# Stage 3: Storage Interfaces and Infrastructure Abstractions

**Risk**: Medium
**Depends on**: Stage 2 (enums and shared types in core)
**Estimated scope**: ~15 new files in core, ~10 modified files in desktop

## Goal

Define the storage abstraction layer and infrastructure interfaces that decouple domain logic from Prisma and desktop-specific singletons. Extract pure derivation functions into core. This stage makes domain extraction (Stages 4-5) possible.

## Problem

Domain services currently depend on:
1. **Prisma resource accessors** (`workspaceAccessor`, `claudeSessionAccessor`) for database access
2. **Infrastructure singletons** (`createLogger`, `configService`) for logging and configuration
3. **Service constants** (`SERVICE_LIMITS`, `SERVICE_INTERVAL_MS`) for tuning parameters

Core cannot depend on any of these. We need interfaces that core defines and desktop implements.

## What Gets Done

### Part A: Storage Interfaces

Define TypeScript interfaces in `packages/core/src/storage/` that mirror the resource accessor method signatures using core's own types (from Stage 2).

#### `WorkspaceStorage`

```typescript
// packages/core/src/storage/workspace-storage.ts
import type {
  CIStatus, KanbanColumn, PRState, RatchetState,
  RunScriptStatus, WorkspaceStatus
} from '../types/enums.js';

/** Flat workspace record -- no Prisma relations */
export interface WorkspaceRecord {
  id: string;
  projectId: string;
  name: string;
  description: string | null;
  status: WorkspaceStatus;
  branchName: string | null;
  isAutoGeneratedBranch: boolean;
  worktreePath: string | null;
  prUrl: string | null;
  prNumber: number | null;
  prState: PRState;
  prReviewState: string | null;
  prCiStatus: CIStatus;
  prUpdatedAt: Date | null;
  prCiFailedAt: Date | null;
  prCiLastNotifiedAt: Date | null;
  prReviewLastCheckedAt: Date | null;
  prReviewLastCommentId: string | null;
  ratchetEnabled: boolean;
  ratchetState: RatchetState;
  ratchetLastCheckedAt: Date | null;
  ratchetLastPushAt: Date | null;
  ratchetActiveSessionId: string | null;
  ratchetLastCiRunId: string | null;
  runScriptStatus: RunScriptStatus;
  hasHadSessions: boolean;
  cachedKanbanColumn: KanbanColumn;
  githubIssueNumber: number | null;
  githubIssueUrl: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface WorkspaceStorage {
  findRawById(id: string): Promise<WorkspaceRecord | null>;
  findRawByIdOrThrow(id: string): Promise<WorkspaceRecord>;
  update(id: string, data: Partial<WorkspaceRecord>): Promise<WorkspaceRecord>;
  transitionWithCas(
    id: string,
    fromStatus: WorkspaceStatus,
    data: Partial<WorkspaceRecord>
  ): Promise<{ count: number }>;
  markHasHadSessions(id: string): Promise<void>;
  clearRatchetActiveSession(workspaceId: string, sessionId: string): Promise<void>;
  findWithPRsForRatchet(): Promise<RatchetWorkspaceView[]>;
  findForRatchetById(id: string): Promise<RatchetWorkspaceView | null>;
  findWithPRsForCIMonitoring(): Promise<CIMonitoringView[]>;
  findWithPRsForReviewMonitoring(): Promise<ReviewMonitoringView[]>;
}

/** Projection for ratchet polling */
export interface RatchetWorkspaceView {
  id: string;
  prUrl: string;
  prNumber: number | null;
  prState: PRState;
  prCiStatus: CIStatus;
  ratchetEnabled: boolean;
  ratchetState: RatchetState;
  ratchetActiveSessionId: string | null;
  ratchetLastCiRunId: string | null;
  prReviewLastCheckedAt: Date | null;
}

/** Projection for CI monitoring */
export interface CIMonitoringView {
  id: string;
  prUrl: string;
  prCiStatus: CIStatus;
  prCiFailedAt: Date | null;
  prCiLastNotifiedAt: Date | null;
}

/** Projection for review monitoring */
export interface ReviewMonitoringView {
  id: string;
  prUrl: string;
  prNumber: number;
  prReviewLastCheckedAt: Date | null;
  prReviewLastCommentId: string | null;
}
```

#### `SessionStorage`

```typescript
// packages/core/src/storage/session-storage.ts
import type { SessionStatus } from '../types/enums.js';

export interface SessionRecord {
  id: string;
  workspaceId: string;
  name: string | null;
  workflow: string;
  model: string;
  status: SessionStatus;
  claudeSessionId: string | null;
  claudeProjectPath: string | null;
  claudeProcessPid: number | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface SessionWithWorkspace extends SessionRecord {
  workspace: {
    id: string;
    projectId: string;
    name: string;
    worktreePath: string | null;
    branchName: string | null;
  };
}

export interface SessionStorage {
  create(data: CreateSessionInput): Promise<SessionRecord>;
  findById(id: string): Promise<SessionWithWorkspace | null>;
  findByWorkspaceId(workspaceId: string, filters?: { status?: SessionStatus; limit?: number }): Promise<SessionRecord[]>;
  update(id: string, data: Partial<SessionRecord>): Promise<SessionRecord>;
  delete(id: string): Promise<SessionRecord>;
  findWithPid(): Promise<SessionRecord[]>;
  acquireFixerSession(input: AcquireFixerSessionInput): Promise<FixerSessionAcquisition>;
}

export interface CreateSessionInput {
  workspaceId: string;
  name?: string;
  workflow: string;
  model?: string;
  claudeProjectPath?: string | null;
}

export interface AcquireFixerSessionInput {
  workspaceId: string;
  workflow: string;
  sessionName: string;
  maxSessions: number;
  claudeProjectPath: string | null;
}

export type FixerSessionAcquisition =
  | { outcome: 'existing'; sessionId: string; status: SessionStatus }
  | { outcome: 'limit_reached' }
  | { outcome: 'created'; sessionId: string };
```

### Part B: Infrastructure Interfaces

#### Logger

```typescript
// packages/core/src/infra/logger.ts
export interface Logger {
  error(message: string, context?: Record<string, unknown>): void;
  warn(message: string, context?: Record<string, unknown>): void;
  info(message: string, context?: Record<string, unknown>): void;
  debug(message: string, context?: Record<string, unknown>): void;
}

export type CreateLogger = (component: string) => Logger;
```

#### Config

```typescript
// packages/core/src/infra/config.ts

/** Service timing/limit constants needed by core domain services */
export interface CoreServiceConfig {
  /** Ratchet polling interval in ms (default: 60000) */
  ratchetIntervalMs: number;
  /** Max concurrent ratchet checks (default: 3) */
  ratchetConcurrency: number;
  /** Max fixer sessions per workspace (default: 5) */
  maxFixerSessions: number;
  /** CI notification cooldown in ms (default: 300000) */
  ciNotificationCooldownMs: number;
  /** Session idle timeout in ms */
  sessionIdleTimeoutMs: number;
}
```

### Part C: Extract Pure Derivation Functions

Move pure business logic that depends only on core types:

| Source | Destination |
|--------|-------------|
| `src/backend/domains/workspace/state/flow-state.ts` | `packages/core/src/workspace/flow-state.ts` |
| `src/backend/domains/workspace/state/init-policy.ts` | `packages/core/src/workspace/init-policy.ts` |
| `src/backend/domains/workspace/state/kanban-state.ts` (pure `computeKanbanColumn` function only) | `packages/core/src/workspace/kanban-column.ts` |

These functions operate on enum values and plain data -- they have no infrastructure dependencies.

Desktop originals become re-exports:

```typescript
// src/backend/domains/workspace/state/flow-state.ts (after migration)
export {
  deriveWorkspaceFlowState,
  deriveWorkspaceFlowStateFromWorkspace,
  type WorkspaceFlowState,
} from '@factory-factory/core';
```

### Part D: Desktop Implements Core Interfaces

Resource accessors gain `implements` clauses:

```typescript
// src/backend/resource_accessors/workspace.accessor.ts
import type { WorkspaceStorage } from '@factory-factory/core';

class WorkspaceAccessor implements WorkspaceStorage {
  // Existing methods already match the interface signatures
  // TypeScript verifies this at compile time
}
```

Similarly for `ClaudeSessionAccessor implements SessionStorage`.

## New Files

```
packages/core/src/
  storage/
    workspace-storage.ts    # WorkspaceStorage interface + record types
    session-storage.ts      # SessionStorage interface + record types
    index.ts                # Barrel re-export
  infra/
    logger.ts               # Logger, CreateLogger interfaces
    config.ts               # CoreServiceConfig interface
    index.ts                # Barrel re-export
  workspace/
    flow-state.ts           # deriveWorkspaceFlowState (from domains/workspace/state/)
    init-policy.ts          # getWorkspaceInitPolicy (from domains/workspace/state/)
    kanban-column.ts        # computeKanbanColumn (from domains/workspace/state/)
    index.ts                # Barrel re-export
  index.ts                  # Updated: re-exports storage/, infra/, workspace/
```

## Modified Files

- `src/backend/resource_accessors/workspace.accessor.ts` -- add `implements WorkspaceStorage`
- `src/backend/resource_accessors/claude-session.accessor.ts` -- add `implements SessionStorage`
- `src/backend/domains/workspace/state/flow-state.ts` -- becomes re-export
- `src/backend/domains/workspace/state/init-policy.ts` -- becomes re-export
- `src/backend/domains/workspace/state/kanban-state.ts` -- pure function part moves; service part stays
- `src/backend/domains/workspace/index.ts` -- update re-exports

## Tests to Add

### Storage interface contract tests

```typescript
// packages/core/src/storage/workspace-storage.test.ts
describe('WorkspaceStorage interface', () => {
  it('WorkspaceRecord has all required fields', () => {
    // Type-level test: compile-time verification
    const record: WorkspaceRecord = {
      id: 'test-id',
      projectId: 'proj-id',
      name: 'Test',
      // ... all required fields
    };
    expect(record.id).toBe('test-id');
  });
});
```

### Pure function tests (ported from desktop)

```typescript
// packages/core/src/workspace/flow-state.test.ts
// Port existing tests from src/backend/domains/workspace/state/flow-state.test.ts
```

```typescript
// packages/core/src/workspace/kanban-column.test.ts
// Port existing tests for computeKanbanColumn
```

## Verification Checklist

```bash
pnpm install
pnpm --filter @factory-factory/core build
pnpm --filter @factory-factory/core test
pnpm typecheck   # Proves accessor classes satisfy storage interfaces
pnpm test        # All existing desktop tests still pass
pnpm check:fix
```

## Risks and Mitigations

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| Storage interface doesn't cover all accessor methods | Medium | Start with methods used by ratchet/session/workspace services; expand as needed in Stage 5 |
| `Partial<WorkspaceRecord>` is too loose for CAS updates | Low | Can tighten with branded types later; structural match is sufficient for extraction |
| Pure function extraction breaks imports | Low | Desktop re-exports maintain backward compatibility |
| `implements` clause reveals method signature mismatches | Medium | This is the point -- fix signatures to match; structural typing helps |

## Design Decisions

### Why interfaces, not abstract classes?

Interfaces impose zero runtime overhead and allow multiple inheritance. Desktop's `WorkspaceAccessor` already exists as a class -- we just add an `implements` clause. No constructor changes needed.

### Why not extract the resource accessors themselves?

Resource accessors are Prisma-coupled by design. They use `prisma.workspace.findMany()`, `prisma.$transaction()`, etc. These are implementation details that vary by storage backend. Core defines the contract; each consumer provides the implementation.

### Why extract pure functions now?

`flow-state.ts`, `init-policy.ts`, and `computeKanbanColumn` are pure derivation functions that operate on enums and plain data. They are the easiest code to extract and they validate the pattern before we tackle stateful services in Stage 5.

## Out of Scope

- Claude protocol types and process management (Stage 4)
- Stateful domain services (Stage 5)
- Moving bridge interface definitions (Stage 5)

import type { Project, UserSettings, Workspace } from '@prisma-gen/client';
import {
  CIStatus,
  KanbanColumn,
  PRState,
  RatchetState,
  RunScriptStatus,
  WorkspaceCreationSource,
  WorkspaceStatus,
} from '@prisma-gen/client';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import type { ExportDataV1, ExportDataV2 } from './data-backup.service';

// Use vi.hoisted so mockTx is available when vi.mock factory runs (vi.mock is hoisted above imports)
const mockTx = vi.hoisted(() => ({
  project: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  workspace: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  claudeSession: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  terminalSession: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  userSettings: {
    findFirst: vi.fn(),
    create: vi.fn(),
  },
}));

// vi.mock is hoisted above imports, so static imports below will receive the mocked module
vi.mock('../db', () => ({
  prisma: {
    project: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    workspace: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    claudeSession: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    terminalSession: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    userSettings: {
      findFirst: vi.fn(),
      create: vi.fn(),
    },
    $transaction: vi.fn((callback) => callback(mockTx)),
  },
}));

import { prisma } from '../db';
import { dataBackupService, exportDataSchema } from './data-backup.service';

describe('DataBackupService', () => {
  const mockProject: Project = {
    id: 'proj-1',
    name: 'Test Project',
    slug: 'test-project',
    repoPath: '/path/to/repo',
    worktreeBasePath: '/path/to/worktrees',
    defaultBranch: 'main',
    githubOwner: 'test-owner',
    githubRepo: 'test-repo',
    isArchived: false,
    startupScriptCommand: 'npm install',
    startupScriptPath: null,
    startupScriptTimeout: 300,
    createdAt: new Date('2025-01-01T00:00:00.000Z'),
    updatedAt: new Date('2025-01-01T00:00:00.000Z'),
  };

  const mockWorkspaceV2: Workspace = {
    id: 'ws-1',
    projectId: 'proj-1',
    name: 'Test Workspace',
    description: 'Test description',
    status: WorkspaceStatus.READY,
    worktreePath: '/path/to/worktree',
    branchName: 'feature/test',
    isAutoGeneratedBranch: true,
    creationSource: WorkspaceCreationSource.GITHUB_ISSUE,
    creationMetadata: { issueNumber: 123 },
    initErrorMessage: null,
    initOutput: 'Init output',
    initStartedAt: new Date('2025-01-01T00:00:00.000Z'),
    initCompletedAt: new Date('2025-01-01T00:05:00.000Z'),
    initRetryCount: 0,
    runScriptCommand: 'npm run dev',
    runScriptCleanupCommand: 'npm run cleanup',
    runScriptPid: 12_345,
    runScriptPort: 3000,
    runScriptStartedAt: new Date('2025-01-01T00:10:00.000Z'),
    runScriptStatus: RunScriptStatus.RUNNING,
    prUrl: 'https://github.com/test/repo/pull/1',
    githubIssueNumber: 123,
    githubIssueUrl: 'https://github.com/test/repo/issues/123',
    prNumber: 1,
    prState: PRState.OPEN,
    prReviewState: 'APPROVED',
    prCiStatus: CIStatus.SUCCESS,
    prUpdatedAt: new Date('2025-01-01T00:15:00.000Z'),
    prCiFailedAt: null,
    prCiLastNotifiedAt: null,
    // Phase 3+ PR review tracking
    prReviewLastCheckedAt: new Date('2025-01-01T00:20:00.000Z'),
    prReviewLastCommentId: 'comment-123',
    // Phase 3+ ratchet tracking
    ratchetEnabled: true,
    ratchetState: RatchetState.READY,
    ratchetLastCheckedAt: new Date('2025-01-01T00:25:00.000Z'),
    ratchetLastPushAt: new Date('2025-01-01T00:30:00.000Z'),
    ratchetActiveSessionId: 'session-123',
    ratchetLastCiRunId: 'run-123',
    ratchetLastNotifiedState: RatchetState.CI_RUNNING,
    hasHadSessions: true,
    cachedKanbanColumn: KanbanColumn.WORKING,
    stateComputedAt: new Date('2025-01-01T00:35:00.000Z'),
    createdAt: new Date('2025-01-01T00:00:00.000Z'),
    updatedAt: new Date('2025-01-01T00:35:00.000Z'),
  };

  const mockUserSettingsV2: UserSettings = {
    id: 'settings-1',
    userId: 'default',
    preferredIde: 'cursor',
    customIdeCommand: null,
    playSoundOnComplete: true,
    notificationSoundPath: '/path/to/sound.mp3',
    workspaceOrder: { 'proj-1': ['ws-1', 'ws-2'] },
    cachedSlashCommands: { commands: [] },
    // Phase 3+ ratchet settings
    ratchetEnabled: true,
    ratchetAutoFixCi: true,
    ratchetAutoFixReviews: false,
    ratchetAutoMerge: false,
    ratchetAllowedReviewers: ['user1', 'user2'],
    createdAt: new Date('2025-01-01T00:00:00.000Z'),
    updatedAt: new Date('2025-01-01T00:00:00.000Z'),
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('exportData', () => {
    it('should export data in v2 format with all fields', async () => {
      vi.mocked(prisma.project.findMany).mockResolvedValue([mockProject]);
      vi.mocked(prisma.workspace.findMany).mockResolvedValue([mockWorkspaceV2]);
      vi.mocked(prisma.claudeSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.terminalSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.userSettings.findFirst).mockResolvedValue(mockUserSettingsV2);

      const result = await dataBackupService.exportData('1.0.0');

      expect(result.meta.schemaVersion).toBe(2);
      expect(result.meta.version).toBe('1.0.0');
      expect(result.data.projects).toHaveLength(1);
      expect(result.data.workspaces).toHaveLength(1);

      // Verify all workspace fields are exported
      const exportedWorkspace = result.data.workspaces[0];
      expect(exportedWorkspace).toBeDefined();
      expect(exportedWorkspace?.ratchetEnabled).toBe(true);
      expect(exportedWorkspace?.ratchetState).toBe(RatchetState.READY);
      expect(exportedWorkspace?.ratchetLastCheckedAt).toBe('2025-01-01T00:25:00.000Z');
      expect(exportedWorkspace?.ratchetActiveSessionId).toBe('session-123');
      expect(exportedWorkspace?.ratchetLastCiRunId).toBe('run-123');
      expect(exportedWorkspace?.prReviewLastCheckedAt).toBe('2025-01-01T00:20:00.000Z');
      expect(exportedWorkspace?.prReviewLastCommentId).toBe('comment-123');

      // Verify all user settings fields are exported
      const exportedSettings = result.data.userSettings;
      expect(exportedSettings).not.toBeNull();
      expect(exportedSettings?.ratchetEnabled).toBe(true);
      expect(exportedSettings?.ratchetAutoFixCi).toBe(true);
      expect(exportedSettings?.ratchetAutoFixReviews).toBe(false);
      expect(exportedSettings?.ratchetAutoMerge).toBe(false);
      expect(exportedSettings?.ratchetAllowedReviewers).toEqual(['user1', 'user2']);

      // Verify cached data is excluded
      expect('workspaceOrder' in (exportedSettings ?? {})).toBe(false);
      expect('cachedSlashCommands' in (exportedSettings ?? {})).toBe(false);
    });

    it('should handle null user settings', async () => {
      vi.mocked(prisma.project.findMany).mockResolvedValue([]);
      vi.mocked(prisma.workspace.findMany).mockResolvedValue([]);
      vi.mocked(prisma.claudeSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.terminalSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.userSettings.findFirst).mockResolvedValue(null);

      const result = await dataBackupService.exportData('1.0.0');

      expect(result.data.userSettings).toBeNull();
    });

    it('should export valid v2 schema', async () => {
      vi.mocked(prisma.project.findMany).mockResolvedValue([mockProject]);
      vi.mocked(prisma.workspace.findMany).mockResolvedValue([mockWorkspaceV2]);
      vi.mocked(prisma.claudeSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.terminalSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.userSettings.findFirst).mockResolvedValue(mockUserSettingsV2);

      const result = await dataBackupService.exportData('1.0.0');

      // Should validate against the schema
      const parseResult = exportDataSchema.safeParse(result);
      expect(parseResult.success).toBe(true);
    });
  });

  describe('importData - v2 round-trip', () => {
    it('should import v2 data without loss', async () => {
      const exportedData: ExportDataV2 = {
        meta: {
          exportedAt: '2025-01-01T00:00:00.000Z',
          version: '1.0.0',
          schemaVersion: 2,
        },
        data: {
          projects: [
            {
              id: 'proj-1',
              name: 'Test Project',
              slug: 'test-project',
              repoPath: '/path/to/repo',
              worktreeBasePath: '/path/to/worktrees',
              defaultBranch: 'main',
              githubOwner: 'test-owner',
              githubRepo: 'test-repo',
              isArchived: false,
              startupScriptCommand: 'npm install',
              startupScriptPath: null,
              startupScriptTimeout: 300,
              createdAt: '2025-01-01T00:00:00.000Z',
              updatedAt: '2025-01-01T00:00:00.000Z',
            },
          ],
          workspaces: [
            {
              id: 'ws-1',
              projectId: 'proj-1',
              name: 'Test Workspace',
              description: 'Test description',
              status: WorkspaceStatus.READY,
              worktreePath: '/path/to/worktree',
              branchName: 'feature/test',
              isAutoGeneratedBranch: true,
              creationSource: WorkspaceCreationSource.GITHUB_ISSUE,
              creationMetadata: { issueNumber: 123 },
              initErrorMessage: null,
              initOutput: 'Init output',
              initStartedAt: '2025-01-01T00:00:00.000Z',
              initCompletedAt: '2025-01-01T00:05:00.000Z',
              initRetryCount: 0,
              runScriptCommand: 'npm run dev',
              runScriptCleanupCommand: 'npm run cleanup',
              runScriptPid: 12_345,
              runScriptPort: 3000,
              runScriptStartedAt: '2025-01-01T00:10:00.000Z',
              runScriptStatus: RunScriptStatus.RUNNING,
              prUrl: 'https://github.com/test/repo/pull/1',
              githubIssueNumber: 123,
              githubIssueUrl: 'https://github.com/test/repo/issues/123',
              prNumber: 1,
              prState: PRState.OPEN,
              prReviewState: 'APPROVED',
              prCiStatus: CIStatus.SUCCESS,
              prUpdatedAt: '2025-01-01T00:15:00.000Z',
              prCiFailedAt: null,
              prCiLastNotifiedAt: null,
              prReviewLastCheckedAt: '2025-01-01T00:20:00.000Z',
              prReviewLastCommentId: 'comment-123',
              ratchetEnabled: true,
              ratchetState: RatchetState.READY,
              ratchetLastCheckedAt: '2025-01-01T00:25:00.000Z',
              ratchetLastPushAt: '2025-01-01T00:30:00.000Z',
              ratchetActiveSessionId: 'session-123',
              ratchetLastCiRunId: 'run-123',
              ratchetLastNotifiedState: RatchetState.CI_RUNNING,
              hasHadSessions: true,
              cachedKanbanColumn: KanbanColumn.WORKING,
              stateComputedAt: '2025-01-01T00:35:00.000Z',
              createdAt: '2025-01-01T00:00:00.000Z',
              updatedAt: '2025-01-01T00:35:00.000Z',
            },
          ],
          claudeSessions: [],
          terminalSessions: [],
          userSettings: {
            preferredIde: 'cursor',
            customIdeCommand: null,
            playSoundOnComplete: true,
            notificationSoundPath: '/path/to/sound.mp3',
            ratchetEnabled: true,
            ratchetAutoFixCi: true,
            ratchetAutoFixReviews: false,
            ratchetAutoMerge: false,
            ratchetAllowedReviewers: ['user1', 'user2'],
          },
        },
      };

      // Mock transaction client methods
      vi.mocked(mockTx.project.findUnique)
        .mockResolvedValueOnce(null) // ID check during project import
        .mockResolvedValueOnce(null) // slug check during project import
        .mockResolvedValue(mockProject); // workspace import checks
      vi.mocked(mockTx.project.create).mockResolvedValue(mockProject);
      vi.mocked(mockTx.workspace.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.workspace.create).mockResolvedValue(mockWorkspaceV2);
      vi.mocked(mockTx.userSettings.findFirst).mockResolvedValue(null);
      vi.mocked(mockTx.userSettings.create).mockResolvedValue(mockUserSettingsV2);

      const result = await dataBackupService.importData(exportedData);

      expect(result.projects.imported).toBe(1);
      expect(result.workspaces.imported).toBe(1);
      expect(result.userSettings.imported).toBe(true);

      // Verify workspace was created with all ratchet fields
      expect(mockTx.workspace.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          ratchetEnabled: true,
          ratchetState: RatchetState.READY,
          ratchetActiveSessionId: 'session-123',
          ratchetLastCiRunId: 'run-123',
          prReviewLastCommentId: 'comment-123',
        }),
      });

      // Verify user settings was created with all ratchet fields
      expect(mockTx.userSettings.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          ratchetEnabled: true,
          ratchetAutoFixCi: true,
          ratchetAutoFixReviews: false,
          ratchetAutoMerge: false,
        }),
      });
    });
  });

  describe('importData - v1 compatibility', () => {
    it('should import v1 data with migration to v2 defaults', async () => {
      const v1Data: ExportDataV1 = {
        meta: {
          exportedAt: '2024-12-01T00:00:00.000Z',
          version: '0.9.0',
          schemaVersion: 1,
        },
        data: {
          projects: [
            {
              id: 'proj-1',
              name: 'Test Project',
              slug: 'test-project',
              repoPath: '/path/to/repo',
              worktreeBasePath: '/path/to/worktrees',
              defaultBranch: 'main',
              githubOwner: null,
              githubRepo: null,
              isArchived: false,
              startupScriptCommand: null,
              startupScriptPath: null,
              startupScriptTimeout: 300,
              createdAt: '2024-12-01T00:00:00.000Z',
              updatedAt: '2024-12-01T00:00:00.000Z',
            },
          ],
          workspaces: [
            {
              id: 'ws-1',
              projectId: 'proj-1',
              name: 'Old Workspace',
              description: null,
              status: WorkspaceStatus.READY,
              worktreePath: '/path/to/worktree',
              branchName: 'main',
              // v1 may not have these fields
              initErrorMessage: null,
              initOutput: null,
              initStartedAt: null,
              initCompletedAt: null,
              initRetryCount: 0,
              runScriptCommand: null,
              runScriptCleanupCommand: null,
              runScriptPid: null,
              runScriptPort: null,
              runScriptStartedAt: null,
              runScriptStatus: RunScriptStatus.IDLE,
              prUrl: null,
              githubIssueNumber: null,
              githubIssueUrl: null,
              prNumber: null,
              prState: PRState.NONE,
              prReviewState: null,
              prCiStatus: CIStatus.UNKNOWN,
              prUpdatedAt: null,
              prCiFailedAt: null,
              prCiLastNotifiedAt: null,
              hasHadSessions: false,
              cachedKanbanColumn: KanbanColumn.WAITING,
              stateComputedAt: null,
              createdAt: '2024-12-01T00:00:00.000Z',
              updatedAt: '2024-12-01T00:00:00.000Z',
            },
          ],
          claudeSessions: [],
          terminalSessions: [],
          userSettings: {
            preferredIde: 'cursor',
            customIdeCommand: null,
            playSoundOnComplete: true,
            notificationSoundPath: null,
          },
        },
      };

      // Mock transaction client methods
      vi.mocked(mockTx.project.findUnique)
        .mockResolvedValueOnce(null) // ID check during project import
        .mockResolvedValueOnce(null) // slug check during project import
        .mockResolvedValue(mockProject); // workspace import checks
      vi.mocked(mockTx.project.create).mockResolvedValue(mockProject);
      vi.mocked(mockTx.workspace.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.workspace.create).mockResolvedValue(mockWorkspaceV2);
      vi.mocked(mockTx.userSettings.findFirst).mockResolvedValue(null);
      vi.mocked(mockTx.userSettings.create).mockResolvedValue(mockUserSettingsV2);

      const result = await dataBackupService.importData(v1Data);

      expect(result.projects.imported).toBe(1);
      expect(result.workspaces.imported).toBe(1);
      expect(result.userSettings.imported).toBe(true);

      // Verify workspace was created with v2 defaults for missing fields
      expect(mockTx.workspace.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          // v1 fields should be preserved
          id: 'ws-1',
          name: 'Old Workspace',
          // v2 fields should have defaults
          isAutoGeneratedBranch: false,
          creationSource: WorkspaceCreationSource.MANUAL,
          creationMetadata: undefined, // null converted to undefined for Prisma
          ratchetEnabled: true,
          ratchetState: RatchetState.IDLE,
          ratchetLastCheckedAt: null,
          ratchetLastPushAt: null,
          ratchetActiveSessionId: null,
          ratchetLastCiRunId: null,
          ratchetLastNotifiedState: null,
          prReviewLastCheckedAt: null,
          prReviewLastCommentId: null,
        }),
      });

      // Verify user settings was created with v2 defaults
      expect(mockTx.userSettings.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          preferredIde: 'cursor',
          ratchetEnabled: false,
          ratchetAutoFixCi: true,
          ratchetAutoFixReviews: true,
          ratchetAutoMerge: false,
        }),
      });
    });

    it('should handle v1 PAUSED runScriptStatus migration', async () => {
      const v1Data: ExportDataV1 = {
        meta: {
          exportedAt: '2024-12-01T00:00:00.000Z',
          version: '0.9.0',
          schemaVersion: 1,
        },
        data: {
          projects: [],
          workspaces: [
            {
              id: 'ws-1',
              projectId: 'proj-1',
              name: 'Old Workspace',
              description: null,
              status: WorkspaceStatus.READY,
              worktreePath: '/path',
              branchName: 'main',
              initErrorMessage: null,
              initOutput: null,
              initStartedAt: null,
              initCompletedAt: null,
              initRetryCount: 0,
              runScriptCommand: null,
              runScriptCleanupCommand: null,
              runScriptPid: null,
              runScriptPort: null,
              runScriptStartedAt: null,
              // Cast to RunScriptStatus to simulate old v1 data with PAUSED value
              runScriptStatus: 'PAUSED' as unknown as RunScriptStatus,
              prUrl: null,
              githubIssueNumber: null,
              githubIssueUrl: null,
              prNumber: null,
              prState: PRState.NONE,
              prReviewState: null,
              prCiStatus: CIStatus.UNKNOWN,
              prUpdatedAt: null,
              prCiFailedAt: null,
              prCiLastNotifiedAt: null,
              hasHadSessions: false,
              cachedKanbanColumn: KanbanColumn.WAITING,
              stateComputedAt: null,
              createdAt: '2024-12-01T00:00:00.000Z',
              updatedAt: '2024-12-01T00:00:00.000Z',
            },
          ],
          claudeSessions: [],
          terminalSessions: [],
          userSettings: null,
        },
      };

      // Mock transaction client methods
      vi.mocked(mockTx.project.findUnique).mockResolvedValue(mockProject);
      vi.mocked(mockTx.workspace.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.workspace.create).mockResolvedValue(mockWorkspaceV2);

      await dataBackupService.importData(v1Data);

      // Verify PAUSED was converted to IDLE
      expect(mockTx.workspace.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          runScriptStatus: RunScriptStatus.IDLE,
        }),
      });
    });
  });

  describe('importData - skip existing records', () => {
    it('should skip projects that already exist', async () => {
      const exportedData: ExportDataV2 = {
        meta: {
          exportedAt: '2025-01-01T00:00:00.000Z',
          version: '1.0.0',
          schemaVersion: 2,
        },
        data: {
          projects: [
            {
              id: 'proj-1',
              name: 'Test Project',
              slug: 'test-project',
              repoPath: '/path',
              worktreeBasePath: '/path',
              defaultBranch: 'main',
              githubOwner: null,
              githubRepo: null,
              isArchived: false,
              startupScriptCommand: null,
              startupScriptPath: null,
              startupScriptTimeout: 300,
              createdAt: '2025-01-01T00:00:00.000Z',
              updatedAt: '2025-01-01T00:00:00.000Z',
            },
          ],
          workspaces: [],
          claudeSessions: [],
          terminalSessions: [],
          userSettings: null,
        },
      };

      vi.mocked(mockTx.project.findUnique).mockResolvedValue(mockProject);

      const result = await dataBackupService.importData(exportedData);

      expect(result.projects.skipped).toBe(1);
      expect(result.projects.imported).toBe(0);
      expect(mockTx.project.create).not.toHaveBeenCalled();
    });

    it('should skip workspaces with missing projects', async () => {
      const exportedData: ExportDataV2 = {
        meta: {
          exportedAt: '2025-01-01T00:00:00.000Z',
          version: '1.0.0',
          schemaVersion: 2,
        },
        data: {
          projects: [],
          workspaces: [
            {
              id: 'ws-1',
              projectId: 'missing-project',
              name: 'Orphaned Workspace',
              description: null,
              status: WorkspaceStatus.NEW,
              worktreePath: null,
              branchName: null,
              isAutoGeneratedBranch: false,
              creationSource: WorkspaceCreationSource.MANUAL,
              creationMetadata: null,
              initErrorMessage: null,
              initOutput: null,
              initStartedAt: null,
              initCompletedAt: null,
              initRetryCount: 0,
              runScriptCommand: null,
              runScriptCleanupCommand: null,
              runScriptPid: null,
              runScriptPort: null,
              runScriptStartedAt: null,
              runScriptStatus: RunScriptStatus.IDLE,
              prUrl: null,
              githubIssueNumber: null,
              githubIssueUrl: null,
              prNumber: null,
              prState: PRState.NONE,
              prReviewState: null,
              prCiStatus: CIStatus.UNKNOWN,
              prUpdatedAt: null,
              prCiFailedAt: null,
              prCiLastNotifiedAt: null,
              prReviewLastCheckedAt: null,
              prReviewLastCommentId: null,
              ratchetEnabled: true,
              ratchetState: RatchetState.IDLE,
              ratchetLastCheckedAt: null,
              ratchetLastPushAt: null,
              ratchetActiveSessionId: null,
              ratchetLastCiRunId: null,
              ratchetLastNotifiedState: null,
              hasHadSessions: false,
              cachedKanbanColumn: KanbanColumn.WAITING,
              stateComputedAt: null,
              createdAt: '2025-01-01T00:00:00.000Z',
              updatedAt: '2025-01-01T00:00:00.000Z',
            },
          ],
          claudeSessions: [],
          terminalSessions: [],
          userSettings: null,
        },
      };

      vi.mocked(mockTx.workspace.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.project.findUnique).mockResolvedValue(null);

      const result = await dataBackupService.importData(exportedData);

      expect(result.workspaces.skipped).toBe(1);
      expect(result.workspaces.imported).toBe(0);
      expect(mockTx.workspace.create).not.toHaveBeenCalled();
    });
  });
});

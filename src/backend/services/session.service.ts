import { SessionStatus } from '@prisma-gen/client';
import { ClaudeClient, type ClaudeClientOptions } from '../claude/index';
import { ClaudeProcess, type ClaudeProcessOptions, type ResourceUsage } from '../claude/process';
import {
  getAllProcesses,
  getProcess,
  isAnyProcessWorking,
  isProcessWorking,
  type RegisteredProcess,
} from '../claude/registry';
import { isAutoGeneratedBranchName } from '../clients/git.client';
import { buildBranchRenameInstruction } from '../prompts/branch-rename';
import { getWorkflowContent } from '../prompts/workflows';
import { claudeSessionAccessor, workspaceAccessor } from '../resource_accessors/index';
import { githubCLIService } from './github-cli.service';
import { createLogger } from './logger.service';

const logger = createLogger('session');

// Track sessions currently being stopped to prevent race conditions
const stoppingInProgress = new Set<string>();

class SessionService {
  // Track ClaudeClients by dbSessionId - single source of truth for client lifecycle
  private readonly clients = new Map<string, ClaudeClient>();
  private readonly pendingCreation = new Map<string, Promise<ClaudeClient>>();
  /**
   * Start a Claude session
   */
  async startClaudeSession(sessionId: string, options?: { initialPrompt?: string }): Promise<void> {
    const session = await claudeSessionAccessor.findById(sessionId);
    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    if (session.status === SessionStatus.RUNNING) {
      throw new Error('Session is already running');
    }
    if (stoppingInProgress.has(sessionId)) {
      throw new Error('Session is currently being stopped');
    }

    const workspace = await workspaceAccessor.findById(session.workspaceId);
    if (!workspace) {
      throw new Error(`Workspace not found: ${session.workspaceId}`);
    }

    const workingDir = workspace.worktreePath;
    if (!workingDir) {
      throw new Error('Workspace has no worktree path');
    }

    // Mark workspace as having had sessions (for kanban backlog/waiting distinction)
    // Uses atomic conditional update - safe to call even if already true
    await workspaceAccessor.markHasHadSessions(workspace.id);

    // Get workflow prompt content
    const workflowPrompt = getWorkflowContent(session.workflow);
    logger.info('Loaded workflow prompt', {
      sessionId,
      workflow: session.workflow,
      hasPrompt: !!workflowPrompt,
      promptLength: workflowPrompt?.length ?? 0,
      promptPreview: workflowPrompt?.slice(0, 200) ?? '(none)',
    });

    // Build process options
    const processOptions: ClaudeProcessOptions = {
      workingDir,
      model: session.model,
      resumeClaudeSessionId: session.claudeSessionId ?? undefined,
      initialPrompt: options?.initialPrompt ?? 'Continue with the task.',
      permissionMode: 'bypassPermissions',
      systemPrompt: workflowPrompt ?? undefined,
      sessionId, // Enable auto-registration in process registry
    };

    // Spawn Claude process (auto-registers in global registry)
    const process = await ClaudeProcess.spawn(processOptions);
    const pid = process.getPid();

    // Update session with process info
    await claudeSessionAccessor.update(sessionId, {
      status: SessionStatus.RUNNING,
      claudeProcessPid: pid ?? null,
    });

    // Set up event handlers
    process.on('session_id', async (claudeSessionId) => {
      try {
        await claudeSessionAccessor.update(sessionId, { claudeSessionId });
      } catch (error) {
        logger.warn('Failed to update session with Claude session ID', {
          sessionId,
          claudeSessionId,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    });

    process.on('exit', async () => {
      // Process auto-unregisters from global registry on exit

      // Skip status update if stopClaudeSession is handling this (prevents race condition)
      // When stopping, the stopClaudeSession function will set the correct status (IDLE)
      if (stoppingInProgress.has(sessionId)) {
        logger.debug('Skipping exit handler status update - stop in progress', { sessionId });
        return;
      }

      try {
        await claudeSessionAccessor.update(sessionId, {
          status: SessionStatus.COMPLETED,
          claudeProcessPid: null,
        });
      } catch (error) {
        logger.warn('Failed to update session status on exit', {
          sessionId,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    });

    logger.info('Claude session started', { sessionId, pid });
  }

  /**
   * Stop a Claude session gracefully.
   * Checks the clients Map first, then falls back to the process registry.
   */
  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: dual-path stop logic with fallback to process registry
  async stopClaudeSession(sessionId: string): Promise<void> {
    // Check if already stopping to prevent concurrent stop attempts
    if (stoppingInProgress.has(sessionId)) {
      logger.debug('Session stop already in progress', { sessionId });
      return;
    }

    // Check clients Map first (preferred path)
    const client = this.clients.get(sessionId);
    if (client) {
      stoppingInProgress.add(sessionId);
      try {
        await client.stop();
      } catch (error) {
        logger.warn('Failed to stop client gracefully, forcing kill', {
          sessionId,
          error: error instanceof Error ? error.message : String(error),
        });
        client.kill();
      } finally {
        stoppingInProgress.delete(sessionId);
        this.clients.delete(sessionId);
      }
    } else {
      // Fallback to process registry (for processes started via legacy path)
      const process = getProcess(sessionId);
      if (process) {
        stoppingInProgress.add(sessionId);
        try {
          await process.interrupt();
        } catch (error) {
          logger.error('Failed to interrupt process', {
            sessionId,
            error: error instanceof Error ? error.message : String(error),
          });
        } finally {
          stoppingInProgress.delete(sessionId);
        }
      }
    }

    // Always update DB status
    await claudeSessionAccessor.update(sessionId, {
      status: SessionStatus.IDLE,
      claudeProcessPid: null,
    });

    logger.info('Claude session stopped', { sessionId });
  }

  /**
   * Stop all Claude sessions for a workspace
   */
  async stopWorkspaceSessions(workspaceId: string): Promise<void> {
    const sessions = await claudeSessionAccessor.findByWorkspaceId(workspaceId);

    for (const session of sessions) {
      if (session.status === SessionStatus.RUNNING || getProcess(session.id)) {
        try {
          await this.stopClaudeSession(session.id);
        } catch (error) {
          logger.error('Failed to stop workspace session', {
            sessionId: session.id,
            workspaceId,
            error: error instanceof Error ? error.message : String(error),
          });
        }
      }
    }

    logger.info('Stopped all workspace sessions', { workspaceId, count: sessions.length });
  }

  // ===========================================================================
  // Client Lifecycle (Single Source of Truth)
  // ===========================================================================

  /**
   * Get or create a ClaudeClient for a session.
   * This is the single source of truth for client lifecycle management.
   *
   * @param sessionId - The database session ID
   * @param options - Optional client configuration overrides
   * @returns The ClaudeClient instance
   */
  async getOrCreateClient(
    sessionId: string,
    options?: {
      thinkingEnabled?: boolean;
      permissionMode?: 'bypassPermissions' | 'plan';
      model?: string;
    }
  ): Promise<ClaudeClient> {
    // Return existing running client
    const existing = this.clients.get(sessionId);
    if (existing?.isRunning()) {
      logger.debug('Returning existing running client', { sessionId });
      return existing;
    }

    // Handle concurrent creation
    const pending = this.pendingCreation.get(sessionId);
    if (pending) {
      logger.debug('Waiting for pending client creation', { sessionId });
      return pending;
    }

    // Create new client
    logger.info('Creating new ClaudeClient', { sessionId, options });
    const createPromise = this.createClient(sessionId, options);
    this.pendingCreation.set(sessionId, createPromise);

    try {
      return await createPromise;
    } finally {
      this.pendingCreation.delete(sessionId);
    }
  }

  /**
   * Get an existing ClaudeClient without creating one.
   *
   * @param sessionId - The database session ID
   * @returns The ClaudeClient if it exists and is running, undefined otherwise
   */
  getClient(sessionId: string): ClaudeClient | undefined {
    const client = this.clients.get(sessionId);
    return client?.isRunning() ? client : undefined;
  }

  /**
   * Internal: Create a new ClaudeClient for a session.
   */
  private async createClient(
    sessionId: string,
    options?: {
      thinkingEnabled?: boolean;
      permissionMode?: 'bypassPermissions' | 'plan';
      model?: string;
    }
  ): Promise<ClaudeClient> {
    const sessionOpts = await this.getSessionOptions(sessionId);
    if (!sessionOpts) {
      throw new Error(`Session not found: ${sessionId}`);
    }

    // Mark workspace as having sessions
    const session = await claudeSessionAccessor.findById(sessionId);
    if (session) {
      await workspaceAccessor.markHasHadSessions(session.workspaceId);
    }

    // Build client options
    const clientOptions: ClaudeClientOptions = {
      workingDir: sessionOpts.workingDir,
      resumeClaudeSessionId: sessionOpts.resumeClaudeSessionId,
      systemPrompt: sessionOpts.systemPrompt,
      model: options?.model ?? sessionOpts.model,
      permissionMode: options?.permissionMode ?? 'bypassPermissions',
      includePartialMessages: true,
      thinkingEnabled: options?.thinkingEnabled,
      sessionId, // Enable auto-registration in process registry
    };

    // Create client
    const client = await ClaudeClient.create(clientOptions);
    this.clients.set(sessionId, client);

    // Set up DB update handlers
    this.setupClientDbHandlers(sessionId, client);

    // Update DB status
    await claudeSessionAccessor.update(sessionId, {
      status: SessionStatus.RUNNING,
      claudeProcessPid: client.getPid() ?? null,
    });

    logger.info('ClaudeClient created', {
      sessionId,
      pid: client.getPid(),
      model: options?.model ?? sessionOpts.model,
    });

    return client;
  }

  /**
   * Internal: Set up handlers that update DB on client events.
   */
  private setupClientDbHandlers(sessionId: string, client: ClaudeClient): void {
    client.on('session_id', async (claudeSessionId) => {
      try {
        await claudeSessionAccessor.update(sessionId, { claudeSessionId });
        logger.debug('Updated session with claudeSessionId', { sessionId, claudeSessionId });
      } catch (error) {
        logger.warn('Failed to update session with claudeSessionId', {
          sessionId,
          claudeSessionId,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    });

    client.on('exit', async () => {
      this.clients.delete(sessionId);

      // Skip status update if stopClaudeSession is handling this
      if (stoppingInProgress.has(sessionId)) {
        logger.debug('Skipping exit handler status update - stop in progress', { sessionId });
        return;
      }

      try {
        await claudeSessionAccessor.update(sessionId, {
          status: SessionStatus.COMPLETED,
          claudeProcessPid: null,
        });
        logger.debug('Updated session status to COMPLETED on exit', { sessionId });
      } catch (error) {
        logger.warn('Failed to update session status on exit', {
          sessionId,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    });
  }

  // ===========================================================================
  // Process Registry Access
  // ===========================================================================

  /**
   * Get an active Claude process from the global registry.
   * Returns a RegisteredProcess interface with status, lifecycle, and resource methods.
   */
  getClaudeProcess(sessionId: string): RegisteredProcess | undefined {
    return getProcess(sessionId);
  }

  /**
   * Check if a session is running in memory
   */
  isSessionRunning(sessionId: string): boolean {
    const process = getProcess(sessionId);
    return process?.isRunning() ?? false;
  }

  /**
   * Check if a session is actively working (not just alive, but processing)
   */
  isSessionWorking(sessionId: string): boolean {
    return isProcessWorking(sessionId);
  }

  /**
   * Check if any session in the given list is actively working
   */
  isAnySessionWorking(sessionIds: string[]): boolean {
    return isAnyProcessWorking(sessionIds);
  }

  /**
   * Get session options for creating a Claude client.
   * Loads the workflow prompt from the database session.
   * This is the single source of truth for session configuration.
   */
  async getSessionOptions(sessionId: string): Promise<{
    workingDir: string;
    resumeClaudeSessionId: string | undefined;
    systemPrompt: string | undefined;
    model: string;
  } | null> {
    const session = await claudeSessionAccessor.findById(sessionId);
    if (!session) {
      logger.warn('Session not found when getting options', { sessionId });
      return null;
    }

    const workspace = await workspaceAccessor.findById(session.workspaceId);
    if (!workspace?.worktreePath) {
      logger.warn('Workspace or worktree not found', {
        sessionId,
        workspaceId: session.workspaceId,
      });
      return null;
    }

    // Load workflow prompt
    const workflowPrompt = getWorkflowContent(session.workflow);
    logger.info('Loaded workflow prompt for session options', {
      sessionId,
      workflow: session.workflow,
      hasPrompt: !!workflowPrompt,
      promptLength: workflowPrompt?.length ?? 0,
    });

    // Build system prompt, optionally prepending branch rename instructions
    let systemPrompt = workflowPrompt ?? undefined;
    if (workspace.branchName && isAutoGeneratedBranchName(workspace.branchName)) {
      // Get authenticated GitHub username for branch prefix
      const githubUsername = await githubCLIService.getAuthenticatedUsername();

      const branchRenameInstruction = buildBranchRenameInstruction({
        branchPrefix: githubUsername ?? '',
        workspaceName: workspace.name,
        workspaceDescription: workspace.description ?? undefined,
      });
      systemPrompt = branchRenameInstruction + (workflowPrompt ?? '');
      logger.info('Injected branch rename instruction', {
        sessionId,
        branchName: workspace.branchName,
        branchPrefix: githubUsername,
      });
    }

    return {
      workingDir: workspace.worktreePath,
      resumeClaudeSessionId: session.claudeSessionId ?? undefined,
      systemPrompt,
      model: session.model,
    };
  }

  /**
   * Get all active Claude processes for admin view
   */
  getAllActiveProcesses(): Array<{
    sessionId: string;
    pid: number | undefined;
    status: string;
    isRunning: boolean;
    resourceUsage: ResourceUsage | null;
    idleTimeMs: number;
  }> {
    const processes: Array<{
      sessionId: string;
      pid: number | undefined;
      status: string;
      isRunning: boolean;
      resourceUsage: ResourceUsage | null;
      idleTimeMs: number;
    }> = [];

    for (const [sessionId, process] of getAllProcesses()) {
      processes.push({
        sessionId,
        pid: process.getPid(),
        status: process.getStatus(),
        isRunning: process.isRunning(),
        resourceUsage: process.getResourceUsage(),
        idleTimeMs: process.getIdleTimeMs(),
      });
    }

    return processes;
  }

  /**
   * Get all active clients for cleanup purposes.
   * Returns an iterator of [sessionId, client] pairs.
   */
  getAllClients(): IterableIterator<[string, ClaudeClient]> {
    return this.clients.entries();
  }

  /**
   * Stop all active clients during shutdown.
   * @param timeoutMs - Timeout for each client stop operation
   */
  async stopAllClients(timeoutMs = 5000): Promise<void> {
    const stopPromises: Promise<void>[] = [];

    for (const [sessionId, client] of this.clients) {
      let didTimeout = false;
      const stopPromise = Promise.race([
        (async () => {
          try {
            await client.stop();
          } catch {
            client.kill();
          }
        })(),
        new Promise<void>((resolve) =>
          setTimeout(() => {
            didTimeout = true;
            resolve();
          }, timeoutMs)
        ),
      ]).then(() => {
        if (didTimeout) {
          logger.warn('Client stop timed out, force killing', { sessionId });
        }
        try {
          client.kill();
        } catch {
          // Ignore kill errors
        }
      });

      stopPromises.push(stopPromise);
      logger.debug('Stopping chat client', { sessionId });
    }

    await Promise.all(stopPromises);

    // Clean up listeners and clear map
    for (const client of this.clients.values()) {
      client.removeAllListeners();
    }
    this.clients.clear();

    logger.info('All clients stopped and cleaned up');
  }
}

export const sessionService = new SessionService();

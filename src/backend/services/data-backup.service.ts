/**
 * Data Backup Service
 *
 * Handles export and import of database data for backup/restore purposes.
 * Used when database migrations require a reset.
 */

import {
  CIStatus,
  KanbanColumn,
  PRState,
  type Prisma,
  RatchetState,
  RunScriptStatus,
  SessionStatus,
  WorkspaceCreationSource,
  WorkspaceStatus,
} from '@prisma-gen/client';
import { z } from 'zod';
import { prisma } from '../db';
import { createLogger } from './logger.service';

type TransactionClient = Prisma.TransactionClient;

const logger = createLogger('data-backup');

// ============================================================================
// Schemas
// ============================================================================

const exportedProjectSchema = z.object({
  id: z.string(),
  name: z.string(),
  slug: z.string(),
  repoPath: z.string(),
  worktreeBasePath: z.string(),
  defaultBranch: z.string(),
  githubOwner: z.string().nullable(),
  githubRepo: z.string().nullable(),
  isArchived: z.boolean(),
  startupScriptCommand: z.string().nullable(),
  startupScriptPath: z.string().nullable(),
  startupScriptTimeout: z.number(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

// Schema v1 - for importing legacy backups
const exportedWorkspaceSchemaV1 = z.object({
  id: z.string(),
  projectId: z.string(),
  name: z.string(),
  description: z.string().nullable(),
  status: z.nativeEnum(WorkspaceStatus),
  worktreePath: z.string().nullable(),
  branchName: z.string().nullable(),
  // Optional for backward compatibility with pre-Phase-3 backups
  isAutoGeneratedBranch: z.boolean().optional(),
  creationSource: z.nativeEnum(WorkspaceCreationSource).optional(),
  creationMetadata: z.unknown().nullable().optional(),
  initErrorMessage: z.string().nullable(),
  initOutput: z.string().nullable(),
  initStartedAt: z.string().nullable(),
  initCompletedAt: z.string().nullable(),
  initRetryCount: z.number(),
  runScriptCommand: z.string().nullable(),
  runScriptCleanupCommand: z.string().nullable(),
  runScriptPid: z.number().nullable(),
  runScriptPort: z.number().nullable(),
  runScriptStartedAt: z.string().nullable(),
  // Accept both old SessionStatus and new RunScriptStatus values for backward compatibility
  runScriptStatus: z.union([z.nativeEnum(RunScriptStatus), z.literal('PAUSED')]),
  prUrl: z.string().nullable(),
  githubIssueNumber: z.number().nullable(),
  githubIssueUrl: z.string().nullable(),
  prNumber: z.number().nullable(),
  prState: z.nativeEnum(PRState),
  prReviewState: z.string().nullable(),
  prCiStatus: z.nativeEnum(CIStatus),
  prUpdatedAt: z.string().nullable(),
  prCiFailedAt: z.string().nullable(),
  prCiLastNotifiedAt: z.string().nullable(),
  hasHadSessions: z.boolean(),
  cachedKanbanColumn: z.nativeEnum(KanbanColumn),
  stateComputedAt: z.string().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

// Schema v2 - includes all Phase 3 and Phase 4 fields
const exportedWorkspaceSchemaV2 = exportedWorkspaceSchemaV1.extend({
  // PR review tracking (Phase 3+)
  prReviewLastCheckedAt: z.string().nullable(),
  prReviewLastCommentId: z.string().nullable(),
  // Ratchet tracking fields (Phase 3+)
  ratchetEnabled: z.boolean(),
  ratchetState: z.nativeEnum(RatchetState),
  ratchetLastCheckedAt: z.string().nullable(),
  ratchetLastPushAt: z.string().nullable(),
  ratchetActiveSessionId: z.string().nullable(),
  ratchetLastCiRunId: z.string().nullable(),
  ratchetLastNotifiedState: z.nativeEnum(RatchetState).nullable(),
});

const exportedClaudeSessionSchema = z.object({
  id: z.string(),
  workspaceId: z.string(),
  name: z.string().nullable(),
  workflow: z.string(),
  model: z.string(),
  status: z.nativeEnum(SessionStatus),
  claudeSessionId: z.string().nullable(),
  claudeProcessPid: z.number().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

const exportedTerminalSessionSchema = z.object({
  id: z.string(),
  workspaceId: z.string(),
  name: z.string().nullable(),
  status: z.nativeEnum(SessionStatus),
  pid: z.number().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

// Schema v1 - for importing legacy backups
const exportedUserSettingsSchemaV1 = z.object({
  preferredIde: z.string(),
  customIdeCommand: z.string().nullable(),
  playSoundOnComplete: z.boolean(),
  notificationSoundPath: z.string().nullable(),
  // Deprecated fields - kept for backward compatibility during import
  autoFixCiIssues: z.boolean().optional(),
  autoFixPrReviewComments: z.boolean().optional(),
  prReviewFixAllowedUsers: z.array(z.string()).nullable().optional(),
  prReviewFixPrompt: z.string().nullable().optional(),
});

// Schema v2 - includes ratchet settings
const exportedUserSettingsSchemaV2 = z.object({
  preferredIde: z.string(),
  customIdeCommand: z.string().nullable(),
  playSoundOnComplete: z.boolean(),
  notificationSoundPath: z.string().nullable(),
  // Note: workspaceOrder and cachedSlashCommands are intentionally excluded as they are
  // rebuild-able cache data (per design doc: "Excludes cached data")
  // Ratchet settings (Phase 3+)
  ratchetEnabled: z.boolean(),
  ratchetAutoFixCi: z.boolean(),
  ratchetAutoFixReviews: z.boolean(),
  // Removed fields - kept for backward compatibility during import
  ratchetAutoFixConflicts: z.boolean().optional(),
  ratchetAutoMerge: z.boolean(),
  ratchetAllowedReviewers: z.unknown().nullish(), // JSON field - allow undefined from DB
  // Deprecated fields - kept for backward compatibility during import
  autoFixCiIssues: z.boolean().optional(),
  autoFixPrReviewComments: z.boolean().optional(),
  prReviewFixAllowedUsers: z.array(z.string()).nullable().optional(),
  prReviewFixPrompt: z.string().nullable().optional(),
});

// Schema v1 - for importing legacy backups
const exportDataSchemaV1 = z.object({
  meta: z.object({
    exportedAt: z.string(),
    version: z.string(),
    schemaVersion: z.literal(1),
  }),
  data: z.object({
    projects: z.array(exportedProjectSchema),
    workspaces: z.array(exportedWorkspaceSchemaV1),
    claudeSessions: z.array(exportedClaudeSessionSchema),
    terminalSessions: z.array(exportedTerminalSessionSchema),
    userSettings: exportedUserSettingsSchemaV1.nullable(),
  }),
});

// Schema v2 - includes all Phase 3 and Phase 4 fields
const exportDataSchemaV2 = z.object({
  meta: z.object({
    exportedAt: z.string(),
    version: z.string(),
    schemaVersion: z.literal(2),
  }),
  data: z.object({
    projects: z.array(exportedProjectSchema),
    workspaces: z.array(exportedWorkspaceSchemaV2),
    claudeSessions: z.array(exportedClaudeSessionSchema),
    terminalSessions: z.array(exportedTerminalSessionSchema),
    userSettings: exportedUserSettingsSchemaV2.nullable(),
  }),
});

// Main export schema that accepts both v1 and v2
export const exportDataSchema = z.union([exportDataSchemaV2, exportDataSchemaV1]);

export type ExportData = z.infer<typeof exportDataSchemaV2>;
export type ExportDataV1 = z.infer<typeof exportDataSchemaV1>;
export type ExportDataV2 = z.infer<typeof exportDataSchemaV2>;

// ============================================================================
// Types
// ============================================================================

export interface ImportCounter {
  imported: number;
  skipped: number;
}

export interface ImportResults {
  projects: ImportCounter;
  workspaces: ImportCounter;
  claudeSessions: ImportCounter;
  terminalSessions: ImportCounter;
  userSettings: { imported: boolean; skipped: boolean };
}

type ExportedProject = z.infer<typeof exportedProjectSchema>;
type ExportedWorkspaceV1 = z.infer<typeof exportedWorkspaceSchemaV1>;
type ExportedWorkspaceV2 = z.infer<typeof exportedWorkspaceSchemaV2>;
type ExportedClaudeSession = z.infer<typeof exportedClaudeSessionSchema>;
type ExportedTerminalSession = z.infer<typeof exportedTerminalSessionSchema>;
type ExportedUserSettingsV1 = z.infer<typeof exportedUserSettingsSchemaV1>;
type ExportedUserSettingsV2 = z.infer<typeof exportedUserSettingsSchemaV2>;

function normalizeRunScriptStatus(
  status: z.infer<typeof exportedWorkspaceSchemaV1.shape.runScriptStatus>
): RunScriptStatus {
  return status === 'PAUSED' ? RunScriptStatus.IDLE : status;
}

/**
 * Migrates v1 workspace data to v2 format by adding default values for new fields.
 * Uses ?? to preserve any existing v2 fields in forward-filled/mixed backups.
 */
function migrateWorkspaceV1ToV2(
  v1: ExportedWorkspaceV1 | (ExportedWorkspaceV1 & Partial<ExportedWorkspaceV2>)
): ExportedWorkspaceV2 {
  const partial = v1 as Partial<ExportedWorkspaceV2>;
  return {
    ...v1,
    // Set defaults for Phase 3 creation tracking fields
    isAutoGeneratedBranch: v1.isAutoGeneratedBranch ?? false,
    creationSource: v1.creationSource ?? 'MANUAL',
    creationMetadata: v1.creationMetadata ?? null,
    // Set defaults for Phase 3+ PR review tracking fields (preserve if present)
    prReviewLastCheckedAt: partial.prReviewLastCheckedAt ?? null,
    prReviewLastCommentId: partial.prReviewLastCommentId ?? null,
    // Set defaults for Phase 3+ ratchet fields (preserve if present)
    ratchetEnabled: partial.ratchetEnabled ?? true, // Default to enabled (matches schema default)
    ratchetState: partial.ratchetState ?? RatchetState.IDLE,
    ratchetLastCheckedAt: partial.ratchetLastCheckedAt ?? null,
    ratchetLastPushAt: partial.ratchetLastPushAt ?? null,
    ratchetActiveSessionId: partial.ratchetActiveSessionId ?? null,
    ratchetLastCiRunId: partial.ratchetLastCiRunId ?? null,
    ratchetLastNotifiedState: partial.ratchetLastNotifiedState ?? null,
  };
}

/**
 * Migrates v1 user settings to v2 format by adding default values for new fields.
 * Uses ?? to preserve any existing v2 fields in forward-filled/mixed backups.
 */
function migrateUserSettingsV1ToV2(
  v1: ExportedUserSettingsV1 | (ExportedUserSettingsV1 & Partial<ExportedUserSettingsV2>)
): ExportedUserSettingsV2 {
  const partial = v1 as Partial<ExportedUserSettingsV2>;
  return {
    ...v1,
    // Set defaults for Phase 3+ ratchet settings (preserve if present, match schema defaults)
    ratchetEnabled: partial.ratchetEnabled ?? false,
    ratchetAutoFixCi: partial.ratchetAutoFixCi ?? true,
    ratchetAutoFixReviews: partial.ratchetAutoFixReviews ?? true,
    ratchetAutoMerge: partial.ratchetAutoMerge ?? false,
    ratchetAllowedReviewers: partial.ratchetAllowedReviewers ?? null,
  };
}

// ============================================================================
// Helpers
// ============================================================================

const toISOString = (date: Date | null): string | null => (date ? date.toISOString() : null);
const parseDate = (str: string | null): Date | null => (str ? new Date(str) : null);

/**
 * Ensures v2 workspace has all required fields and defaults for optional fields.
 * Validates that claimed v2 data actually has v2 fields to prevent runtime errors.
 */
function ensureWorkspaceV2Defaults(w: ExportedWorkspaceV2): ExportedWorkspaceV2 {
  // Validate all required v2 fields are present (not undefined)
  const missingRequired =
    w.ratchetEnabled === undefined ||
    w.ratchetState === undefined ||
    w.prReviewLastCheckedAt === undefined ||
    w.prReviewLastCommentId === undefined;

  if (missingRequired) {
    logger.warn('V2 workspace missing required v2 fields, applying migration', {
      workspaceId: w.id,
      hasRatchetEnabled: w.ratchetEnabled !== undefined,
      hasRatchetState: w.ratchetState !== undefined,
      hasPrReviewLastCheckedAt: w.prReviewLastCheckedAt !== undefined,
      hasPrReviewLastCommentId: w.prReviewLastCommentId !== undefined,
    });
    // Fallback to migration if required fields are missing
    return migrateWorkspaceV1ToV2(w as unknown as ExportedWorkspaceV1);
  }

  // Ensure optional Phase 3 fields have defaults
  return {
    ...w,
    isAutoGeneratedBranch: w.isAutoGeneratedBranch ?? false,
    creationSource: w.creationSource ?? 'MANUAL',
    creationMetadata: w.creationMetadata ?? null,
  };
}

/**
 * Ensures v2 user settings has all required fields.
 * Validates that claimed v2 data actually has v2 fields to prevent runtime errors.
 */
function ensureUserSettingsV2Defaults(s: ExportedUserSettingsV2): ExportedUserSettingsV2 {
  // Validate required v2 fields are present (not undefined)
  if (
    s.ratchetEnabled === undefined ||
    s.ratchetAutoFixCi === undefined ||
    s.ratchetAutoFixReviews === undefined ||
    s.ratchetAutoMerge === undefined
  ) {
    logger.warn('V2 user settings missing required ratchet fields, applying migration', {
      hasRatchetEnabled: s.ratchetEnabled !== undefined,
      hasRatchetAutoFixCi: s.ratchetAutoFixCi !== undefined,
    });
    // Fallback to migration if required fields are missing
    return migrateUserSettingsV1ToV2(s as unknown as ExportedUserSettingsV1);
  }

  return s;
}

// ============================================================================
// Import Functions
// ============================================================================

async function importProjects(
  projects: ExportedProject[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const p of projects) {
    const existing = await tx.project.findUnique({ where: { id: p.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const slugConflict = await tx.project.findUnique({ where: { slug: p.slug } });
    if (slugConflict) {
      logger.warn('Skipping project due to slug conflict', { id: p.id, slug: p.slug });
      counter.skipped++;
      continue;
    }

    await tx.project.create({
      data: {
        id: p.id,
        name: p.name,
        slug: p.slug,
        repoPath: p.repoPath,
        worktreeBasePath: p.worktreeBasePath,
        defaultBranch: p.defaultBranch,
        githubOwner: p.githubOwner,
        githubRepo: p.githubRepo,
        isArchived: p.isArchived,
        startupScriptCommand: p.startupScriptCommand,
        startupScriptPath: p.startupScriptPath,
        startupScriptTimeout: p.startupScriptTimeout,
        createdAt: new Date(p.createdAt),
        updatedAt: new Date(p.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importWorkspaces(
  workspaces: Array<ExportedWorkspaceV1 | ExportedWorkspaceV2>,
  schemaVersion: number,
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const workspace of workspaces) {
    const existing = await tx.workspace.findUnique({ where: { id: workspace.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const project = await tx.project.findUnique({ where: { id: workspace.projectId } });
    if (!project) {
      logger.warn('Skipping workspace due to missing project', {
        workspaceId: workspace.id,
        projectId: workspace.projectId,
      });
      counter.skipped++;
      continue;
    }

    // Migrate v1 to v2 if needed (based on schema version from meta)
    // For v2, also ensure optional fields have defaults and validate required v2 fields
    const w: ExportedWorkspaceV2 =
      schemaVersion >= 2
        ? ensureWorkspaceV2Defaults(workspace as ExportedWorkspaceV2)
        : migrateWorkspaceV1ToV2(workspace);

    await tx.workspace.create({
      data: {
        id: w.id,
        projectId: w.projectId,
        name: w.name,
        description: w.description,
        status: w.status,
        worktreePath: w.worktreePath,
        branchName: w.branchName,
        isAutoGeneratedBranch: w.isAutoGeneratedBranch ?? false,
        creationSource: w.creationSource ?? 'MANUAL',
        creationMetadata:
          w.creationMetadata != null ? (w.creationMetadata as Prisma.InputJsonValue) : undefined,
        initErrorMessage: w.initErrorMessage,
        initOutput: w.initOutput,
        initStartedAt: parseDate(w.initStartedAt),
        initCompletedAt: parseDate(w.initCompletedAt),
        initRetryCount: w.initRetryCount,
        runScriptCommand: w.runScriptCommand,
        runScriptCleanupCommand: w.runScriptCleanupCommand,
        runScriptPid: w.runScriptPid,
        runScriptPort: w.runScriptPort,
        runScriptStartedAt: parseDate(w.runScriptStartedAt),
        runScriptStatus: normalizeRunScriptStatus(w.runScriptStatus),
        prUrl: w.prUrl,
        githubIssueNumber: w.githubIssueNumber,
        githubIssueUrl: w.githubIssueUrl,
        prNumber: w.prNumber,
        prState: w.prState,
        prReviewState: w.prReviewState,
        prCiStatus: w.prCiStatus,
        prUpdatedAt: parseDate(w.prUpdatedAt),
        prCiFailedAt: parseDate(w.prCiFailedAt),
        prCiLastNotifiedAt: parseDate(w.prCiLastNotifiedAt),
        // Phase 3+ PR review tracking fields
        prReviewLastCheckedAt: parseDate(w.prReviewLastCheckedAt),
        prReviewLastCommentId: w.prReviewLastCommentId,
        // Phase 3+ ratchet fields
        ratchetEnabled: w.ratchetEnabled,
        ratchetState: w.ratchetState,
        ratchetLastCheckedAt: parseDate(w.ratchetLastCheckedAt),
        ratchetLastPushAt: parseDate(w.ratchetLastPushAt),
        ratchetActiveSessionId: w.ratchetActiveSessionId,
        ratchetLastCiRunId: w.ratchetLastCiRunId,
        ratchetLastNotifiedState: w.ratchetLastNotifiedState,
        hasHadSessions: w.hasHadSessions,
        cachedKanbanColumn: w.cachedKanbanColumn,
        stateComputedAt: parseDate(w.stateComputedAt),
        createdAt: new Date(w.createdAt),
        updatedAt: new Date(w.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importClaudeSessions(
  sessions: ExportedClaudeSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.claudeSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping claude session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.claudeSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        workflow: s.workflow,
        model: s.model,
        status: s.status,
        claudeSessionId: s.claudeSessionId,
        claudeProcessPid: s.claudeProcessPid,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importTerminalSessions(
  sessions: ExportedTerminalSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.terminalSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping terminal session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.terminalSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        status: s.status,
        pid: s.pid,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importUserSettings(
  settings: ExportedUserSettingsV1 | ExportedUserSettingsV2 | null,
  schemaVersion: number,
  tx: TransactionClient
): Promise<{ imported: boolean; skipped: boolean }> {
  if (!settings) {
    return { imported: false, skipped: false };
  }

  const existing = await tx.userSettings.findFirst({ where: { userId: 'default' } });
  if (existing) {
    return { imported: false, skipped: true };
  }

  // Migrate v1 to v2 if needed (based on schema version from meta)
  // For v2, also ensure all required fields are present
  const s: ExportedUserSettingsV2 =
    schemaVersion >= 2
      ? ensureUserSettingsV2Defaults(settings as ExportedUserSettingsV2)
      : migrateUserSettingsV1ToV2(settings);

  await tx.userSettings.create({
    data: {
      userId: 'default',
      preferredIde: s.preferredIde,
      customIdeCommand: s.customIdeCommand,
      playSoundOnComplete: s.playSoundOnComplete,
      notificationSoundPath: s.notificationSoundPath,
      // Phase 3+ ratchet settings
      ratchetEnabled: s.ratchetEnabled,
      ratchetAutoFixCi: s.ratchetAutoFixCi,
      ratchetAutoFixReviews: s.ratchetAutoFixReviews,
      ratchetAutoMerge: s.ratchetAutoMerge,
      ratchetAllowedReviewers:
        s.ratchetAllowedReviewers != null
          ? (s.ratchetAllowedReviewers as Prisma.InputJsonValue)
          : undefined,
      // Note: workspaceOrder and cachedSlashCommands are intentionally not imported
      // as they are rebuild-able cache data
      // Deprecated fields are ignored - they no longer exist in the schema
    },
  });

  return { imported: true, skipped: false };
}

// ============================================================================
// Service Class
// ============================================================================

class DataBackupService {
  /**
   * Export all data for backup/migration.
   * Exports projects, workspaces, sessions, and user preferences.
   * Excludes cached data (workspaceOrder, cachedSlashCommands) which will rebuild.
   * Exports in schema version 2 format.
   */
  async exportData(appVersion: string): Promise<ExportData> {
    logger.info('Exporting database data');

    // Fetch all data
    const [projects, workspaces, claudeSessions, terminalSessions, userSettings] =
      await Promise.all([
        prisma.project.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.workspace.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.claudeSession.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.terminalSession.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.userSettings.findFirst({ where: { userId: 'default' } }),
      ]);

    const exportData: ExportData = {
      meta: {
        exportedAt: new Date().toISOString(),
        version: appVersion,
        schemaVersion: 2,
      },
      data: {
        projects: projects.map((p) => ({
          id: p.id,
          name: p.name,
          slug: p.slug,
          repoPath: p.repoPath,
          worktreeBasePath: p.worktreeBasePath,
          defaultBranch: p.defaultBranch,
          githubOwner: p.githubOwner,
          githubRepo: p.githubRepo,
          isArchived: p.isArchived,
          startupScriptCommand: p.startupScriptCommand,
          startupScriptPath: p.startupScriptPath,
          startupScriptTimeout: p.startupScriptTimeout,
          createdAt: p.createdAt.toISOString(),
          updatedAt: p.updatedAt.toISOString(),
        })),
        workspaces: workspaces.map((w) => ({
          id: w.id,
          projectId: w.projectId,
          name: w.name,
          description: w.description,
          status: w.status,
          worktreePath: w.worktreePath,
          branchName: w.branchName,
          isAutoGeneratedBranch: w.isAutoGeneratedBranch,
          creationSource: w.creationSource,
          creationMetadata: w.creationMetadata,
          initErrorMessage: w.initErrorMessage,
          initOutput: w.initOutput,
          initStartedAt: toISOString(w.initStartedAt),
          initCompletedAt: toISOString(w.initCompletedAt),
          initRetryCount: w.initRetryCount,
          runScriptCommand: w.runScriptCommand,
          runScriptCleanupCommand: w.runScriptCleanupCommand,
          runScriptPid: w.runScriptPid,
          runScriptPort: w.runScriptPort,
          runScriptStartedAt: toISOString(w.runScriptStartedAt),
          runScriptStatus: w.runScriptStatus,
          prUrl: w.prUrl,
          githubIssueNumber: w.githubIssueNumber,
          githubIssueUrl: w.githubIssueUrl,
          prNumber: w.prNumber,
          prState: w.prState,
          prReviewState: w.prReviewState,
          prCiStatus: w.prCiStatus,
          prUpdatedAt: toISOString(w.prUpdatedAt),
          prCiFailedAt: toISOString(w.prCiFailedAt),
          prCiLastNotifiedAt: toISOString(w.prCiLastNotifiedAt),
          // Phase 3+ PR review tracking fields
          prReviewLastCheckedAt: toISOString(w.prReviewLastCheckedAt),
          prReviewLastCommentId: w.prReviewLastCommentId,
          // Phase 3+ ratchet tracking fields
          ratchetEnabled: w.ratchetEnabled,
          ratchetState: w.ratchetState,
          ratchetLastCheckedAt: toISOString(w.ratchetLastCheckedAt),
          ratchetLastPushAt: toISOString(w.ratchetLastPushAt),
          ratchetActiveSessionId: w.ratchetActiveSessionId,
          ratchetLastCiRunId: w.ratchetLastCiRunId,
          ratchetLastNotifiedState: w.ratchetLastNotifiedState,
          hasHadSessions: w.hasHadSessions,
          cachedKanbanColumn: w.cachedKanbanColumn,
          stateComputedAt: toISOString(w.stateComputedAt),
          createdAt: w.createdAt.toISOString(),
          updatedAt: w.updatedAt.toISOString(),
        })),
        claudeSessions: claudeSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          workflow: s.workflow,
          model: s.model,
          status: s.status,
          claudeSessionId: s.claudeSessionId,
          claudeProcessPid: s.claudeProcessPid,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        terminalSessions: terminalSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          status: s.status,
          pid: s.pid,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        userSettings: userSettings
          ? {
              preferredIde: userSettings.preferredIde,
              customIdeCommand: userSettings.customIdeCommand,
              playSoundOnComplete: userSettings.playSoundOnComplete,
              notificationSoundPath: userSettings.notificationSoundPath,
              // Phase 3+ ratchet settings
              ratchetEnabled: userSettings.ratchetEnabled,
              ratchetAutoFixCi: userSettings.ratchetAutoFixCi,
              ratchetAutoFixReviews: userSettings.ratchetAutoFixReviews,
              ratchetAutoMerge: userSettings.ratchetAutoMerge,
              ratchetAllowedReviewers: userSettings.ratchetAllowedReviewers,
              // Note: workspaceOrder and cachedSlashCommands are intentionally excluded
              // as they are rebuild-able cache data (per design doc)
            }
          : null,
      },
    };

    logger.info('Export completed', {
      projectCount: projects.length,
      workspaceCount: workspaces.length,
      claudeSessionCount: claudeSessions.length,
      terminalSessionCount: terminalSessions.length,
    });

    return exportData;
  }

  /**
   * Import data from a backup file.
   * Supports both v1 and v2 schema versions with automatic migration.
   * Skips records that already exist (by ID).
   * Returns counts of imported/skipped records.
   * All imports are wrapped in a transaction for atomicity.
   */
  async importData(input: ExportDataV1 | ExportDataV2): Promise<ImportResults> {
    logger.info('Starting data import', {
      schemaVersion: input.meta.schemaVersion,
      exportedAt: input.meta.exportedAt,
      projectCount: input.data.projects.length,
      workspaceCount: input.data.workspaces.length,
    });

    // Import in dependency order within a transaction for atomicity
    const results = await prisma.$transaction(async (tx) => {
      const schemaVersion = input.meta.schemaVersion;
      const projects = await importProjects(input.data.projects, tx);
      const workspaces = await importWorkspaces(input.data.workspaces, schemaVersion, tx);
      const claudeSessions = await importClaudeSessions(input.data.claudeSessions, tx);
      const terminalSessions = await importTerminalSessions(input.data.terminalSessions, tx);
      const userSettings = await importUserSettings(input.data.userSettings, schemaVersion, tx);

      return {
        projects,
        workspaces,
        claudeSessions,
        terminalSessions,
        userSettings,
      };
    });

    logger.info('Import completed', {
      schemaVersion: input.meta.schemaVersion,
      projects: results.projects,
      workspaces: results.workspaces,
      claudeSessions: results.claudeSessions,
      terminalSessions: results.terminalSessions,
    });

    return results;
  }
}

// Export singleton instance
export const dataBackupService = new DataBackupService();

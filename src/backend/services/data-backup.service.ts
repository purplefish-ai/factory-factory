/**
 * Data Backup Service
 *
 * Handles export and import of database data for backup/restore purposes.
 * Used when database migrations require a reset.
 */

import {
  CIStatus,
  KanbanColumn,
  PRState,
  type Prisma,
  RunScriptStatus,
  SessionStatus,
  WorkspaceCreationSource,
  WorkspaceStatus,
} from '@prisma-gen/client';
import { z } from 'zod';
import { prisma } from '../db';
import { createLogger } from './logger.service';

type TransactionClient = Prisma.TransactionClient;

const logger = createLogger('data-backup');

// ============================================================================
// Schemas
// ============================================================================

const exportedProjectSchema = z.object({
  id: z.string(),
  name: z.string(),
  slug: z.string(),
  repoPath: z.string(),
  worktreeBasePath: z.string(),
  defaultBranch: z.string(),
  githubOwner: z.string().nullable(),
  githubRepo: z.string().nullable(),
  isArchived: z.boolean(),
  startupScriptCommand: z.string().nullable(),
  startupScriptPath: z.string().nullable(),
  startupScriptTimeout: z.number(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

const exportedWorkspaceSchema = z.object({
  id: z.string(),
  projectId: z.string(),
  name: z.string(),
  description: z.string().nullable(),
  status: z.nativeEnum(WorkspaceStatus),
  worktreePath: z.string().nullable(),
  branchName: z.string().nullable(),
  // Optional for backward compatibility with pre-Phase-3 backups
  isAutoGeneratedBranch: z.boolean().optional(),
  creationSource: z.nativeEnum(WorkspaceCreationSource).optional(),
  creationMetadata: z.unknown().nullable().optional(),
  initErrorMessage: z.string().nullable(),
  initOutput: z.string().nullable(),
  initStartedAt: z.string().nullable(),
  initCompletedAt: z.string().nullable(),
  initRetryCount: z.number(),
  runScriptCommand: z.string().nullable(),
  runScriptCleanupCommand: z.string().nullable(),
  runScriptPid: z.number().nullable(),
  runScriptPort: z.number().nullable(),
  runScriptStartedAt: z.string().nullable(),
  // Accept both old SessionStatus and new RunScriptStatus values for backward compatibility
  runScriptStatus: z.union([z.nativeEnum(RunScriptStatus), z.literal('PAUSED')]),
  prUrl: z.string().nullable(),
  githubIssueNumber: z.number().nullable(),
  githubIssueUrl: z.string().nullable(),
  prNumber: z.number().nullable(),
  prState: z.nativeEnum(PRState),
  prReviewState: z.string().nullable(),
  prCiStatus: z.nativeEnum(CIStatus),
  prUpdatedAt: z.string().nullable(),
  prCiFailedAt: z.string().nullable(),
  prCiLastNotifiedAt: z.string().nullable(),
  hasHadSessions: z.boolean(),
  cachedKanbanColumn: z.nativeEnum(KanbanColumn),
  stateComputedAt: z.string().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

const exportedClaudeSessionSchema = z.object({
  id: z.string(),
  workspaceId: z.string(),
  name: z.string().nullable(),
  workflow: z.string(),
  model: z.string(),
  status: z.nativeEnum(SessionStatus),
  claudeSessionId: z.string().nullable(),
  claudeProcessPid: z.number().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

const exportedTerminalSessionSchema = z.object({
  id: z.string(),
  workspaceId: z.string(),
  name: z.string().nullable(),
  status: z.nativeEnum(SessionStatus),
  pid: z.number().nullable(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

const exportedUserSettingsSchema = z.object({
  preferredIde: z.string(),
  customIdeCommand: z.string().nullable(),
  playSoundOnComplete: z.boolean(),
  notificationSoundPath: z.string().nullable(),
  // Deprecated fields - kept for backward compatibility during import
  autoFixCiIssues: z.boolean().optional(),
  autoFixPrReviewComments: z.boolean().optional(),
  prReviewFixAllowedUsers: z.array(z.string()).nullable().optional(),
  prReviewFixPrompt: z.string().nullable().optional(),
});

export const exportDataSchema = z.object({
  meta: z.object({
    exportedAt: z.string(),
    version: z.string(),
    schemaVersion: z.literal(1),
  }),
  data: z.object({
    projects: z.array(exportedProjectSchema),
    workspaces: z.array(exportedWorkspaceSchema),
    claudeSessions: z.array(exportedClaudeSessionSchema),
    terminalSessions: z.array(exportedTerminalSessionSchema),
    userSettings: exportedUserSettingsSchema.nullable(),
  }),
});

export type ExportData = z.infer<typeof exportDataSchema>;

// ============================================================================
// Types
// ============================================================================

export interface ImportCounter {
  imported: number;
  skipped: number;
}

export interface ImportResults {
  projects: ImportCounter;
  workspaces: ImportCounter;
  claudeSessions: ImportCounter;
  terminalSessions: ImportCounter;
  userSettings: { imported: boolean; skipped: boolean };
}

type ExportedProject = z.infer<typeof exportedProjectSchema>;
type ExportedWorkspace = z.infer<typeof exportedWorkspaceSchema>;
type ExportedClaudeSession = z.infer<typeof exportedClaudeSessionSchema>;
type ExportedTerminalSession = z.infer<typeof exportedTerminalSessionSchema>;
type ExportedUserSettings = z.infer<typeof exportedUserSettingsSchema>;

function normalizeRunScriptStatus(
  status: z.infer<typeof exportedWorkspaceSchema.shape.runScriptStatus>
): RunScriptStatus {
  return status === 'PAUSED' ? RunScriptStatus.IDLE : status;
}

// ============================================================================
// Helpers
// ============================================================================

const toISOString = (date: Date | null): string | null => (date ? date.toISOString() : null);
const parseDate = (str: string | null): Date | null => (str ? new Date(str) : null);

// ============================================================================
// Import Functions
// ============================================================================

async function importProjects(
  projects: ExportedProject[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const p of projects) {
    const existing = await tx.project.findUnique({ where: { id: p.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const slugConflict = await tx.project.findUnique({ where: { slug: p.slug } });
    if (slugConflict) {
      logger.warn('Skipping project due to slug conflict', { id: p.id, slug: p.slug });
      counter.skipped++;
      continue;
    }

    await tx.project.create({
      data: {
        id: p.id,
        name: p.name,
        slug: p.slug,
        repoPath: p.repoPath,
        worktreeBasePath: p.worktreeBasePath,
        defaultBranch: p.defaultBranch,
        githubOwner: p.githubOwner,
        githubRepo: p.githubRepo,
        isArchived: p.isArchived,
        startupScriptCommand: p.startupScriptCommand,
        startupScriptPath: p.startupScriptPath,
        startupScriptTimeout: p.startupScriptTimeout,
        createdAt: new Date(p.createdAt),
        updatedAt: new Date(p.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importWorkspaces(
  workspaces: ExportedWorkspace[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const w of workspaces) {
    const existing = await tx.workspace.findUnique({ where: { id: w.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const project = await tx.project.findUnique({ where: { id: w.projectId } });
    if (!project) {
      logger.warn('Skipping workspace due to missing project', {
        workspaceId: w.id,
        projectId: w.projectId,
      });
      counter.skipped++;
      continue;
    }

    await tx.workspace.create({
      data: {
        id: w.id,
        projectId: w.projectId,
        name: w.name,
        description: w.description,
        status: w.status,
        worktreePath: w.worktreePath,
        branchName: w.branchName,
        isAutoGeneratedBranch: w.isAutoGeneratedBranch ?? false,
        creationSource: w.creationSource ?? 'MANUAL',
        creationMetadata:
          w.creationMetadata != null ? (w.creationMetadata as Prisma.InputJsonValue) : undefined,
        initErrorMessage: w.initErrorMessage,
        initOutput: w.initOutput,
        initStartedAt: parseDate(w.initStartedAt),
        initCompletedAt: parseDate(w.initCompletedAt),
        initRetryCount: w.initRetryCount,
        runScriptCommand: w.runScriptCommand,
        runScriptCleanupCommand: w.runScriptCleanupCommand,
        runScriptPid: w.runScriptPid,
        runScriptPort: w.runScriptPort,
        runScriptStartedAt: parseDate(w.runScriptStartedAt),
        // Map old SessionStatus values to RunScriptStatus (PAUSED -> IDLE)
        runScriptStatus: normalizeRunScriptStatus(w.runScriptStatus),
        prUrl: w.prUrl,
        githubIssueNumber: w.githubIssueNumber,
        githubIssueUrl: w.githubIssueUrl,
        prNumber: w.prNumber,
        prState: w.prState,
        prReviewState: w.prReviewState,
        prCiStatus: w.prCiStatus,
        prUpdatedAt: parseDate(w.prUpdatedAt),
        prCiFailedAt: parseDate(w.prCiFailedAt),
        prCiLastNotifiedAt: parseDate(w.prCiLastNotifiedAt),
        hasHadSessions: w.hasHadSessions,
        cachedKanbanColumn: w.cachedKanbanColumn,
        stateComputedAt: parseDate(w.stateComputedAt),
        createdAt: new Date(w.createdAt),
        updatedAt: new Date(w.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importClaudeSessions(
  sessions: ExportedClaudeSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.claudeSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping claude session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.claudeSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        workflow: s.workflow,
        model: s.model,
        status: s.status,
        claudeSessionId: s.claudeSessionId,
        claudeProcessPid: s.claudeProcessPid,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importTerminalSessions(
  sessions: ExportedTerminalSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.terminalSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping terminal session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.terminalSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        status: s.status,
        pid: s.pid,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importUserSettings(
  settings: ExportedUserSettings | null,
  tx: TransactionClient
): Promise<{ imported: boolean; skipped: boolean }> {
  if (!settings) {
    return { imported: false, skipped: false };
  }

  const existing = await tx.userSettings.findFirst({ where: { userId: 'default' } });
  if (existing) {
    return { imported: false, skipped: true };
  }

  await tx.userSettings.create({
    data: {
      userId: 'default',
      preferredIde: settings.preferredIde,
      customIdeCommand: settings.customIdeCommand,
      playSoundOnComplete: settings.playSoundOnComplete,
      notificationSoundPath: settings.notificationSoundPath,
      // Deprecated fields are ignored - they no longer exist in the schema
    },
  });

  return { imported: true, skipped: false };
}

// ============================================================================
// Service Class
// ============================================================================

class DataBackupService {
  /**
   * Export all data for backup/migration.
   * Exports projects, workspaces, sessions, and user preferences.
   * Excludes cached data (workspaceOrder, cachedSlashCommands) which will rebuild.
   */
  async exportData(appVersion: string): Promise<ExportData> {
    logger.info('Exporting database data');

    // Fetch all data
    const [projects, workspaces, claudeSessions, terminalSessions, userSettings] =
      await Promise.all([
        prisma.project.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.workspace.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.claudeSession.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.terminalSession.findMany({ orderBy: { createdAt: 'asc' } }),
        prisma.userSettings.findFirst({ where: { userId: 'default' } }),
      ]);

    const exportData: ExportData = {
      meta: {
        exportedAt: new Date().toISOString(),
        version: appVersion,
        schemaVersion: 1,
      },
      data: {
        projects: projects.map((p) => ({
          id: p.id,
          name: p.name,
          slug: p.slug,
          repoPath: p.repoPath,
          worktreeBasePath: p.worktreeBasePath,
          defaultBranch: p.defaultBranch,
          githubOwner: p.githubOwner,
          githubRepo: p.githubRepo,
          isArchived: p.isArchived,
          startupScriptCommand: p.startupScriptCommand,
          startupScriptPath: p.startupScriptPath,
          startupScriptTimeout: p.startupScriptTimeout,
          createdAt: p.createdAt.toISOString(),
          updatedAt: p.updatedAt.toISOString(),
        })),
        workspaces: workspaces.map((w) => ({
          id: w.id,
          projectId: w.projectId,
          name: w.name,
          description: w.description,
          status: w.status,
          worktreePath: w.worktreePath,
          branchName: w.branchName,
          isAutoGeneratedBranch: w.isAutoGeneratedBranch,
          creationSource: w.creationSource,
          creationMetadata: w.creationMetadata,
          initErrorMessage: w.initErrorMessage,
          initOutput: w.initOutput,
          initStartedAt: toISOString(w.initStartedAt),
          initCompletedAt: toISOString(w.initCompletedAt),
          initRetryCount: w.initRetryCount,
          runScriptCommand: w.runScriptCommand,
          runScriptCleanupCommand: w.runScriptCleanupCommand,
          runScriptPid: w.runScriptPid,
          runScriptPort: w.runScriptPort,
          runScriptStartedAt: toISOString(w.runScriptStartedAt),
          runScriptStatus: w.runScriptStatus,
          prUrl: w.prUrl,
          githubIssueNumber: w.githubIssueNumber,
          githubIssueUrl: w.githubIssueUrl,
          prNumber: w.prNumber,
          prState: w.prState,
          prReviewState: w.prReviewState,
          prCiStatus: w.prCiStatus,
          prUpdatedAt: toISOString(w.prUpdatedAt),
          prCiFailedAt: toISOString(w.prCiFailedAt),
          prCiLastNotifiedAt: toISOString(w.prCiLastNotifiedAt),
          hasHadSessions: w.hasHadSessions,
          cachedKanbanColumn: w.cachedKanbanColumn,
          stateComputedAt: toISOString(w.stateComputedAt),
          createdAt: w.createdAt.toISOString(),
          updatedAt: w.updatedAt.toISOString(),
        })),
        claudeSessions: claudeSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          workflow: s.workflow,
          model: s.model,
          status: s.status,
          claudeSessionId: s.claudeSessionId,
          claudeProcessPid: s.claudeProcessPid,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        terminalSessions: terminalSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          status: s.status,
          pid: s.pid,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        userSettings: userSettings
          ? {
              preferredIde: userSettings.preferredIde,
              customIdeCommand: userSettings.customIdeCommand,
              playSoundOnComplete: userSettings.playSoundOnComplete,
              notificationSoundPath: userSettings.notificationSoundPath,
            }
          : null,
      },
    };

    logger.info('Export completed', {
      projectCount: projects.length,
      workspaceCount: workspaces.length,
      claudeSessionCount: claudeSessions.length,
      terminalSessionCount: terminalSessions.length,
    });

    return exportData;
  }

  /**
   * Import data from a backup file.
   * Skips records that already exist (by ID).
   * Returns counts of imported/skipped records.
   * All imports are wrapped in a transaction for atomicity.
   */
  async importData(input: ExportData): Promise<ImportResults> {
    logger.info('Starting data import', {
      schemaVersion: input.meta.schemaVersion,
      exportedAt: input.meta.exportedAt,
      projectCount: input.data.projects.length,
      workspaceCount: input.data.workspaces.length,
    });

    // Import in dependency order within a transaction for atomicity
    const results = await prisma.$transaction(async (tx) => {
      const projects = await importProjects(input.data.projects, tx);
      const workspaces = await importWorkspaces(input.data.workspaces, tx);
      const claudeSessions = await importClaudeSessions(input.data.claudeSessions, tx);
      const terminalSessions = await importTerminalSessions(input.data.terminalSessions, tx);
      const userSettings = await importUserSettings(input.data.userSettings, tx);

      return {
        projects,
        workspaces,
        claudeSessions,
        terminalSessions,
        userSettings,
      };
    });

    logger.info('Import completed', {
      projects: results.projects,
      workspaces: results.workspaces,
      claudeSessions: results.claudeSessions,
      terminalSessions: results.terminalSessions,
    });

    return results;
  }
}

// Export singleton instance
export const dataBackupService = new DataBackupService();

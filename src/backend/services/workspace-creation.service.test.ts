import type { UserSettings, Workspace } from '@prisma-gen/client';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import * as claudeSessionAccessorModule from '../resource_accessors/claude-session.accessor';
import * as projectAccessorModule from '../resource_accessors/project.accessor';
import * as userSettingsAccessorModule from '../resource_accessors/user-settings.accessor';
import * as workspaceAccessorModule from '../resource_accessors/workspace.accessor';
import type { configService } from './config.service';
import * as gitOpsServiceModule from './git-ops.service';
import type { createLogger } from './logger.service';
import {
  adaptLegacyCreateInput,
  WorkspaceCreationService,
  type WorkspaceCreationSource,
} from './workspace-creation.service';
import * as worktreeLifecycleServiceModule from './worktree-lifecycle.service';

type ConfigService = typeof configService;
type Logger = ReturnType<typeof createLogger>;

// Mock dependencies
vi.mock('../resource_accessors/workspace.accessor');
vi.mock('../resource_accessors/project.accessor');
vi.mock('../resource_accessors/user-settings.accessor');
vi.mock('../resource_accessors/claude-session.accessor');
vi.mock('./git-ops.service');
vi.mock('./worktree-lifecycle.service');
vi.mock('../trpc/workspace/init.trpc', () => ({
  initializeWorkspaceWorktree: vi.fn().mockResolvedValue(undefined),
}));

describe('WorkspaceCreationService', () => {
  let service: WorkspaceCreationService;
  let mockLogger: Logger;
  let mockConfigService: ConfigService;

  const mockWorkspace: Workspace = {
    id: 'ws-123',
    projectId: 'proj-1',
    name: 'Test Workspace',
    description: null,
    status: 'NEW',
    branchName: null,
    worktreePath: null,
    isAutoGeneratedBranch: false,
    prUrl: null,
    githubIssueNumber: null,
    githubIssueUrl: null,
    prNumber: null,
    prState: 'NONE',
    prReviewState: null,
    prCiStatus: 'UNKNOWN',
    prUpdatedAt: null,
    prCiFailedAt: null,
    prCiLastNotifiedAt: null,
    prReviewLastCheckedAt: null,
    prReviewLastCommentId: null,
    ratchetEnabled: true,
    ratchetState: 'IDLE',
    ratchetLastCheckedAt: null,
    ratchetLastPushAt: null,
    ratchetActiveSessionId: null,
    ratchetLastCiRunId: null,
    ratchetLastNotifiedState: null,
    hasHadSessions: false,
    cachedKanbanColumn: 'WAITING',
    stateComputedAt: null,
    initErrorMessage: null,
    initOutput: null,
    initStartedAt: null,
    initCompletedAt: null,
    initRetryCount: 0,
    runScriptCommand: null,
    runScriptCleanupCommand: null,
    runScriptPid: null,
    runScriptPort: null,
    runScriptStartedAt: null,
    runScriptStatus: 'IDLE',
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const mockProject = {
    id: 'proj-1',
    name: 'Test Project',
    slug: 'test-project',
    repoPath: '/path/to/repo',
    worktreeBasePath: '/path/to/worktrees',
    defaultBranch: 'main',
    githubOwner: null,
    githubRepo: null,
    isArchived: false,
    startupScriptCommand: null,
    startupScriptPath: null,
    startupScriptTimeout: 300,
    createdAt: new Date(),
    updatedAt: new Date(),
    workspaces: [],
  };

  beforeEach(() => {
    vi.clearAllMocks();

    mockLogger = {
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      debug: vi.fn(),
    } as unknown as Logger;

    mockConfigService = {
      getMaxSessionsPerWorkspace: vi.fn().mockReturnValue(5),
    } as unknown as ConfigService;

    service = new WorkspaceCreationService({
      logger: mockLogger,
      configService: mockConfigService,
    });

    // Default mocks
    const mockUserSettings: UserSettings = {
      id: '1',
      userId: 'default',
      preferredIde: 'cursor',
      customIdeCommand: '',
      playSoundOnComplete: true,
      notificationSoundPath: null,
      workspaceOrder: null,
      cachedSlashCommands: null,
      autoFixCiIssues: false,
      autoFixPrReviewComments: false,
      prReviewFixAllowedUsers: null,
      prReviewFixPrompt: null,
      ratchetEnabled: true,
      ratchetAutoFixCi: true,
      ratchetAutoFixConflicts: true,
      ratchetAutoFixReviews: true,
      ratchetAutoMerge: false,
      ratchetAllowedReviewers: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    vi.spyOn(userSettingsAccessorModule.userSettingsAccessor, 'get').mockResolvedValue(
      mockUserSettings
    );

    vi.spyOn(workspaceAccessorModule.workspaceAccessor, 'create').mockResolvedValue(mockWorkspace);

    vi.spyOn(claudeSessionAccessorModule.claudeSessionAccessor, 'create').mockResolvedValue({
      id: 'session-1',
      workspaceId: 'ws-123',
      workflow: 'feature',
      name: 'Chat 1',
      status: 'IDLE',
      model: 'sonnet',
      claudeSessionId: null,
      claudeProcessPid: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    vi.spyOn(worktreeLifecycleServiceModule, 'setWorkspaceInitMode').mockResolvedValue();
  });

  describe('create', () => {
    describe('MANUAL source', () => {
      it('should create workspace with manual source', async () => {
        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'My Workspace',
          description: 'A test workspace',
          branchName: 'feature/test',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(result.defaultSessionCreated).toBe(true);
        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith({
          projectId: 'proj-1',
          name: 'My Workspace',
          description: 'A test workspace',
          branchName: 'feature/test',
          ratchetEnabled: true,
        });
      });

      it('should use explicit ratchetEnabled value', async () => {
        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'My Workspace',
          ratchetEnabled: false,
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            ratchetEnabled: false,
          })
        );
      });

      it('should default to user settings ratchetEnabled when not provided', async () => {
        const disabledSettings: UserSettings = {
          id: '1',
          userId: 'default',
          preferredIde: 'cursor',
          customIdeCommand: '',
          playSoundOnComplete: true,
          notificationSoundPath: null,
          workspaceOrder: null,
          cachedSlashCommands: null,
          autoFixCiIssues: false,
          autoFixPrReviewComments: false,
          prReviewFixAllowedUsers: null,
          prReviewFixPrompt: null,
          ratchetEnabled: false,
          ratchetAutoFixCi: true,
          ratchetAutoFixConflicts: true,
          ratchetAutoFixReviews: true,
          ratchetAutoMerge: false,
          ratchetAllowedReviewers: null,
          createdAt: new Date(),
          updatedAt: new Date(),
        };
        vi.spyOn(userSettingsAccessorModule.userSettingsAccessor, 'get').mockResolvedValue(
          disabledSettings
        );

        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'My Workspace',
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            ratchetEnabled: false,
          })
        );
      });
    });

    describe('RESUME_BRANCH source', () => {
      beforeEach(() => {
        vi.spyOn(projectAccessorModule.projectAccessor, 'findById').mockResolvedValue(mockProject);
        vi.spyOn(gitOpsServiceModule.gitOpsService, 'isBranchCheckedOut').mockResolvedValue(false);
      });

      it('should create workspace from resume branch source', async () => {
        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'existing-branch',
          name: 'Resumed Workspace',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(projectAccessorModule.projectAccessor.findById).toHaveBeenCalledWith('proj-1');
        expect(gitOpsServiceModule.gitOpsService.isBranchCheckedOut).toHaveBeenCalledWith(
          mockProject,
          'existing-branch'
        );
        expect(worktreeLifecycleServiceModule.setWorkspaceInitMode).toHaveBeenCalledWith(
          'ws-123',
          true,
          '/path/to/worktrees'
        );
      });

      it('should use branch name as workspace name when name not provided', async () => {
        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'my-feature-branch',
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            name: 'my-feature-branch',
          })
        );
      });

      it('should throw error when project not found', async () => {
        vi.spyOn(projectAccessorModule.projectAccessor, 'findById').mockResolvedValue(null);

        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'existing-branch',
        };

        await expect(service.create(source)).rejects.toThrow('Project not found: proj-1');
      });

      it('should throw error when branch is already checked out', async () => {
        vi.spyOn(gitOpsServiceModule.gitOpsService, 'isBranchCheckedOut').mockResolvedValue(true);

        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'existing-branch',
        };

        await expect(service.create(source)).rejects.toThrow(
          "Branch 'existing-branch' is already checked out in another worktree."
        );
      });
    });

    describe('GITHUB_ISSUE source', () => {
      it('should create workspace from GitHub issue source', async () => {
        const source: WorkspaceCreationSource = {
          type: 'GITHUB_ISSUE',
          projectId: 'proj-1',
          issueNumber: 42,
          issueUrl: 'https://github.com/org/repo/issues/42',
          name: 'Fix bug #42',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith({
          projectId: 'proj-1',
          name: 'Fix bug #42',
          githubIssueNumber: 42,
          githubIssueUrl: 'https://github.com/org/repo/issues/42',
          ratchetEnabled: true,
        });
      });

      it('should generate default name from issue number when name not provided', async () => {
        const source: WorkspaceCreationSource = {
          type: 'GITHUB_ISSUE',
          projectId: 'proj-1',
          issueNumber: 42,
          issueUrl: 'https://github.com/org/repo/issues/42',
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            name: 'Issue #42',
          })
        );
      });
    });

    describe('default session provisioning', () => {
      it('should create default session when max sessions > 0', async () => {
        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'Test',
        };

        const result = await service.create(source);

        expect(result.defaultSessionCreated).toBe(true);
        expect(claudeSessionAccessorModule.claudeSessionAccessor.create).toHaveBeenCalledWith({
          workspaceId: 'ws-123',
          workflow: 'feature',
          name: 'Chat 1',
        });
      });

      it('should not create default session when max sessions is 0', async () => {
        vi.mocked(mockConfigService.getMaxSessionsPerWorkspace).mockReturnValue(0);

        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'Test',
        };

        const result = await service.create(source);

        expect(result.defaultSessionCreated).toBe(false);
        expect(claudeSessionAccessorModule.claudeSessionAccessor.create).not.toHaveBeenCalled();
      });

      it('should handle default session creation failure gracefully', async () => {
        vi.spyOn(claudeSessionAccessorModule.claudeSessionAccessor, 'create').mockRejectedValue(
          new Error('Session creation failed')
        );

        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'Test',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(result.defaultSessionCreated).toBe(false);
        expect(mockLogger.warn).toHaveBeenCalledWith(
          'Failed to create default session for workspace',
          expect.objectContaining({
            workspaceId: 'ws-123',
          })
        );
      });
    });
  });

  describe('adaptLegacyCreateInput', () => {
    it('should adapt manual creation input', () => {
      const input = {
        projectId: 'proj-1',
        name: 'My Workspace',
        description: 'Test description',
        branchName: 'feature/test',
      };

      const result = adaptLegacyCreateInput(input);

      expect(result).toEqual({
        type: 'MANUAL',
        projectId: 'proj-1',
        name: 'My Workspace',
        description: 'Test description',
        branchName: 'feature/test',
        ratchetEnabled: undefined,
        githubIssueNumber: undefined,
        githubIssueUrl: undefined,
      });
    });

    it('should preserve partial GitHub issue data in manual fallback', () => {
      const input = {
        projectId: 'proj-1',
        name: 'Test',
        githubIssueNumber: 42,
        // missing githubIssueUrl
      };

      const result = adaptLegacyCreateInput(input);

      expect(result.type).toBe('MANUAL');
      expect(result).toEqual(
        expect.objectContaining({
          githubIssueNumber: 42,
          githubIssueUrl: undefined,
        })
      );
    });

    it('should adapt resume branch input', () => {
      const input = {
        projectId: 'proj-1',
        name: 'Resumed Workspace',
        branchName: 'existing-branch',
        useExistingBranch: true,
      };

      const result = adaptLegacyCreateInput(input);

      expect(result).toEqual({
        type: 'RESUME_BRANCH',
        projectId: 'proj-1',
        branchName: 'existing-branch',
        name: 'Resumed Workspace',
        description: undefined,
        ratchetEnabled: undefined,
      });
    });

    it('should adapt GitHub issue input', () => {
      const input = {
        projectId: 'proj-1',
        name: 'Issue Workspace',
        githubIssueNumber: 42,
        githubIssueUrl: 'https://github.com/org/repo/issues/42',
        ratchetEnabled: false,
      };

      const result = adaptLegacyCreateInput(input);

      expect(result).toEqual({
        type: 'GITHUB_ISSUE',
        projectId: 'proj-1',
        issueNumber: 42,
        issueUrl: 'https://github.com/org/repo/issues/42',
        name: 'Issue Workspace',
        description: undefined,
        ratchetEnabled: false,
      });
    });

    it('should prioritize resume branch over GitHub issue', () => {
      const input = {
        projectId: 'proj-1',
        name: 'Test',
        branchName: 'branch',
        useExistingBranch: true,
        githubIssueNumber: 42,
        githubIssueUrl: 'https://github.com/org/repo/issues/42',
      };

      const result = adaptLegacyCreateInput(input);

      expect(result.type).toBe('RESUME_BRANCH');
    });

    it('should treat GitHub issue with useExistingBranch=false as GitHub issue', () => {
      const input = {
        projectId: 'proj-1',
        name: 'Test',
        useExistingBranch: false,
        githubIssueNumber: 42,
        githubIssueUrl: 'https://github.com/org/repo/issues/42',
      };

      const result = adaptLegacyCreateInput(input);

      expect(result.type).toBe('GITHUB_ISSUE');
    });
  });
});

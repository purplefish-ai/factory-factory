import { SessionStatus } from '@prisma-gen/client';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { sessionDomainService } from '@/backend/domains/session/session-domain.service';
import { unsafeCoerce } from '@/test-utils/unsafe-coerce';
import type { ClaudeClient } from '../claude';

vi.mock('./logger.service', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));

vi.mock('./session.repository', () => ({
  SessionRepository: class {},
  sessionRepository: {
    getSessionById: vi.fn(),
    getSessionsByWorkspaceId: vi.fn(),
    getWorkspaceById: vi.fn(),
    getProjectById: vi.fn(),
    markWorkspaceHasHadSessions: vi.fn(),
    updateSession: vi.fn(),
    clearRatchetActiveSession: vi.fn(),
    deleteSession: vi.fn(),
  },
}));

vi.mock('./session.prompt-builder', () => ({
  SessionPromptBuilder: class {},
  sessionPromptBuilder: {
    shouldInjectBranchRename: vi.fn(),
    buildSystemPrompt: vi.fn(),
  },
}));

vi.mock('./session.process-manager', () => ({
  SessionProcessManager: class {},
  sessionProcessManager: {
    setOnClientCreated: vi.fn(),
    isStopInProgress: vi.fn(),
    createClient: vi.fn(),
    getOrCreateClient: vi.fn(),
    getClient: vi.fn(),
    getPendingClient: vi.fn(),
    stopClient: vi.fn(),
    getClaudeProcess: vi.fn(),
    isSessionRunning: vi.fn(),
    isSessionWorking: vi.fn(),
    isAnySessionWorking: vi.fn(),
    getAllActiveProcesses: vi.fn(),
    getAllClients: vi.fn(),
    stopAllClients: vi.fn(),
  },
}));

import { sessionProcessManager } from './session.process-manager';
import { sessionPromptBuilder } from './session.prompt-builder';
import { sessionRepository } from './session.repository';
import { sessionService } from './session.service';

describe('SessionService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('starts a session via process manager and updates DB state', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
      hasHadSessions: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const project = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getProjectById>>>({
      id: 'project-1',
      githubOwner: 'owner',
    });

    const client = unsafeCoerce<
      Awaited<ReturnType<typeof sessionProcessManager.getOrCreateClient>>
    >({
      getPid: vi.fn().mockReturnValue(123),
      sendMessage: vi.fn().mockResolvedValue(undefined),
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(true);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: true,
    });

    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.getOrCreateClient).mockResolvedValue(client);

    await sessionService.startClaudeSession('session-1', { initialPrompt: 'Hello' });

    expect(sessionPromptBuilder.shouldInjectBranchRename).toHaveBeenCalledWith({
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
      hasHadSessions: false,
    });
    expect(sessionRepository.markWorkspaceHasHadSessions).toHaveBeenCalledWith('workspace-1');
    expect(sessionProcessManager.getOrCreateClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        systemPrompt: 'system',
        model: 'sonnet',
        permissionMode: 'bypassPermissions',
        includePartialMessages: false,
        sessionId: 'session-1',
      }),
      expect.any(Object),
      { workspaceId: 'workspace-1', workingDir: '/tmp/work' }
    );
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
      claudeProcessPid: 123,
    });
    expect(client.sendMessage).toHaveBeenCalledWith('Hello');
  });

  it('returns existing client without loading options', async () => {
    const client = unsafeCoerce<Awaited<ReturnType<typeof sessionProcessManager.getClient>>>({
      isRunning: vi.fn().mockReturnValue(true),
    });

    vi.mocked(sessionProcessManager.getClient).mockReturnValue(client);

    const result = await sessionService.getOrCreateClient('session-1');

    expect(result).toBe(client);
    expect(sessionProcessManager.getOrCreateClient).not.toHaveBeenCalled();
    expect(sessionRepository.getSessionById).not.toHaveBeenCalled();
  });

  it('delegates to processManager.getOrCreateClient for race protection', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const client = unsafeCoerce<
      Awaited<ReturnType<typeof sessionProcessManager.getOrCreateClient>>
    >({
      getPid: vi.fn().mockReturnValue(456),
    });

    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.getOrCreateClient).mockResolvedValue(client);

    const result = await sessionService.getOrCreateClient('session-1');

    expect(result).toBe(client);
    expect(sessionProcessManager.getOrCreateClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        sessionId: 'session-1',
      }),
      expect.any(Object),
      expect.objectContaining({
        workspaceId: 'workspace-1',
        workingDir: '/tmp/work',
      })
    );
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
      claudeProcessPid: 456,
    });
  });

  it('skips stop when already stopping', async () => {
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(true);

    await sessionService.stopClaudeSession('session-1');

    expect(sessionProcessManager.stopClient).not.toHaveBeenCalled();
    expect(sessionRepository.updateSession).not.toHaveBeenCalled();
  });

  it('clears queued work during manual stop', async () => {
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);
    const clearQueuedWorkSpy = vi.spyOn(sessionDomainService, 'clearQueuedWork');

    await sessionService.stopClaudeSession('session-1');

    expect(clearQueuedWorkSpy).toHaveBeenCalledWith('session-1', { emitSnapshot: false });
  });

  it('deletes ratchet session record during manual stop', async () => {
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        workspaceId: 'workspace-1',
        workflow: 'ratchet',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();
    vi.mocked(sessionRepository.deleteSession).mockResolvedValue({} as never);

    await sessionService.stopClaudeSession('session-1');

    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-1'
    );
    expect(sessionRepository.deleteSession).toHaveBeenCalledWith('session-1');
  });

  it('does not delete non-ratchet session during manual stop', async () => {
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-2',
        workspaceId: 'workspace-1',
        workflow: 'default',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);

    await sessionService.stopClaudeSession('session-2');

    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('still stops process and clears queued work when session lookup fails', async () => {
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionRepository.getSessionById).mockRejectedValueOnce(new Error('db unavailable'));
    vi.mocked(sessionProcessManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockRejectedValueOnce(new Error('missing row'));
    const clearQueuedWorkSpy = vi.spyOn(sessionDomainService, 'clearQueuedWork');

    await expect(sessionService.stopClaudeSession('session-err')).resolves.toBeUndefined();

    expect(sessionProcessManager.stopClient).toHaveBeenCalledWith('session-err');
    expect(clearQueuedWorkSpy).toHaveBeenCalledWith('session-err', { emitSnapshot: false });
  });

  it('marks process as stopped when client creation fails', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(sessionProcessManager.getOrCreateClient).mockRejectedValue(new Error('spawn failed'));
    const setRuntimeSnapshotSpy = vi.spyOn(sessionDomainService, 'setRuntimeSnapshot');

    await expect(sessionService.getOrCreateClient('session-1')).rejects.toThrow('spawn failed');

    expect(setRuntimeSnapshotSpy).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        phase: 'error',
        processState: 'stopped',
        activity: 'IDLE',
      })
    );
  });

  it('marks process as stopped when building client options fails', async () => {
    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(null);
    const setRuntimeSnapshotSpy = vi.spyOn(sessionDomainService, 'setRuntimeSnapshot');

    await expect(sessionService.getOrCreateClient('session-1')).rejects.toThrow(
      'Session not found: session-1'
    );

    expect(setRuntimeSnapshotSpy).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        phase: 'error',
        processState: 'stopped',
        activity: 'IDLE',
      })
    );
  });

  it('returns null session options when workspace is missing', async () => {
    const session = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(null);

    const options = await sessionService.getSessionOptions('session-1');

    expect(options).toBeNull();
  });

  it('clears ratchetActiveSessionId and deletes session on ratchet exit', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'ratchet',
      model: 'sonnet',
      claudeSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const project = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getProjectById>>>({
      id: 'project-1',
      githubOwner: 'owner',
    });

    const client = unsafeCoerce<
      Awaited<ReturnType<typeof sessionProcessManager.getOrCreateClient>>
    >({
      getPid: vi.fn().mockReturnValue(456),
      sendMessage: vi.fn().mockResolvedValue(undefined),
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();
    vi.mocked(sessionRepository.deleteSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.getOrCreateClient).mockResolvedValue(client);

    await sessionService.startClaudeSession('session-1');

    // Extract the onExit handler passed to processManager.getOrCreateClient
    const handlers = vi.mocked(sessionProcessManager.getOrCreateClient).mock.calls[0]![2] as {
      onExit: (id: string) => Promise<void>;
    };
    await handlers.onExit('session-1');

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.COMPLETED,
      claudeProcessPid: null,
    });
    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-1'
    );
    expect(sessionRepository.deleteSession).toHaveBeenCalledWith('session-1');
  });

  it('does not delete session on exit for non-ratchet workflows', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-2',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const client = unsafeCoerce<
      Awaited<ReturnType<typeof sessionProcessManager.getOrCreateClient>>
    >({
      getPid: vi.fn().mockReturnValue(789),
      sendMessage: vi.fn().mockResolvedValue(undefined),
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.getOrCreateClient).mockResolvedValue(client);

    await sessionService.startClaudeSession('session-2');

    const handlers = vi.mocked(sessionProcessManager.getOrCreateClient).mock.calls[0]![2] as {
      onExit: (id: string) => Promise<void>;
    };
    await handlers.onExit('session-2');

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-2', {
      status: SessionStatus.COMPLETED,
      claudeProcessPid: null,
    });
    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('stops sessions that are still starting when stopping a workspace', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionsByWorkspaceId>>>[number]
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
    });

    const client = { isRunning: vi.fn().mockReturnValue(true) };
    const pendingClient = Promise.resolve(unsafeCoerce<ClaudeClient>(client));

    vi.mocked(sessionRepository.getSessionsByWorkspaceId).mockResolvedValue([session]);
    vi.mocked(sessionProcessManager.getPendingClient).mockReturnValue(pendingClient);
    vi.mocked(sessionProcessManager.getClaudeProcess).mockReturnValue(undefined);
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    await sessionService.stopWorkspaceSessions('workspace-1');

    expect(sessionProcessManager.getPendingClient).toHaveBeenCalledWith('session-1');
    expect(sessionProcessManager.stopClient).toHaveBeenCalledWith('session-1');
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.IDLE,
      claudeProcessPid: null,
    });
  });

  it('updates DB status when getOrCreateClient creates new client', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const client = unsafeCoerce<
      Awaited<ReturnType<typeof sessionProcessManager.getOrCreateClient>>
    >({
      getPid: vi.fn().mockReturnValue(999),
    });

    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionProcessManager.getPendingClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.getOrCreateClient).mockResolvedValue(client);

    await sessionService.getOrCreateClient('session-1');

    expect(sessionProcessManager.getOrCreateClient).toHaveBeenCalled();
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
      claudeProcessPid: 999,
    });
  });

  it('getOrCreateClient and startClaudeSession produce identical DB state', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const client = unsafeCoerce<
      Awaited<ReturnType<typeof sessionProcessManager.getOrCreateClient>>
    >({
      getPid: vi.fn().mockReturnValue(888),
      sendMessage: vi.fn().mockResolvedValue(undefined),
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.getOrCreateClient).mockResolvedValue(client);

    // Test getOrCreateClient path (WebSocket)
    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionProcessManager.getPendingClient).mockReturnValue(undefined);
    await sessionService.getOrCreateClient('session-1');

    const getOrCreateCalls = vi.mocked(sessionRepository.updateSession).mock.calls;

    // Reset mocks for second test
    vi.clearAllMocks();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.getOrCreateClient).mockResolvedValue(client);

    // Test startClaudeSession path (tRPC)
    await sessionService.startClaudeSession('session-1');

    const startSessionCalls = vi.mocked(sessionRepository.updateSession).mock.calls;

    // Both paths should update DB with identical state
    expect(getOrCreateCalls).toEqual(
      expect.arrayContaining([
        expect.arrayContaining([
          'session-1',
          {
            status: SessionStatus.RUNNING,
            claudeProcessPid: 888,
          },
        ]),
      ])
    );
    expect(startSessionCalls).toEqual(
      expect.arrayContaining([
        expect.arrayContaining([
          'session-1',
          {
            status: SessionStatus.RUNNING,
            claudeProcessPid: 888,
          },
        ]),
      ])
    );
  });
});

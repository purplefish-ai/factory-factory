import { SessionStatus } from '@prisma-gen/client';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import type { ClaudeClient } from '../claude';

vi.mock('./logger.service', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));

vi.mock('./session.repository', () => ({
  SessionRepository: class {},
  sessionRepository: {
    getSessionById: vi.fn(),
    getSessionsByWorkspaceId: vi.fn(),
    getWorkspaceById: vi.fn(),
    getProjectById: vi.fn(),
    markWorkspaceHasHadSessions: vi.fn(),
    updateSession: vi.fn(),
    clearRatchetActiveSession: vi.fn(),
    deleteSession: vi.fn(),
  },
}));

vi.mock('./session.prompt-builder', () => ({
  SessionPromptBuilder: class {},
  sessionPromptBuilder: {
    shouldInjectBranchRename: vi.fn(),
    buildSystemPrompt: vi.fn(),
  },
}));

vi.mock('./session.process-manager', () => ({
  SessionProcessManager: class {},
  sessionProcessManager: {
    setOnClientCreated: vi.fn(),
    isStopInProgress: vi.fn(),
    createClient: vi.fn(),
    getOrCreateClient: vi.fn(),
    getClient: vi.fn(),
    getPendingClient: vi.fn(),
    stopClient: vi.fn(),
    getClaudeProcess: vi.fn(),
    isSessionRunning: vi.fn(),
    isSessionWorking: vi.fn(),
    isAnySessionWorking: vi.fn(),
    getAllActiveProcesses: vi.fn(),
    getAllClients: vi.fn(),
    stopAllClients: vi.fn(),
  },
}));

import { sessionProcessManager } from './session.process-manager';
import { sessionPromptBuilder } from './session.prompt-builder';
import { sessionRepository } from './session.repository';
import { sessionService } from './session.service';

describe('SessionService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('starts a session via process manager and updates DB state', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    const project = {
      id: 'project-1',
      githubOwner: 'owner',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getProjectById>>;

    const client = {
      getPid: vi.fn().mockReturnValue(123),
    } as unknown as Awaited<ReturnType<typeof sessionProcessManager.createClient>>;

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(true);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: true,
    });

    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.createClient).mockResolvedValue(client);

    await sessionService.startClaudeSession('session-1', { initialPrompt: 'Hello' });

    expect(sessionPromptBuilder.shouldInjectBranchRename).toHaveBeenCalledWith({
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
    });
    expect(sessionRepository.markWorkspaceHasHadSessions).toHaveBeenCalledWith('workspace-1');
    expect(sessionProcessManager.createClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        systemPrompt: 'system',
        model: 'sonnet',
        permissionMode: 'bypassPermissions',
        includePartialMessages: true,
        initialPrompt: 'Hello',
        sessionId: 'session-1',
      }),
      expect.any(Object),
      { workspaceId: 'workspace-1', workingDir: '/tmp/work' }
    );
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
      claudeProcessPid: 123,
    });
  });

  it('returns existing client without loading options', async () => {
    const client = { isRunning: vi.fn().mockReturnValue(true) } as unknown as Awaited<
      ReturnType<typeof sessionProcessManager.getClient>
    >;

    vi.mocked(sessionProcessManager.getClient).mockReturnValue(client);

    const result = await sessionService.getOrCreateClient('session-1');

    expect(result).toBe(client);
    expect(sessionProcessManager.getOrCreateClient).not.toHaveBeenCalled();
    expect(sessionRepository.getSessionById).not.toHaveBeenCalled();
  });

  it('returns pending client creation without loading options', async () => {
    const client = { isRunning: vi.fn().mockReturnValue(true) } as unknown as Awaited<
      ReturnType<typeof sessionProcessManager.getOrCreateClient>
    >;
    const pending = Promise.resolve(client);

    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionProcessManager.getPendingClient).mockReturnValue(pending);

    const result = await sessionService.getOrCreateClient('session-1');

    expect(result).toBe(client);
    expect(sessionProcessManager.getOrCreateClient).not.toHaveBeenCalled();
    expect(sessionRepository.getSessionById).not.toHaveBeenCalled();
  });

  it('skips stop when already stopping', async () => {
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(true);

    await sessionService.stopClaudeSession('session-1');

    expect(sessionProcessManager.stopClient).not.toHaveBeenCalled();
    expect(sessionRepository.updateSession).not.toHaveBeenCalled();
  });

  it('returns null session options when workspace is missing', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getSessionById>>;

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(null);

    const options = await sessionService.getSessionOptions('session-1');

    expect(options).toBeNull();
  });

  it('clears ratchetActiveSessionId and deletes session on ratchet exit', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'ratchet',
      model: 'sonnet',
      claudeSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    const project = {
      id: 'project-1',
      githubOwner: 'owner',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getProjectById>>;

    const client = {
      getPid: vi.fn().mockReturnValue(456),
    } as unknown as Awaited<ReturnType<typeof sessionProcessManager.createClient>>;

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();
    vi.mocked(sessionRepository.deleteSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.createClient).mockResolvedValue(client);

    await sessionService.startClaudeSession('session-1');

    // Extract the onExit handler passed to processManager.createClient
    // biome-ignore lint/style/noNonNullAssertion: test assertion — createClient must have been called
    const handlers = vi.mocked(sessionProcessManager.createClient).mock.calls[0]![2] as {
      onExit: (id: string) => Promise<void>;
    };
    await handlers.onExit('session-1');

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.COMPLETED,
      claudeProcessPid: null,
    });
    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-1'
    );
    expect(sessionRepository.deleteSession).toHaveBeenCalledWith('session-1');
  });

  it('does not delete session on exit for non-ratchet workflows', async () => {
    const session = {
      id: 'session-2',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    const client = {
      getPid: vi.fn().mockReturnValue(789),
    } as unknown as Awaited<ReturnType<typeof sessionProcessManager.createClient>>;

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.createClient).mockResolvedValue(client);

    await sessionService.startClaudeSession('session-2');

    // biome-ignore lint/style/noNonNullAssertion: test assertion — createClient must have been called
    const handlers = vi.mocked(sessionProcessManager.createClient).mock.calls[0]![2] as {
      onExit: (id: string) => Promise<void>;
    };
    await handlers.onExit('session-2');

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-2', {
      status: SessionStatus.COMPLETED,
      claudeProcessPid: null,
    });
    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('stops sessions that are still starting when stopping a workspace', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
    } as unknown as NonNullable<
      Awaited<ReturnType<typeof sessionRepository.getSessionsByWorkspaceId>>
    >[number];

    const client = { isRunning: vi.fn().mockReturnValue(true) };
    const pendingClient = Promise.resolve(client as unknown as ClaudeClient);

    vi.mocked(sessionRepository.getSessionsByWorkspaceId).mockResolvedValue([session]);
    vi.mocked(sessionProcessManager.getPendingClient).mockReturnValue(pendingClient);
    vi.mocked(sessionProcessManager.getClaudeProcess).mockReturnValue(undefined);
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    await sessionService.stopWorkspaceSessions('workspace-1');

    expect(sessionProcessManager.getPendingClient).toHaveBeenCalledWith('session-1');
    expect(sessionProcessManager.stopClient).toHaveBeenCalledWith('session-1');
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.IDLE,
      claudeProcessPid: null,
    });
  });

  it('updates DB status when getOrCreateClient creates new client', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    const client = {
      getPid: vi.fn().mockReturnValue(999),
    } as unknown as Awaited<ReturnType<typeof sessionProcessManager.createClient>>;

    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionProcessManager.getPendingClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.createClient).mockResolvedValue(client);

    await sessionService.getOrCreateClient('session-1');

    expect(sessionProcessManager.createClient).toHaveBeenCalled();
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
      claudeProcessPid: 999,
    });
  });

  it('getOrCreateClient and startClaudeSession produce identical DB state', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      claudeSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    const client = {
      getPid: vi.fn().mockReturnValue(888),
    } as unknown as Awaited<ReturnType<typeof sessionProcessManager.createClient>>;

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(sessionProcessManager.createClient).mockResolvedValue(client);

    // Test getOrCreateClient path (WebSocket)
    vi.mocked(sessionProcessManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionProcessManager.getPendingClient).mockReturnValue(undefined);
    await sessionService.getOrCreateClient('session-1');

    const getOrCreateCalls = vi.mocked(sessionRepository.updateSession).mock.calls;

    // Reset mocks for second test
    vi.clearAllMocks();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(sessionProcessManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(sessionProcessManager.createClient).mockResolvedValue(client);

    // Test startClaudeSession path (tRPC)
    await sessionService.startClaudeSession('session-1');

    const startSessionCalls = vi.mocked(sessionRepository.updateSession).mock.calls;

    // Both paths should update DB with identical state
    expect(getOrCreateCalls).toEqual(
      expect.arrayContaining([
        expect.arrayContaining([
          'session-1',
          {
            status: SessionStatus.RUNNING,
            claudeProcessPid: 888,
          },
        ]),
      ])
    );
    expect(startSessionCalls).toEqual(
      expect.arrayContaining([
        expect.arrayContaining([
          'session-1',
          {
            status: SessionStatus.RUNNING,
            claudeProcessPid: 888,
          },
        ]),
      ])
    );
  });
});

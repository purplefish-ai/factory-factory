/**
 * Pre-Push Branch Rename Interceptor
 *
 * Detects `git push` on tool start and renames auto-generated branches
 * before the first remote push so only meaningful branch names are published.
 */

import { projectManagementService, workspaceDataService } from '@/backend/domains/workspace';
import { gitCommand } from '@/backend/lib/shell';
import { createLogger } from '@/backend/services/logger.service';
import { extractMatchingCommand, generateBranchName } from './branch-rename.utils';
import type { InterceptorContext, ToolEvent, ToolInterceptor } from './types';

const logger = createLogger('pre-push-rename');
const GIT_PUSH_REGEX = /\bgit\s+push\b/;

class PrePushRenameInterceptor implements ToolInterceptor {
  readonly name = 'pre-push-rename';
  readonly tools = '*';

  // Track workspaces that have already been renamed to avoid duplicate renames.
  private renamedWorkspaces = new Set<string>();

  stop(): void {
    this.renamedWorkspaces.clear();
  }

  async onToolStart(event: ToolEvent, context: InterceptorContext): Promise<void> {
    let renameCompleted = false;
    try {
      // Check if this is a `git push` command
      const command = extractMatchingCommand(event, GIT_PUSH_REGEX, logger);
      if (!command) {
        return;
      }

      // Skip if already renamed this workspace
      if (this.renamedWorkspaces.has(context.workspaceId)) {
        return;
      }

      const workspace = await workspaceDataService.findById(context.workspaceId);
      if (!workspace) {
        return;
      }

      if (!workspace.isAutoGeneratedBranch) {
        return;
      }
      const oldBranchName = workspace.branchName ?? '';

      logger.info('Detected git push with auto-generated branch, renaming', {
        workspaceId: context.workspaceId,
        currentBranch: oldBranchName,
      });

      // Mark immediately to prevent races from parallel tool calls
      this.renamedWorkspaces.add(context.workspaceId);

      const project = await projectManagementService.findById(workspace.projectId);
      const newBranchName = generateBranchName({
        branchPrefix: project?.githubOwner ?? '',
        workspaceName: workspace.name,
      });

      if (!newBranchName) {
        logger.warn('Could not generate branch name from workspace context', {
          workspaceId: context.workspaceId,
          workspaceName: workspace.name,
        });
        this.renamedWorkspaces.delete(context.workspaceId);
        return;
      }

      if (newBranchName === oldBranchName) {
        await workspaceDataService.clearAutoGeneratedBranch(context.workspaceId);
        return;
      }

      // Rename the branch directly via git
      const result = await gitCommand(['branch', '-m', newBranchName], context.workingDir);
      if (result.code !== 0) {
        logger.warn('Failed to rename branch before push', {
          workspaceId: context.workspaceId,
          newBranchName,
          stderr: result.stderr,
        });
        // Remove from set so it can be retried
        this.renamedWorkspaces.delete(context.workspaceId);
        return;
      }

      // Persist the new name and clear the auto-generated flag
      await workspaceDataService.setBranchName(context.workspaceId, newBranchName);
      await workspaceDataService.clearAutoGeneratedBranch(context.workspaceId);
      renameCompleted = true;

      logger.info('Renamed branch before push', {
        workspaceId: context.workspaceId,
        oldBranch: oldBranchName,
        newBranch: newBranchName,
      });
    } catch (error) {
      if (!renameCompleted) {
        this.renamedWorkspaces.delete(context.workspaceId);
      }
      logger.error('Error in pre-push rename interceptor', {
        workspaceId: context.workspaceId,
        error,
      });
    }
  }
}

export function createPrePushRenameInterceptor(): ToolInterceptor {
  return new PrePushRenameInterceptor();
}

export const prePushRenameInterceptor = createPrePushRenameInterceptor();

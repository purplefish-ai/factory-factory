import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import type { InterceptorContext, ToolEvent } from './types';

const mockSessionInterceptorBridge = vi.hoisted(() => ({
  getSessionConversationHistory: vi.fn(),
  isSessionRunning: vi.fn(),
  sendSessionMessage: vi.fn(),
}));

const mockWorkspaceDataService = vi.hoisted(() => ({
  findById: vi.fn(),
}));

const mockProjectManagementService = vi.hoisted(() => ({
  findById: vi.fn(),
}));

const mockBuildBranchRenameInstruction = vi.hoisted(() => vi.fn());
const mockCountUserMessages = vi.hoisted(() => vi.fn());
const mockExtractKeyTopics = vi.hoisted(() => vi.fn());

vi.mock('@/backend/domains/session', () => ({
  sessionInterceptorBridge: mockSessionInterceptorBridge,
}));

vi.mock('@/backend/domains/workspace', () => ({
  workspaceDataService: mockWorkspaceDataService,
  projectManagementService: mockProjectManagementService,
}));

vi.mock('@/backend/prompts/branch-rename', () => ({
  buildBranchRenameInstruction: (...args: unknown[]) => mockBuildBranchRenameInstruction(...args),
}));

vi.mock('@/backend/services/config.service', () => ({
  configService: {
    getBranchRenameMessageThreshold: () => 2,
  },
}));

vi.mock('@/backend/utils/conversation-analyzer', () => ({
  countUserMessages: (...args: unknown[]) => mockCountUserMessages(...args),
  extractKeyTopics: (...args: unknown[]) => mockExtractKeyTopics(...args),
}));

vi.mock('@/backend/services/logger.service', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));

import {
  conversationRenameInterceptor,
  createConversationRenameInterceptor,
} from './conversation-rename.interceptor';

const context: InterceptorContext = {
  sessionId: 'session-1',
  workspaceId: 'workspace-1',
  workingDir: '/tmp/worktree',
  timestamp: new Date('2026-02-19T00:00:00.000Z'),
};

const event: ToolEvent = {
  toolUseId: 'tool-1',
  toolName: 'Bash',
  input: { command: 'echo hi' },
};

describe('conversationRenameInterceptor', () => {
  afterEach(() => {
    conversationRenameInterceptor.stop?.();
  });

  beforeEach(() => {
    vi.clearAllMocks();
    mockWorkspaceDataService.findById.mockResolvedValue({
      id: 'workspace-1',
      projectId: 'project-1',
      name: 'Workspace',
      description: 'Desc',
      isAutoGeneratedBranch: true,
    });
    mockSessionInterceptorBridge.getSessionConversationHistory.mockResolvedValue([
      { type: 'user', text: 'Please refactor this module' },
    ]);
    mockCountUserMessages.mockReturnValue(2);
    mockExtractKeyTopics.mockReturnValue('refactor module tests');
    mockProjectManagementService.findById.mockResolvedValue({
      id: 'project-1',
      githubOwner: 'purplefish-ai',
    });
    mockBuildBranchRenameInstruction.mockReturnValue('rename-branch-instruction');
    mockSessionInterceptorBridge.isSessionRunning.mockReturnValue(true);
    mockSessionInterceptorBridge.sendSessionMessage.mockResolvedValue(undefined);
  });

  it('sends rename instruction when threshold is reached', async () => {
    await conversationRenameInterceptor.onToolComplete?.(event, context);

    expect(mockBuildBranchRenameInstruction).toHaveBeenCalledWith({
      branchPrefix: 'purplefish-ai',
      workspaceName: 'Workspace',
      workspaceDescription: 'Desc',
      conversationSummary: 'refactor module tests',
    });
    expect(mockSessionInterceptorBridge.sendSessionMessage).toHaveBeenCalledWith(
      'session-1',
      'rename-branch-instruction'
    );
  });

  it('does not send instructions for non-auto-generated branches', async () => {
    mockWorkspaceDataService.findById.mockResolvedValue({
      id: 'workspace-1',
      projectId: 'project-1',
      name: 'Workspace',
      isAutoGeneratedBranch: false,
    });

    await conversationRenameInterceptor.onToolComplete?.(event, {
      ...context,
      sessionId: 'session-2',
    });
    expect(mockSessionInterceptorBridge.sendSessionMessage).not.toHaveBeenCalled();
  });

  it('skips sending when session is not running', async () => {
    mockSessionInterceptorBridge.isSessionRunning.mockReturnValue(false);

    await conversationRenameInterceptor.onToolComplete?.(event, {
      ...context,
      sessionId: 'session-3',
    });
    expect(mockSessionInterceptorBridge.sendSessionMessage).not.toHaveBeenCalled();
  });

  it('handles internal errors without throwing', async () => {
    mockWorkspaceDataService.findById.mockRejectedValue(new Error('db unavailable'));

    await expect(
      conversationRenameInterceptor.onToolComplete?.(event, { ...context, sessionId: 'session-4' })
    ).resolves.toBeUndefined();
  });

  it('starts and stops cleanup interval via lifecycle hooks', () => {
    const setIntervalSpy = vi.spyOn(globalThis, 'setInterval');
    const clearIntervalSpy = vi.spyOn(globalThis, 'clearInterval');

    conversationRenameInterceptor.start?.();
    conversationRenameInterceptor.start?.();

    expect(setIntervalSpy).toHaveBeenCalledTimes(1);

    conversationRenameInterceptor.stop?.();

    expect(clearIntervalSpy).toHaveBeenCalledTimes(1);

    setIntervalSpy.mockRestore();
    clearIntervalSpy.mockRestore();
  });

  it('factory instances keep processed-session state isolated', async () => {
    const interceptorA = createConversationRenameInterceptor();
    const interceptorB = createConversationRenameInterceptor();

    await interceptorA.onToolComplete?.(event, context);
    await interceptorA.onToolComplete?.(event, context);
    await interceptorB.onToolComplete?.(event, context);

    expect(mockSessionInterceptorBridge.sendSessionMessage).toHaveBeenCalledTimes(2);
  });
});

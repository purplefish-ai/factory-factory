/**
 * Conversation-Based Branch Rename Interceptor
 *
 * Monitors conversation progress and triggers branch renaming after 2 user messages
 * if the branch is still auto-generated. Uses conversation context to generate
 * a more descriptive branch name.
 */

import { sessionInterceptorBridge } from '@/backend/domains/session';
import { projectManagementService, workspaceDataService } from '@/backend/domains/workspace';
import { buildBranchRenameInstruction } from '@/backend/prompts/branch-rename';
import { configService } from '@/backend/services/config.service';
import { createLogger } from '@/backend/services/logger.service';
import { countUserMessages, extractKeyTopics } from '@/backend/utils/conversation-analyzer';
import type { InterceptorContext, ToolEvent, ToolInterceptor } from './types';

const logger = createLogger('conversation-rename');
const CLEANUP_INTERVAL_MS = 60 * 60 * 1000; // 1 hour
const MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours

// Message count threshold for triggering rename (configurable via config service)
const MESSAGE_THRESHOLD = configService.getBranchRenameMessageThreshold();

class ConversationRenameInterceptor implements ToolInterceptor {
  readonly name = 'conversation-rename';
  readonly tools: string[] = ['*'];

  // Track which sessions have already been processed to avoid duplicate renames.
  // Map values are timestamps so old entries can be pruned.
  private processedSessions = new Map<string, number>();
  private cleanupInterval: ReturnType<typeof setInterval> | undefined;

  private cleanupProcessedSessions(): void {
    const now = Date.now();
    let cleaned = 0;
    for (const [sessionId, timestamp] of this.processedSessions.entries()) {
      if (now - timestamp > MAX_AGE_MS) {
        this.processedSessions.delete(sessionId);
        cleaned++;
      }
    }
    if (cleaned > 0) {
      logger.info('Cleaned up old processed session entries', {
        cleaned,
        remaining: this.processedSessions.size,
      });
    }
  }

  start(): void {
    if (this.cleanupInterval) {
      return;
    }

    this.cleanupInterval = setInterval(() => this.cleanupProcessedSessions(), CLEANUP_INTERVAL_MS);
  }

  stop(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = undefined;
    }

    this.processedSessions.clear();
  }

  async onToolComplete(_event: ToolEvent, context: InterceptorContext): Promise<void> {
    try {
      // Skip if already processed this session
      if (this.processedSessions.has(context.sessionId)) {
        return;
      }

      // Get workspace to check branch name
      const workspace = await workspaceDataService.findById(context.workspaceId);
      if (!workspace) {
        return;
      }

      // Skip if branch is not auto-generated (already renamed)
      // Use the stored flag rather than pattern matching, so we don't break
      // if workspace words are changed in the future
      if (!workspace.isAutoGeneratedBranch) {
        this.processedSessions.set(context.sessionId, Date.now());
        return;
      }

      // Read history through session lifecycle service so provider-specific
      // session internals remain encapsulated.
      const history = await sessionInterceptorBridge.getSessionConversationHistory(
        context.sessionId,
        context.workingDir
      );
      if (history.length === 0) {
        return;
      }

      // Count user messages
      const userMessageCount = countUserMessages(history);

      logger.info('Checking conversation progress', {
        sessionId: context.sessionId,
        workspaceId: context.workspaceId,
        userMessageCount,
        threshold: MESSAGE_THRESHOLD,
      });

      // Trigger rename if we've reached the threshold
      // Skip if count is <= 1 to avoid conflict with initial session rename
      if (userMessageCount >= MESSAGE_THRESHOLD && userMessageCount > 1) {
        logger.info('Triggering conversation-based branch rename', {
          sessionId: context.sessionId,
          workspaceId: context.workspaceId,
          userMessageCount,
        });

        // Mark as processed immediately to prevent race condition
        // (before any async operations that could run in parallel)
        this.processedSessions.set(context.sessionId, Date.now());

        // Extract key topics from conversation
        const conversationSummary = extractKeyTopics(history);

        logger.info('Extracted conversation topics', {
          sessionId: context.sessionId,
          conversationSummary,
        });

        // Get project info for branch prefix
        const project = await projectManagementService.findById(workspace.projectId);

        // Build rename instruction with conversation context
        // Only include summary if non-empty
        const renameInstruction = buildBranchRenameInstruction({
          branchPrefix: project?.githubOwner ?? '',
          workspaceName: workspace.name,
          workspaceDescription: workspace.description ?? undefined,
          conversationSummary: conversationSummary || undefined,
        });

        logger.info('Generated branch rename instruction', {
          sessionId: context.sessionId,
          hasConversationSummary: !!conversationSummary,
        });

        if (!sessionInterceptorBridge.isSessionRunning(context.sessionId)) {
          logger.warn('Session not running; skipping branch rename instruction', {
            sessionId: context.sessionId,
          });
          return;
        }

        logger.info('Sending branch rename instruction to session', {
          sessionId: context.sessionId,
        });

        sessionInterceptorBridge
          .sendSessionMessage(context.sessionId, renameInstruction)
          .catch((error) => {
            logger.warn('Failed to send rename instruction', {
              sessionId: context.sessionId,
              error,
            });
          });
      }
    } catch (error) {
      logger.error('Error in conversation rename interceptor', {
        sessionId: context.sessionId,
        error,
      });
    }
  }
}

export function createConversationRenameInterceptor(): ToolInterceptor {
  return new ConversationRenameInterceptor();
}

export const conversationRenameInterceptor = createConversationRenameInterceptor();

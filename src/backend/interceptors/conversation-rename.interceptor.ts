/**
 * Conversation-Based Branch Rename Interceptor
 *
 * Monitors conversation progress and triggers branch renaming after 2 user messages
 * if the branch is still auto-generated. Uses conversation context to generate
 * a more descriptive branch name.
 */

import { sessionService } from '@/backend/domains/session/lifecycle/session.service';
import { projectManagementService, workspaceDataService } from '@/backend/domains/workspace';
import { buildBranchRenameInstruction } from '@/backend/prompts/branch-rename';
import { configService } from '@/backend/services/config.service';
import { createLogger } from '@/backend/services/logger.service';
import { countUserMessages, extractKeyTopics } from '@/backend/utils/conversation-analyzer';
import type { InterceptorContext, ToolEvent, ToolInterceptor } from './types';

const logger = createLogger('conversation-rename');

// Track which sessions have already been processed to avoid duplicate renames
// Use a Map with timestamps to enable cleanup of old entries (prevents memory leak)
const processedSessions = new Map<string, number>();

// Cleanup old processed sessions entries after 24 hours
const CLEANUP_INTERVAL_MS = 60 * 60 * 1000; // 1 hour
const MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours

// Message count threshold for triggering rename (configurable via config service)
const MESSAGE_THRESHOLD = configService.getBranchRenameMessageThreshold();

// Periodically clean up old entries to prevent memory leak
setInterval(() => {
  const now = Date.now();
  let cleaned = 0;
  for (const [sessionId, timestamp] of processedSessions.entries()) {
    if (now - timestamp > MAX_AGE_MS) {
      processedSessions.delete(sessionId);
      cleaned++;
    }
  }
  if (cleaned > 0) {
    logger.info('Cleaned up old processed session entries', {
      cleaned,
      remaining: processedSessions.size,
    });
  }
}, CLEANUP_INTERVAL_MS);

export const conversationRenameInterceptor: ToolInterceptor = {
  name: 'conversation-rename',
  tools: ['*'], // Listen to all tool completions

  async onToolComplete(_event: ToolEvent, context: InterceptorContext): Promise<void> {
    try {
      // Skip if already processed this session
      if (processedSessions.has(context.sessionId)) {
        return;
      }

      // Get workspace to check branch name
      const workspace = await workspaceDataService.findById(context.workspaceId);
      if (!workspace) {
        return;
      }

      // Skip if branch is not auto-generated (already renamed)
      // Use the stored flag rather than pattern matching, so we don't break
      // if workspace words are changed in the future
      if (!workspace.isAutoGeneratedBranch) {
        processedSessions.set(context.sessionId, Date.now());
        return;
      }

      // Read history through session lifecycle service so provider-specific
      // session internals remain encapsulated.
      const history = await sessionService.getSessionConversationHistory(
        context.sessionId,
        context.workingDir
      );
      if (history.length === 0) {
        return;
      }

      // Count user messages
      const userMessageCount = countUserMessages(history);

      logger.info('Checking conversation progress', {
        sessionId: context.sessionId,
        workspaceId: context.workspaceId,
        userMessageCount,
        threshold: MESSAGE_THRESHOLD,
      });

      // Trigger rename if we've reached the threshold
      // Skip if count is <= 1 to avoid conflict with initial session rename
      if (userMessageCount >= MESSAGE_THRESHOLD && userMessageCount > 1) {
        logger.info('Triggering conversation-based branch rename', {
          sessionId: context.sessionId,
          workspaceId: context.workspaceId,
          userMessageCount,
        });

        // Mark as processed immediately to prevent race condition
        // (before any async operations that could run in parallel)
        processedSessions.set(context.sessionId, Date.now());

        // Extract key topics from conversation
        const conversationSummary = extractKeyTopics(history);

        logger.info('Extracted conversation topics', {
          sessionId: context.sessionId,
          conversationSummary,
        });

        // Get project info for branch prefix
        const project = await projectManagementService.findById(workspace.projectId);

        // Build rename instruction with conversation context
        // Only include summary if non-empty
        const renameInstruction = buildBranchRenameInstruction({
          branchPrefix: project?.githubOwner ?? '',
          workspaceName: workspace.name,
          workspaceDescription: workspace.description ?? undefined,
          conversationSummary: conversationSummary || undefined,
        });

        logger.info('Generated branch rename instruction', {
          sessionId: context.sessionId,
          hasConversationSummary: !!conversationSummary,
        });

        // Send the rename instruction as a user message
        // The instruction contains <system_instruction> tags but is sent as user content
        // This will prompt Claude to rename the branch with conversation context
        const client = sessionService.getClient(context.sessionId) as
          | { sendMessage: (msg: string) => Promise<void> }
          | undefined;

        if (client) {
          logger.info('Sending branch rename instruction to Claude', {
            sessionId: context.sessionId,
          });

          // Send the instruction (contains <system_instruction> XML tags)
          client.sendMessage(renameInstruction).catch((error: unknown) => {
            logger.warn('Failed to send rename instruction', {
              sessionId: context.sessionId,
              error,
            });
          });
        } else {
          logger.warn('Could not get Claude client to send rename instruction', {
            sessionId: context.sessionId,
          });
        }
      }
    } catch (error) {
      logger.error('Error in conversation rename interceptor', {
        sessionId: context.sessionId,
        error,
      });
    }
  },
};

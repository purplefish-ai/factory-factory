import { SessionStatus } from '@factory-factory/core';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { sessionDomainService } from '@/backend/domains/session/session-domain.service';
import { unsafeCoerce } from '@/test-utils/unsafe-coerce';

vi.mock('@/backend/services/logger.service', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));

vi.mock('@/backend/domains/session/acp', async (importOriginal) => {
  const actual = (await importOriginal()) as Record<string, unknown>;
  return {
    ...actual,
    AcpEventTranslator: class MockAcpEventTranslator {
      translateSessionUpdate = vi.fn().mockReturnValue([]);
    },
    AcpPermissionBridge: class MockAcpPermissionBridge {
      cancelAll = vi.fn();
      resolvePermission = vi.fn();
    },
    acpRuntimeManager: {
      getClient: vi.fn().mockReturnValue(undefined),
      getOrCreateClient: vi.fn(),
      stopClient: vi.fn(),
      stopAllClients: vi.fn(),
      sendPrompt: vi.fn(),
      cancelPrompt: vi.fn(),
      isSessionRunning: vi.fn().mockReturnValue(false),
      isSessionWorking: vi.fn().mockReturnValue(false),
      isAnySessionWorking: vi.fn().mockReturnValue(false),
      isStopInProgress: vi.fn().mockReturnValue(false),
      setConfigOption: vi.fn(),
    },
  };
});

vi.mock('./session.repository', () => ({
  SessionRepository: class {},
  sessionRepository: {
    getSessionById: vi.fn(),
    getSessionsByWorkspaceId: vi.fn(),
    getWorkspaceById: vi.fn(),
    getProjectById: vi.fn(),
    markWorkspaceHasHadSessions: vi.fn(),
    updateSession: vi.fn(),
    clearRatchetActiveSession: vi.fn(),
    deleteSession: vi.fn(),
  },
}));

vi.mock('./session.prompt-builder', () => ({
  SessionPromptBuilder: class {},
  sessionPromptBuilder: {
    shouldInjectBranchRename: vi.fn(),
    buildSystemPrompt: vi.fn(),
  },
}));

import type { AcpProcessHandle } from '@/backend/domains/session/acp';
import { acpRuntimeManager } from '@/backend/domains/session/acp';
import { sessionPromptBuilder } from './session.prompt-builder';
import { sessionRepository } from './session.repository';
import { sessionService } from './session.service';

describe('SessionService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(acpRuntimeManager.isSessionRunning).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.isSessionWorking).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.isAnySessionWorking).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
  });

  it('starts a session via ACP runtime and updates DB state', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
      hasHadSessions: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const project = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getProjectById>>>({
      id: 'project-1',
      githubOwner: 'owner',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(123),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(true);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: true,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-1', { initialPrompt: 'Hello' });

    expect(sessionPromptBuilder.shouldInjectBranchRename).toHaveBeenCalledWith({
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
      hasHadSessions: false,
    });
    expect(sessionRepository.markWorkspaceHasHadSessions).toHaveBeenCalledWith('workspace-1');
    expect(acpRuntimeManager.getOrCreateClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        systemPrompt: 'system',
        model: 'sonnet',
        permissionMode: 'bypassPermissions',
        sessionId: 'session-1',
      }),
      expect.any(Object),
      { workspaceId: 'workspace-1', workingDir: '/tmp/work' }
    );
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
    });
  });

  it('delegates to ACP runtime for new session creation', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    const result = await sessionService.getOrCreateSessionClient('session-1');

    expect(result).toBe(acpHandle);
    expect(acpRuntimeManager.getOrCreateClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        sessionId: 'session-1',
      }),
      expect.any(Object),
      expect.objectContaining({
        workspaceId: 'workspace-1',
        workingDir: '/tmp/work',
      })
    );
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
    });
  });

  it('skips stop when already stopping', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(true);

    await sessionService.stopSession('session-1');

    expect(acpRuntimeManager.stopClient).not.toHaveBeenCalled();
    expect(sessionRepository.updateSession).not.toHaveBeenCalled();
  });

  it('clears queued work during manual stop', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);
    const clearQueuedWorkSpy = vi.spyOn(sessionDomainService, 'clearQueuedWork');

    await sessionService.stopSession('session-1');

    expect(clearQueuedWorkSpy).toHaveBeenCalledWith('session-1', { emitSnapshot: false });
  });

  it('deletes ratchet session record during manual stop', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        workspaceId: 'workspace-1',
        workflow: 'ratchet',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();
    vi.mocked(sessionRepository.deleteSession).mockResolvedValue({} as never);

    await sessionService.stopSession('session-1');

    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-1'
    );
    expect(sessionRepository.deleteSession).toHaveBeenCalledWith('session-1');
  });

  it('does not delete non-ratchet session during manual stop', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-2',
        workspaceId: 'workspace-1',
        workflow: 'default',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);

    await sessionService.stopSession('session-2');

    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('clears ratchet pointer but does not delete session when transient cleanup is disabled', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-3',
        workspaceId: 'workspace-1',
        workflow: 'ratchet',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);

    await sessionService.stopSession('session-3', {
      cleanupTransientRatchetSession: false,
    });

    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-3'
    );
    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('marks process as stopped when ACP client creation fails', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockRejectedValue(new Error('spawn failed'));
    const setRuntimeSnapshotSpy = vi.spyOn(sessionDomainService, 'setRuntimeSnapshot');

    await expect(sessionService.getOrCreateSessionClient('session-1')).rejects.toThrow(
      'spawn failed'
    );

    expect(setRuntimeSnapshotSpy).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        phase: 'starting',
        processState: 'alive',
        activity: 'IDLE',
      })
    );
  });

  it('throws when session not found during client creation', async () => {
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(null);

    await expect(sessionService.getOrCreateSessionClient('session-1')).rejects.toThrow(
      'Session not found: session-1'
    );
  });

  it('returns null session options when workspace is missing', async () => {
    const session = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      providerSessionId: null,
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(null);

    const options = await sessionService.getSessionOptions('session-1');

    expect(options).toBeNull();
  });

  it('clears ratchetActiveSessionId and deletes session on ACP ratchet exit', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'ratchet',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const project = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getProjectById>>>({
      id: 'project-1',
      githubOwner: 'owner',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();
    vi.mocked(sessionRepository.deleteSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-1');

    // Extract the onExit handler from the ACP event handlers passed to acpRuntimeManager
    const acpHandlers = vi.mocked(acpRuntimeManager.getOrCreateClient).mock.calls[0]![2] as {
      onExit: (id: string, exitCode: number | null) => Promise<void>;
    };
    await acpHandlers.onExit('session-1', 0);

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.COMPLETED,
    });
    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-1'
    );
    expect(sessionRepository.deleteSession).toHaveBeenCalledWith('session-1');
  });

  it('does not delete session on ACP exit for non-ratchet workflows', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-2',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(789),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-2');

    const acpHandlers = vi.mocked(acpRuntimeManager.getOrCreateClient).mock.calls[0]![2] as {
      onExit: (id: string, exitCode: number | null) => Promise<void>;
    };
    await acpHandlers.onExit('session-2', 0);

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-2', {
      status: SessionStatus.COMPLETED,
    });
    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('updates DB status when ACP client is created', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(999),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    await sessionService.getOrCreateSessionClient('session-1');

    expect(acpRuntimeManager.getOrCreateClient).toHaveBeenCalled();
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
    });
  });

  it('returns ACP config options for active session handles', () => {
    const configOptions = [
      {
        id: 'model',
        name: 'Model',
        type: 'string',
        category: 'model',
        currentValue: 'sonnet',
        options: [{ value: 'sonnet', name: 'Sonnet' }],
      },
    ];
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        configOptions,
      })
    );

    expect(sessionService.getSessionConfigOptions('session-1')).toEqual(configOptions);
  });

  it('returns empty config options when no ACP handle is active', () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);

    expect(sessionService.getSessionConfigOptions('session-1')).toEqual([]);
  });

  it('returns CODEX provider fallback capabilities when no ACP handle is active', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-codex',
        provider: 'CODEX',
      })
    );

    const capabilities = await sessionService.getChatBarCapabilities('session-codex');

    expect(capabilities.provider).toBe('CODEX');
    expect(capabilities.model.enabled).toBe(false);
  });

  it('skips setSessionModel when requested model is not in ACP model options', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        provider: 'CODEX',
        configOptions: [
          {
            id: 'model',
            name: 'Model',
            type: 'select',
            category: 'model',
            currentValue: 'gpt-5.3-codex',
            options: [
              { value: 'gpt-5.3-codex', name: 'GPT-5.3 Codex' },
              { value: 'gpt-5.2-codex', name: 'GPT-5.2 Codex' },
            ],
          },
        ],
      })
    );

    await sessionService.setSessionModel('session-codex', 'opus');

    expect(acpRuntimeManager.setConfigOption).not.toHaveBeenCalled();
  });

  it('applies setSessionModel when requested model is supported by ACP options', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        provider: 'CODEX',
        configOptions: [
          {
            id: 'model',
            name: 'Model',
            type: 'select',
            category: 'model',
            currentValue: 'gpt-5.3-codex',
            options: [
              { value: 'gpt-5.3-codex', name: 'GPT-5.3 Codex' },
              { value: 'gpt-5.2-codex', name: 'GPT-5.2 Codex' },
            ],
          },
        ],
      })
    );
    vi.mocked(acpRuntimeManager.setConfigOption).mockResolvedValue([
      {
        id: 'model',
        name: 'Model',
        type: 'select',
        category: 'model',
        currentValue: 'gpt-5.2-codex',
        options: [{ value: 'gpt-5.2-codex', name: 'GPT-5.2 Codex' }],
      },
    ] as never);

    await sessionService.setSessionModel('session-codex', 'gpt-5.2-codex');

    expect(acpRuntimeManager.setConfigOption).toHaveBeenCalledWith(
      'session-codex',
      'model',
      'gpt-5.2-codex'
    );
  });

  it('avoids redundant session DB lookups during startSession', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      hasHadSessions: true,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(111),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-1', { initialPrompt: 'go' });

    // startSession loads session once and passes to getOrCreateAcpSessionClient(session)
    // which passes to createAcpClient(session) -> loadSessionContext(preloadedSession)
    // Total: 1 call (session is passed through, no redundant DB lookup)
    expect(sessionRepository.getSessionById).toHaveBeenCalledTimes(1);
  });

  it('normalizes stale loading runtime to idle when no process is active', () => {
    vi.spyOn(sessionDomainService, 'getRuntimeSnapshot').mockReturnValue({
      phase: 'loading',
      processState: 'unknown',
      activity: 'IDLE',
      updatedAt: new Date('2026-02-10T01:45:35.844Z').toISOString(),
    });

    const runtime = sessionService.getRuntimeSnapshot('session-1');

    expect(runtime).toMatchObject({
      phase: 'idle',
      processState: 'stopped',
      activity: 'IDLE',
    });
  });

  it('keeps recent loading runtime when no process is active', () => {
    vi.spyOn(sessionDomainService, 'getRuntimeSnapshot').mockReturnValue({
      phase: 'loading',
      processState: 'unknown',
      activity: 'IDLE',
      updatedAt: new Date().toISOString(),
    });

    const runtime = sessionService.getRuntimeSnapshot('session-1');

    expect(runtime).toMatchObject({
      phase: 'loading',
      processState: 'unknown',
      activity: 'IDLE',
    });
  });

  it('stops all ACP clients during shutdown', async () => {
    vi.mocked(acpRuntimeManager.stopAllClients).mockResolvedValue(undefined);

    await sessionService.stopAllClients(4321);

    expect(acpRuntimeManager.stopAllClients).toHaveBeenCalledTimes(1);
  });

  it('propagates ACP shutdown failure', async () => {
    vi.mocked(acpRuntimeManager.stopAllClients).mockRejectedValueOnce(
      new Error('acp shutdown failed')
    );

    await expect(sessionService.stopAllClients()).rejects.toThrow('acp shutdown failed');
  });
});

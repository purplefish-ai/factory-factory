import { beforeEach, describe, expect, it, vi } from 'vitest';
import { sessionDomainService } from '@/backend/domains/session/session-domain.service';
import { SessionStatus } from '@/shared/core';
import { unsafeCoerce } from '@/test-utils/unsafe-coerce';

vi.mock('@/backend/services/logger.service', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));

vi.mock('@/backend/domains/session/acp', async (importOriginal) => {
  const actual = (await importOriginal()) as Record<string, unknown>;
  return {
    ...actual,
    AcpEventTranslator: class MockAcpEventTranslator {
      translateSessionUpdate = vi.fn().mockReturnValue([]);
    },
    AcpPermissionBridge: class MockAcpPermissionBridge {
      cancelAll = vi.fn();
      resolvePermission = vi.fn();
    },
    acpRuntimeManager: {
      getClient: vi.fn().mockReturnValue(undefined),
      getOrCreateClient: vi.fn(),
      stopClient: vi.fn(),
      stopAllClients: vi.fn(),
      sendPrompt: vi.fn(),
      cancelPrompt: vi.fn(),
      isSessionRunning: vi.fn().mockReturnValue(false),
      isSessionWorking: vi.fn().mockReturnValue(false),
      isAnySessionWorking: vi.fn().mockReturnValue(false),
      isStopInProgress: vi.fn().mockReturnValue(false),
      setConfigOption: vi.fn(),
      setSessionMode: vi.fn(),
      setSessionModel: vi.fn(),
    },
  };
});

vi.mock('./session.repository', () => ({
  SessionRepository: class {},
  sessionRepository: {
    getSessionById: vi.fn(),
    getSessionsByWorkspaceId: vi.fn(),
    getWorkspaceById: vi.fn(),
    getProjectById: vi.fn(),
    markWorkspaceHasHadSessions: vi.fn(),
    updateSession: vi.fn(),
    clearRatchetActiveSession: vi.fn(),
    deleteSession: vi.fn(),
  },
}));

vi.mock('./session.prompt-builder', () => ({
  SessionPromptBuilder: class {},
  sessionPromptBuilder: {
    shouldInjectBranchRename: vi.fn(),
    buildSystemPrompt: vi.fn(),
  },
}));

import type { AcpProcessHandle } from '@/backend/domains/session/acp';
import { acpRuntimeManager } from '@/backend/domains/session/acp';
import { sessionPromptBuilder } from './session.prompt-builder';
import { sessionRepository } from './session.repository';
import { sessionService } from './session.service';

describe('SessionService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    sessionService.setPromptTurnCompleteHandler(null);
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(acpRuntimeManager.isSessionRunning).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.isSessionWorking).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.isAnySessionWorking).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
  });

  it('starts a session via ACP runtime and updates DB state', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
      hasHadSessions: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const project = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getProjectById>>>({
      id: 'project-1',
      githubOwner: 'owner',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(123),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(true);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: true,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-1', { initialPrompt: 'Hello' });

    expect(sessionPromptBuilder.shouldInjectBranchRename).toHaveBeenCalledWith({
      branchName: 'auto-branch',
      isAutoGeneratedBranch: true,
      hasHadSessions: false,
    });
    expect(sessionRepository.markWorkspaceHasHadSessions).toHaveBeenCalledWith('workspace-1');
    expect(acpRuntimeManager.getOrCreateClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        systemPrompt: 'system',
        model: 'sonnet',
        permissionMode: 'bypassPermissions',
        sessionId: 'session-1',
      }),
      expect.any(Object),
      { workspaceId: 'workspace-1', workingDir: '/tmp/work' }
    );
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
    });
  });

  it('delegates to ACP runtime for new session creation', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    const result = await sessionService.getOrCreateSessionClient('session-1');

    expect(result).toBe(acpHandle);
    expect(acpRuntimeManager.getOrCreateClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        sessionId: 'session-1',
      }),
      expect.any(Object),
      expect.objectContaining({
        workspaceId: 'workspace-1',
        workingDir: '/tmp/work',
      })
    );
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
    });
  });

  it('applies Claude non-interactive startup mode preset when bypassPermissions is available', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });
    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      hasHadSessions: true,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });
    const modeConfig = {
      id: 'mode',
      name: 'Mode',
      type: 'select',
      category: 'mode',
      currentValue: 'default',
      options: [
        { value: 'default', name: 'Default' },
        { value: 'bypassPermissions', name: 'Bypass Permissions' },
      ],
    };
    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      provider: 'CLAUDE',
      providerSessionId: 'provider-session-1',
      isPromptInFlight: false,
      configOptions: [modeConfig],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.setSessionMode).mockResolvedValue([
      {
        ...modeConfig,
        currentValue: 'bypassPermissions',
      },
    ] as never);

    await sessionService.startSession('session-1', {
      initialPrompt: '',
      startupModePreset: 'non_interactive',
    });

    expect(acpRuntimeManager.setSessionMode).toHaveBeenCalledWith('session-1', 'bypassPermissions');
    expect(acpRuntimeManager.sendPrompt).not.toHaveBeenCalled();
  });

  it('applies Codex non-interactive startup mode preset using code mode', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-codex',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'gpt-5-codex',
      provider: 'CODEX',
      providerSessionId: null,
    });
    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      hasHadSessions: true,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });
    const modeConfig = {
      id: 'mode',
      name: 'Mode',
      type: 'select',
      category: 'mode',
      currentValue: 'ask',
      options: [
        { value: 'ask', name: 'Ask' },
        { value: 'code', name: 'Code' },
      ],
    };
    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(457),
      provider: 'CODEX',
      providerSessionId: 'provider-codex-1',
      isPromptInFlight: false,
      configOptions: [modeConfig],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.setSessionMode).mockResolvedValue([
      {
        ...modeConfig,
        currentValue: 'code',
      },
    ] as never);

    await sessionService.startSession('session-codex', {
      initialPrompt: '',
      startupModePreset: 'non_interactive',
    });

    expect(acpRuntimeManager.setSessionMode).toHaveBeenCalledWith('session-codex', 'code');
    expect(acpRuntimeManager.sendPrompt).not.toHaveBeenCalled();
  });

  it('injects replayed user_message_chunk events while session is idle', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: 'provider-session-1',
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    const injectUserMessageSpy = vi.spyOn(sessionDomainService, 'injectCommittedUserMessage');
    await sessionService.getOrCreateSessionClient('session-1');

    const acpHandlers = vi.mocked(acpRuntimeManager.getOrCreateClient).mock.calls[0]![2] as {
      onAcpEvent: (id: string, event: unknown) => void;
    };
    acpHandlers.onAcpEvent('session-1', {
      type: 'acp_session_update',
      update: {
        sessionUpdate: 'user_message_chunk',
        content: { type: 'text', text: 'ping' },
      },
    });

    expect(injectUserMessageSpy).toHaveBeenCalledWith('session-1', 'ping');
  });

  it('suppresses replayed user_message_chunk when transcript is already hydrated', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: 'provider-session-1',
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    const historyHydratedSpy = vi
      .spyOn(sessionDomainService, 'isHistoryHydrated')
      .mockReturnValue(true);
    const transcriptSpy = vi.spyOn(sessionDomainService, 'getTranscriptSnapshot').mockReturnValue([
      unsafeCoerce({
        id: 'hist-1',
        source: 'user',
        text: 'already loaded',
        timestamp: '2026-02-14T00:00:00.000Z',
        order: 0,
      }),
    ]);

    try {
      const injectUserMessageSpy = vi.spyOn(sessionDomainService, 'injectCommittedUserMessage');
      await sessionService.getOrCreateSessionClient('session-1');

      const acpHandlers = vi.mocked(acpRuntimeManager.getOrCreateClient).mock.calls[0]![2] as {
        onAcpEvent: (id: string, event: unknown) => void;
      };
      acpHandlers.onAcpEvent('session-1', {
        type: 'acp_session_update',
        update: {
          sessionUpdate: 'user_message_chunk',
          content: { type: 'text', text: 'ping' },
        },
      });

      expect(injectUserMessageSpy).not.toHaveBeenCalled();
    } finally {
      historyHydratedSpy.mockRestore();
      transcriptSpy.mockRestore();
    }
  });

  it('ignores live user_message_chunk events while session is working', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: 'provider-session-1',
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    const injectUserMessageSpy = vi.spyOn(sessionDomainService, 'injectCommittedUserMessage');
    await sessionService.getOrCreateSessionClient('session-1');
    vi.mocked(acpRuntimeManager.isSessionWorking).mockReturnValue(true);

    const acpHandlers = vi.mocked(acpRuntimeManager.getOrCreateClient).mock.calls[0]![2] as {
      onAcpEvent: (id: string, event: unknown) => void;
    };
    acpHandlers.onAcpEvent('session-1', {
      type: 'acp_session_update',
      update: {
        sessionUpdate: 'user_message_chunk',
        content: { type: 'text', text: 'ping' },
      },
    });

    expect(injectUserMessageSpy).not.toHaveBeenCalled();
  });

  it('creates client from preloaded session without re-querying session row', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      hasHadSessions: true,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(777),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    const result = await sessionService.getOrCreateSessionClientFromRecord(session);

    expect(result).toBe(acpHandle);
    expect(sessionRepository.getSessionById).not.toHaveBeenCalled();
    expect(acpRuntimeManager.getOrCreateClient).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        workingDir: '/tmp/work',
        sessionId: 'session-1',
      }),
      expect.any(Object),
      expect.objectContaining({
        workspaceId: 'workspace-1',
        workingDir: '/tmp/work',
      })
    );
  });

  it('skips stop when already stopping', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(true);

    await sessionService.stopSession('session-1');

    expect(acpRuntimeManager.stopClient).not.toHaveBeenCalled();
    expect(sessionRepository.updateSession).not.toHaveBeenCalled();
  });

  it('clears queued work during manual stop', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);
    const clearQueuedWorkSpy = vi.spyOn(sessionDomainService, 'clearQueuedWork');

    await sessionService.stopSession('session-1');

    expect(clearQueuedWorkSpy).toHaveBeenCalledWith('session-1', { emitSnapshot: false });
  });

  it('marks workspace session idle during manual stop', async () => {
    const markSessionIdle = vi.fn();
    sessionService.configure({
      workspace: {
        markSessionRunning: vi.fn(),
        markSessionIdle,
      },
    });
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        workspaceId: 'workspace-1',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);

    await sessionService.stopSession('session-1');

    expect(markSessionIdle).toHaveBeenCalledWith('workspace-1', 'session-1');
  });

  it('still clears queued work and marks idle when runtime stop fails', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockRejectedValue(new Error('stop failed'));
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        workspaceId: 'workspace-1',
        workflow: 'ratchet',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);
    const clearQueuedWorkSpy = vi.spyOn(sessionDomainService, 'clearQueuedWork');

    await sessionService.stopSession('session-1');

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.IDLE,
    });
    expect(clearQueuedWorkSpy).toHaveBeenCalledWith('session-1', { emitSnapshot: false });
    expect(sessionRepository.clearRatchetActiveSession).not.toHaveBeenCalled();
    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('deletes ratchet session record during manual stop', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        workspaceId: 'workspace-1',
        workflow: 'ratchet',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();
    vi.mocked(sessionRepository.deleteSession).mockResolvedValue({} as never);

    await sessionService.stopSession('session-1');

    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-1'
    );
    expect(sessionRepository.deleteSession).toHaveBeenCalledWith('session-1');
  });

  it('does not delete non-ratchet session during manual stop', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-2',
        workspaceId: 'workspace-1',
        workflow: 'default',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);

    await sessionService.stopSession('session-2');

    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('clears ratchet pointer but does not delete session when transient cleanup is disabled', async () => {
    vi.mocked(acpRuntimeManager.isStopInProgress).mockReturnValue(false);
    vi.mocked(acpRuntimeManager.stopClient).mockResolvedValue();
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-3',
        workspaceId: 'workspace-1',
        workflow: 'ratchet',
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue({} as never);

    await sessionService.stopSession('session-3', {
      cleanupTransientRatchetSession: false,
    });

    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-3'
    );
    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('marks process as stopped when ACP client creation fails', async () => {
    const session = {
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    } as unknown as NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>;

    const workspace = {
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    } as unknown as Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>;

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockRejectedValue(new Error('spawn failed'));
    const setRuntimeSnapshotSpy = vi.spyOn(sessionDomainService, 'setRuntimeSnapshot');

    await expect(sessionService.getOrCreateSessionClient('session-1')).rejects.toThrow(
      'spawn failed'
    );

    expect(setRuntimeSnapshotSpy).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        phase: 'starting',
        processState: 'alive',
        activity: 'IDLE',
      })
    );
  });

  it('throws when session not found during client creation', async () => {
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(null);

    await expect(sessionService.getOrCreateSessionClient('session-1')).rejects.toThrow(
      'Session not found: session-1'
    );
  });

  it('returns null session options when workspace is missing', async () => {
    const session = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      providerSessionId: null,
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(null);

    const options = await sessionService.getSessionOptions('session-1');

    expect(options).toBeNull();
  });

  it('clears ratchetActiveSessionId and deletes session on ACP ratchet exit', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'ratchet',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const project = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getProjectById>>>({
      id: 'project-1',
      githubOwner: 'owner',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(456),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.getProjectById).mockResolvedValue(project);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();
    vi.mocked(sessionRepository.deleteSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: 'workflow',
      systemPrompt: 'system',
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-1');

    // Extract the onExit handler from the ACP event handlers passed to acpRuntimeManager
    const acpHandlers = vi.mocked(acpRuntimeManager.getOrCreateClient).mock.calls[0]![2] as {
      onExit: (id: string, exitCode: number | null) => Promise<void>;
    };
    await acpHandlers.onExit('session-1', 0);

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.COMPLETED,
    });
    expect(sessionRepository.clearRatchetActiveSession).toHaveBeenCalledWith(
      'workspace-1',
      'session-1'
    );
    expect(sessionRepository.deleteSession).toHaveBeenCalledWith('session-1');
  });

  it('does not delete session on ACP exit for non-ratchet workflows', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-2',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'fix-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(789),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionRepository.clearRatchetActiveSession).mockResolvedValue();

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-2');

    const acpHandlers = vi.mocked(acpRuntimeManager.getOrCreateClient).mock.calls[0]![2] as {
      onExit: (id: string, exitCode: number | null) => Promise<void>;
    };
    await acpHandlers.onExit('session-2', 0);

    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-2', {
      status: SessionStatus.COMPLETED,
    });
    expect(sessionRepository.deleteSession).not.toHaveBeenCalled();
  });

  it('updates DB status when ACP client is created', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(999),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);

    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });

    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);

    await sessionService.getOrCreateSessionClient('session-1');

    expect(acpRuntimeManager.getOrCreateClient).toHaveBeenCalled();
    expect(sessionRepository.updateSession).toHaveBeenCalledWith('session-1', {
      status: SessionStatus.RUNNING,
    });
  });

  it('returns ACP config options for active session handles', () => {
    const configOptions = [
      {
        id: 'model',
        name: 'Model',
        type: 'string',
        category: 'model',
        currentValue: 'sonnet',
        options: [{ value: 'sonnet', name: 'Sonnet' }],
      },
    ];
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        configOptions,
      })
    );

    expect(sessionService.getSessionConfigOptions('session-1')).toEqual(configOptions);
  });

  it('returns empty config options when no ACP handle is active', () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);

    expect(sessionService.getSessionConfigOptions('session-1')).toEqual([]);
  });

  it('returns cached config options when no ACP handle is active', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        provider: 'CLAUDE',
        providerMetadata: {
          acpConfigSnapshot: {
            provider: 'CLAUDE',
            providerSessionId: 'provider-session-1',
            capturedAt: '2026-02-14T00:00:00.000Z',
            configOptions: [
              {
                id: 'model',
                name: 'Model',
                type: 'select',
                category: 'model',
                currentValue: 'claude-sonnet-4-5',
                options: [{ value: 'claude-sonnet-4-5', name: 'Claude Sonnet 4.5' }],
              },
            ],
          },
        },
      })
    );

    await expect(sessionService.getSessionConfigOptionsWithFallback('session-1')).resolves.toEqual([
      {
        id: 'model',
        name: 'Model',
        type: 'select',
        category: 'model',
        currentValue: 'claude-sonnet-4-5',
        options: [{ value: 'claude-sonnet-4-5', name: 'Claude Sonnet 4.5' }],
      },
    ]);
  });

  it('returns empty Claude capabilities when no ACP handle or cached snapshot exists', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-claude',
        provider: 'CLAUDE',
        model: 'claude-sonnet-4-5',
        providerMetadata: null,
      })
    );

    const capabilities = await sessionService.getChatBarCapabilities('session-claude');

    expect(capabilities.provider).toBe('CLAUDE');
    expect(capabilities.model.enabled).toBe(false);
    expect(capabilities.model.selected).toBeUndefined();
    expect(capabilities.model.options).toEqual([]);
  });

  it('retries persisting ACP config snapshot metadata once when first write fails', async () => {
    const configOptions = unsafeCoerce<import('@agentclientprotocol/sdk').SessionConfigOption[]>([
      {
        id: 'model',
        name: 'Model',
        type: 'select',
        category: 'model',
        currentValue: 'claude-sonnet-4-5',
        options: [{ value: 'claude-sonnet-4-5', name: 'Claude Sonnet 4.5' }],
      },
    ]);
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        provider: 'CLAUDE',
        providerSessionId: 'provider-session-1',
        configOptions,
      })
    );
    vi.mocked(acpRuntimeManager.setSessionModel).mockResolvedValue(configOptions);
    vi.mocked(sessionRepository.updateSession)
      .mockRejectedValueOnce(new Error('primary metadata write failed'))
      .mockResolvedValueOnce(unsafeCoerce({ id: 'session-1' }));
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        providerMetadata: { existing: 'metadata' },
      })
    );

    await sessionService.setSessionConfigOption('session-1', 'model', 'claude-sonnet-4-5');

    const metadataUpdates = vi
      .mocked(sessionRepository.updateSession)
      .mock.calls.filter(([, update]) => Object.hasOwn(update, 'providerMetadata'));
    expect(metadataUpdates).toHaveLength(2);
    expect(metadataUpdates[1]?.[1]).toMatchObject({
      model: 'claude-sonnet-4-5',
      providerMetadata: expect.objectContaining({
        existing: 'metadata',
        acpConfigSnapshot: expect.any(Object),
      }),
    });
  });

  it('returns CODEX provider fallback capabilities when no ACP handle is active', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-codex',
        provider: 'CODEX',
      })
    );

    const capabilities = await sessionService.getChatBarCapabilities('session-codex');

    expect(capabilities.provider).toBe('CODEX');
    expect(capabilities.model.enabled).toBe(false);
  });

  it('derives CODEX model/reasoning/plan-mode capabilities from cached ACP config options', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-codex',
        provider: 'CODEX',
        providerMetadata: {
          acpConfigSnapshot: {
            provider: 'CODEX',
            providerSessionId: 'sess_123',
            capturedAt: '2026-02-15T00:00:00.000Z',
            configOptions: [
              {
                id: 'model',
                name: 'Model',
                type: 'select',
                category: 'model',
                currentValue: 'gpt-5-codex',
                options: [
                  { value: 'gpt-5-codex', name: 'GPT-5 Codex' },
                  { value: 'gpt-5-mini', name: 'GPT-5 Mini' },
                ],
              },
              {
                id: 'mode',
                name: 'Mode',
                type: 'select',
                category: 'mode',
                currentValue: 'plan',
                options: [
                  { value: 'ask', name: 'Ask' },
                  { value: 'plan', name: 'Plan' },
                ],
              },
              {
                id: 'reasoning_effort',
                name: 'Reasoning Effort',
                type: 'select',
                category: 'thought_level',
                currentValue: 'high',
                options: [
                  { value: 'medium', name: 'Medium', description: 'Balanced' },
                  { value: 'high', name: 'High', description: 'Thorough' },
                ],
              },
            ],
          },
        },
      })
    );

    const capabilities = await sessionService.getChatBarCapabilities('session-codex');

    expect(capabilities.provider).toBe('CODEX');
    expect(capabilities.model.options).toEqual([
      { value: 'gpt-5-codex', label: 'GPT-5 Codex' },
      { value: 'gpt-5-mini', label: 'GPT-5 Mini' },
    ]);
    expect(capabilities.reasoning.enabled).toBe(true);
    expect(capabilities.reasoning.options).toEqual([
      { value: 'medium', label: 'Medium', description: 'Balanced' },
      { value: 'high', label: 'High', description: 'Thorough' },
    ]);
    expect(capabilities.reasoning.selected).toBe('high');
    expect(capabilities.planMode.enabled).toBe(true);
    expect(capabilities.thinking.enabled).toBe(false);
  });

  it('disables plan mode when ACP config options do not advertise a plan variant', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-codex',
        provider: 'CODEX',
        providerMetadata: {
          acpConfigSnapshot: {
            provider: 'CODEX',
            providerSessionId: 'sess_124',
            capturedAt: '2026-02-15T00:00:00.000Z',
            configOptions: [
              {
                id: 'mode',
                name: 'Approval Policy',
                type: 'select',
                category: 'mode',
                currentValue: 'on-failure',
                options: [{ value: 'on-failure', name: 'On Failure' }],
              },
            ],
          },
        },
      })
    );

    const capabilities = await sessionService.getChatBarCapabilities('session-codex');

    expect(capabilities.planMode.enabled).toBe(false);
  });

  it('skips setSessionModel when requested model is not in ACP model options', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        provider: 'CODEX',
        configOptions: [
          {
            id: 'model',
            name: 'Model',
            type: 'select',
            category: 'model',
            currentValue: 'gpt-5.3-codex',
            options: [
              { value: 'gpt-5.3-codex', name: 'GPT-5.3 Codex' },
              { value: 'gpt-5.2-codex', name: 'GPT-5.2 Codex' },
            ],
          },
        ],
      })
    );

    await sessionService.setSessionModel('session-codex', 'opus');

    expect(acpRuntimeManager.setConfigOption).not.toHaveBeenCalled();
  });

  it('applies setSessionModel when requested model is supported by ACP options', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        provider: 'CODEX',
        configOptions: [
          {
            id: 'model',
            name: 'Model',
            type: 'select',
            category: 'model',
            currentValue: 'gpt-5.3-codex',
            options: [
              { value: 'gpt-5.3-codex', name: 'GPT-5.3 Codex' },
              { value: 'gpt-5.2-codex', name: 'GPT-5.2 Codex' },
            ],
          },
        ],
      })
    );
    vi.mocked(acpRuntimeManager.setSessionModel).mockResolvedValue([
      {
        id: 'model',
        name: 'Model',
        type: 'select',
        category: 'model',
        currentValue: 'gpt-5.2-codex',
        options: [{ value: 'gpt-5.2-codex', name: 'GPT-5.2 Codex' }],
      },
    ] as never);

    await sessionService.setSessionModel('session-codex', 'gpt-5.2-codex');

    expect(acpRuntimeManager.setSessionModel).toHaveBeenCalledWith(
      'session-codex',
      'gpt-5.2-codex'
    );
    expect(acpRuntimeManager.setConfigOption).not.toHaveBeenCalled();
  });

  it('routes mode config updates through ACP setSessionMode', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        provider: 'CLAUDE',
        configOptions: [
          {
            id: 'mode',
            name: 'Mode',
            type: 'select',
            category: 'mode',
            currentValue: 'default',
            options: [
              { value: 'default', name: 'Default' },
              { value: 'acceptEdits', name: 'Accept Edits' },
            ],
          },
        ],
      })
    );
    vi.mocked(acpRuntimeManager.setSessionMode).mockResolvedValue([
      {
        id: 'mode',
        name: 'Mode',
        type: 'select',
        category: 'mode',
        currentValue: 'acceptEdits',
        options: [
          { value: 'default', name: 'Default' },
          { value: 'acceptEdits', name: 'Accept Edits' },
        ],
      },
    ] as never);

    await sessionService.setSessionConfigOption('session-1', 'mode', 'acceptEdits');

    expect(acpRuntimeManager.setSessionMode).toHaveBeenCalledWith('session-1', 'acceptEdits');
    expect(acpRuntimeManager.setConfigOption).not.toHaveBeenCalled();
  });

  it('routes model config updates through ACP setSessionModel', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce({
        provider: 'CLAUDE',
        configOptions: [
          {
            id: 'model',
            name: 'Model',
            type: 'select',
            category: 'model',
            currentValue: 'default',
            options: [
              { value: 'default', name: 'Default' },
              { value: 'claude-sonnet-4-5', name: 'Sonnet 4.5' },
            ],
          },
        ],
      })
    );
    vi.mocked(acpRuntimeManager.setSessionModel).mockResolvedValue([
      {
        id: 'model',
        name: 'Model',
        type: 'select',
        category: 'model',
        currentValue: 'claude-sonnet-4-5',
        options: [
          { value: 'default', name: 'Default' },
          { value: 'claude-sonnet-4-5', name: 'Sonnet 4.5' },
        ],
      },
    ] as never);

    await sessionService.setSessionConfigOption('session-1', 'model', 'claude-sonnet-4-5');

    expect(acpRuntimeManager.setSessionModel).toHaveBeenCalledWith(
      'session-1',
      'claude-sonnet-4-5'
    );
    expect(acpRuntimeManager.setConfigOption).not.toHaveBeenCalled();
  });

  it('updates cached config snapshot when setting config on inactive session', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        provider: 'CODEX',
        providerMetadata: {
          acpConfigSnapshot: {
            provider: 'CODEX',
            providerSessionId: 'thread_123',
            capturedAt: '2026-02-15T00:00:00.000Z',
            configOptions: [
              {
                id: 'execution_mode',
                name: 'Execution Mode',
                type: 'select',
                category: 'permission',
                currentValue: '["on-request","workspace-write"]',
                options: [
                  {
                    value: '["on-request","workspace-write"]',
                    name: 'on-request + workspace-write',
                  },
                  {
                    value: '["on-failure","workspace-write"]',
                    name: 'on-failure + workspace-write',
                  },
                ],
              },
            ],
          },
        },
      })
    );
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(unsafeCoerce({ id: 'session-1' }));
    const emitDeltaSpy = vi.spyOn(sessionDomainService, 'emitDelta');

    await sessionService.setSessionConfigOption(
      'session-1',
      'execution_mode',
      '["on-failure","workspace-write"]'
    );

    expect(acpRuntimeManager.setConfigOption).not.toHaveBeenCalled();
    expect(acpRuntimeManager.setSessionMode).not.toHaveBeenCalled();
    expect(acpRuntimeManager.setSessionModel).not.toHaveBeenCalled();
    expect(sessionRepository.updateSession).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        providerMetadata: expect.objectContaining({
          acpConfigSnapshot: expect.objectContaining({
            configOptions: expect.arrayContaining([
              expect.objectContaining({
                id: 'execution_mode',
                currentValue: '["on-failure","workspace-write"]',
              }),
            ]),
          }),
        }),
      })
    );
    expect(emitDeltaSpy).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        type: 'config_options_update',
        configOptions: expect.arrayContaining([
          expect.objectContaining({
            id: 'execution_mode',
            currentValue: '["on-failure","workspace-write"]',
          }),
        ]),
      })
    );
  });

  it('rejects unsupported cached config values on inactive session', async () => {
    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(undefined);
    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(
      unsafeCoerce({
        id: 'session-1',
        provider: 'CODEX',
        providerMetadata: {
          acpConfigSnapshot: {
            provider: 'CODEX',
            providerSessionId: 'thread_123',
            capturedAt: '2026-02-15T00:00:00.000Z',
            configOptions: [
              {
                id: 'execution_mode',
                name: 'Execution Mode',
                type: 'select',
                category: 'permission',
                currentValue: '["on-request","workspace-write"]',
                options: [
                  {
                    value: '["on-request","workspace-write"]',
                    name: 'on-request + workspace-write',
                  },
                ],
              },
            ],
          },
        },
      })
    );

    await expect(
      sessionService.setSessionConfigOption(
        'session-1',
        'execution_mode',
        '["never","danger-full-access"]'
      )
    ).rejects.toThrow('Unsupported value');
    expect(sessionRepository.updateSession).not.toHaveBeenCalled();
    expect(acpRuntimeManager.setConfigOption).not.toHaveBeenCalled();
  });

  it('finalizes orphaned ACP tool calls when prompt ends without terminal updates', async () => {
    const pendingToolCalls = (
      sessionService as unknown as {
        pendingAcpToolCalls: Map<
          string,
          Map<
            string,
            {
              toolUseId: string;
              toolName: string;
              acpKind?: string;
              acpLocations?: Array<{ path: string; line?: number | null }>;
            }
          >
        >;
      }
    ).pendingAcpToolCalls;

    vi.mocked(acpRuntimeManager.sendPrompt).mockImplementation(() => {
      pendingToolCalls.set(
        'session-1',
        new Map([
          [
            'call-1',
            {
              toolUseId: 'call-1',
              toolName: 'Run pwd',
              acpKind: 'execute',
            },
          ],
        ])
      );
      return Promise.resolve({ stopReason: 'end_turn' } as never);
    });

    const emitDeltaSpy = vi.spyOn(sessionDomainService, 'emitDelta');
    const appendClaudeEventSpy = vi
      .spyOn(sessionDomainService, 'appendClaudeEvent')
      .mockReturnValue(77);

    await sessionService.sendAcpMessage('session-1', 'hello');

    expect(emitDeltaSpy).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        type: 'tool_progress',
        tool_use_id: 'call-1',
        tool_name: 'Run pwd',
        elapsed_time_seconds: 0,
      })
    );
    expect(appendClaudeEventSpy).toHaveBeenCalledWith(
      'session-1',
      expect.objectContaining({
        type: 'user',
        message: expect.objectContaining({
          content: [
            expect.objectContaining({
              type: 'tool_result',
              tool_use_id: 'call-1',
              is_error: true,
            }),
          ],
        }),
      })
    );
    expect(pendingToolCalls.has('session-1')).toBe(false);
  });

  it('does not synthesize tool call completion when no ACP tool calls are pending', async () => {
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' } as never);
    const appendClaudeEventSpy = vi.spyOn(sessionDomainService, 'appendClaudeEvent');

    await sessionService.sendAcpMessage('session-1', 'hello');

    expect(appendClaudeEventSpy).not.toHaveBeenCalled();
  });

  it('schedules prompt-turn completion callbacks after ACP prompt settles', async () => {
    vi.useFakeTimers();
    try {
      const onPromptTurnComplete = vi.fn().mockResolvedValue(undefined);
      sessionService.setPromptTurnCompleteHandler(onPromptTurnComplete);
      vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({
        stopReason: 'end_turn',
      } as never);

      await sessionService.sendAcpMessage('session-1', 'hello');

      expect(onPromptTurnComplete).not.toHaveBeenCalled();
      await vi.runOnlyPendingTimersAsync();
      expect(onPromptTurnComplete).toHaveBeenCalledWith('session-1');
    } finally {
      vi.useRealTimers();
    }
  });

  it('swallows prompt-turn completion callback failures', async () => {
    vi.useFakeTimers();
    try {
      const onPromptTurnComplete = vi.fn().mockRejectedValue(new Error('dispatch failed'));
      sessionService.setPromptTurnCompleteHandler(onPromptTurnComplete);
      vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({
        stopReason: 'end_turn',
      } as never);

      await expect(sessionService.sendAcpMessage('session-1', 'hello')).resolves.toBe('end_turn');
      await vi.runOnlyPendingTimersAsync();
      expect(onPromptTurnComplete).toHaveBeenCalledWith('session-1');
    } finally {
      vi.useRealTimers();
    }
  });

  it('avoids redundant session DB lookups during startSession', async () => {
    const session = unsafeCoerce<
      NonNullable<Awaited<ReturnType<typeof sessionRepository.getSessionById>>>
    >({
      id: 'session-1',
      workspaceId: 'workspace-1',
      status: SessionStatus.IDLE,
      workflow: 'default',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerSessionId: null,
    });

    const workspace = unsafeCoerce<Awaited<ReturnType<typeof sessionRepository.getWorkspaceById>>>({
      id: 'workspace-1',
      worktreePath: '/tmp/work',
      branchName: 'feature-branch',
      isAutoGeneratedBranch: false,
      hasHadSessions: true,
      name: 'Workspace A',
      description: null,
      projectId: 'project-1',
    });

    const acpHandle = unsafeCoerce<AcpProcessHandle>({
      getPid: vi.fn().mockReturnValue(111),
      isPromptInFlight: false,
      configOptions: [],
    });

    vi.mocked(sessionRepository.getSessionById).mockResolvedValue(session);
    vi.mocked(sessionRepository.getWorkspaceById).mockResolvedValue(workspace);
    vi.mocked(sessionRepository.markWorkspaceHasHadSessions).mockResolvedValue();
    vi.mocked(sessionRepository.updateSession).mockResolvedValue(session);
    vi.mocked(sessionPromptBuilder.shouldInjectBranchRename).mockReturnValue(false);
    vi.mocked(sessionPromptBuilder.buildSystemPrompt).mockReturnValue({
      workflowPrompt: undefined,
      systemPrompt: undefined,
      injectedBranchRename: false,
    });
    vi.mocked(acpRuntimeManager.getOrCreateClient).mockResolvedValue(acpHandle);
    vi.mocked(acpRuntimeManager.sendPrompt).mockResolvedValue({ stopReason: 'end_turn' });

    await sessionService.startSession('session-1', { initialPrompt: 'go' });

    // startSession loads session once and passes to getOrCreateAcpSessionClient(session)
    // which passes to createAcpClient(session) -> loadSessionContext(preloadedSession)
    // Total: 1 call (session is passed through, no redundant DB lookup)
    expect(sessionRepository.getSessionById).toHaveBeenCalledTimes(1);
  });

  it('normalizes stale loading runtime to idle when no process is active', () => {
    vi.spyOn(sessionDomainService, 'getRuntimeSnapshot').mockReturnValue({
      phase: 'loading',
      processState: 'unknown',
      activity: 'IDLE',
      updatedAt: new Date('2026-02-10T01:45:35.844Z').toISOString(),
    });

    const runtime = sessionService.getRuntimeSnapshot('session-1');

    expect(runtime).toMatchObject({
      phase: 'idle',
      processState: 'stopped',
      activity: 'IDLE',
    });
  });

  it('keeps recent loading runtime when no process is active', () => {
    vi.spyOn(sessionDomainService, 'getRuntimeSnapshot').mockReturnValue({
      phase: 'loading',
      processState: 'unknown',
      activity: 'IDLE',
      updatedAt: new Date().toISOString(),
    });

    const runtime = sessionService.getRuntimeSnapshot('session-1');

    expect(runtime).toMatchObject({
      phase: 'loading',
      processState: 'unknown',
      activity: 'IDLE',
    });
  });

  it('keeps updatedAt stable while ACP client remains in same runtime state', () => {
    const updatedAt = '2026-02-10T01:45:35.844Z';
    vi.spyOn(sessionDomainService, 'getRuntimeSnapshot').mockReturnValue({
      phase: 'idle',
      processState: 'alive',
      activity: 'IDLE',
      updatedAt,
    });

    vi.mocked(acpRuntimeManager.getClient).mockReturnValue(
      unsafeCoerce<AcpProcessHandle>({
        isPromptInFlight: false,
        configOptions: [],
      })
    );
    vi.mocked(acpRuntimeManager.isSessionWorking).mockReturnValue(false);

    const runtime = sessionService.getRuntimeSnapshot('session-1');

    expect(runtime).toEqual({
      phase: 'idle',
      processState: 'alive',
      activity: 'IDLE',
      updatedAt,
    });
  });

  it('stops all ACP clients during shutdown', async () => {
    vi.mocked(acpRuntimeManager.stopAllClients).mockResolvedValue(undefined);

    await sessionService.stopAllClients(4321);

    expect(acpRuntimeManager.stopAllClients).toHaveBeenCalledTimes(1);
  });

  it('propagates ACP shutdown failure', async () => {
    vi.mocked(acpRuntimeManager.stopAllClients).mockRejectedValueOnce(
      new Error('acp shutdown failed')
    );

    await expect(sessionService.stopAllClients()).rejects.toThrow('acp shutdown failed');
  });
});

import type { UserSettings, Workspace } from '@prisma-gen/client';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import * as worktreeLifecycleServiceModule from '@/backend/domains/workspace/worktree/worktree-lifecycle.service';
import * as claudeSessionAccessorModule from '@/backend/resource_accessors/claude-session.accessor';
import * as projectAccessorModule from '@/backend/resource_accessors/project.accessor';
import * as userSettingsAccessorModule from '@/backend/resource_accessors/user-settings.accessor';
import * as workspaceAccessorModule from '@/backend/resource_accessors/workspace.accessor';
import type { configService } from '@/backend/services/config.service';
import * as gitOpsServiceModule from '@/backend/services/git-ops.service';
import type { createLogger } from '@/backend/services/logger.service';
import { unsafeCoerce } from '@/test-utils/unsafe-coerce';
import { WorkspaceCreationService, type WorkspaceCreationSource } from './creation.service';

type ConfigService = typeof configService;
type Logger = ReturnType<typeof createLogger>;

// Mock dependencies
vi.mock('@/backend/resource_accessors/workspace.accessor');
vi.mock('@/backend/resource_accessors/project.accessor');
vi.mock('@/backend/resource_accessors/user-settings.accessor');
vi.mock('@/backend/resource_accessors/claude-session.accessor');
vi.mock('@/backend/services/git-ops.service');
vi.mock('@/backend/domains/workspace/worktree/worktree-lifecycle.service');

describe('WorkspaceCreationService', () => {
  let service: WorkspaceCreationService;
  let mockLogger: Logger;
  let mockConfigService: ConfigService;

  const mockWorkspace: Workspace = {
    id: 'ws-123',
    projectId: 'proj-1',
    name: 'Test Workspace',
    description: null,
    status: 'NEW',
    branchName: null,
    worktreePath: null,
    isAutoGeneratedBranch: false,
    creationSource: 'MANUAL',
    creationMetadata: null,
    prUrl: null,
    githubIssueNumber: null,
    githubIssueUrl: null,
    defaultSessionProvider: 'WORKSPACE_DEFAULT',
    ratchetSessionProvider: 'WORKSPACE_DEFAULT',
    prNumber: null,
    prState: 'NONE',
    prReviewState: null,
    prCiStatus: 'UNKNOWN',
    prUpdatedAt: null,
    prCiFailedAt: null,
    prCiLastNotifiedAt: null,
    prReviewLastCheckedAt: null,
    prReviewLastCommentId: null,
    ratchetEnabled: true,
    ratchetState: 'IDLE',
    ratchetLastCheckedAt: null,
    ratchetLastPushAt: null,
    ratchetActiveSessionId: null,
    ratchetLastCiRunId: null,
    ratchetLastNotifiedState: null,
    hasHadSessions: false,
    cachedKanbanColumn: 'WAITING',
    stateComputedAt: null,
    initErrorMessage: null,
    initOutput: null,
    initStartedAt: null,
    initCompletedAt: null,
    initRetryCount: 0,
    runScriptCommand: null,
    runScriptCleanupCommand: null,
    runScriptPid: null,
    runScriptPort: null,
    runScriptStartedAt: null,
    runScriptStatus: 'IDLE',
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const mockProject = {
    id: 'proj-1',
    name: 'Test Project',
    slug: 'test-project',
    repoPath: '/path/to/repo',
    worktreeBasePath: '/path/to/worktrees',
    defaultBranch: 'main',
    githubOwner: null,
    githubRepo: null,
    isArchived: false,
    startupScriptCommand: null,
    startupScriptPath: null,
    startupScriptTimeout: 300,
    createdAt: new Date(),
    updatedAt: new Date(),
    workspaces: [],
  };

  beforeEach(() => {
    vi.clearAllMocks();

    mockLogger = unsafeCoerce<Logger>({
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      debug: vi.fn(),
    });

    mockConfigService = unsafeCoerce<ConfigService>({
      getMaxSessionsPerWorkspace: vi.fn().mockReturnValue(5),
    });

    service = new WorkspaceCreationService({
      logger: mockLogger,
      configService: mockConfigService,
    });

    // Default mocks
    const mockUserSettings: UserSettings = {
      id: '1',
      userId: 'default',
      preferredIde: 'cursor',
      customIdeCommand: '',
      playSoundOnComplete: true,
      notificationSoundPath: null,
      workspaceOrder: null,
      cachedSlashCommands: null,
      ratchetEnabled: true,
      defaultSessionProvider: 'CLAUDE',
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    vi.spyOn(userSettingsAccessorModule.userSettingsAccessor, 'get').mockResolvedValue(
      mockUserSettings
    );
    vi.spyOn(
      userSettingsAccessorModule.userSettingsAccessor,
      'getDefaultSessionProvider'
    ).mockResolvedValue('CLAUDE');

    vi.spyOn(workspaceAccessorModule.workspaceAccessor, 'create').mockResolvedValue(mockWorkspace);

    vi.spyOn(claudeSessionAccessorModule.claudeSessionAccessor, 'create').mockResolvedValue({
      id: 'session-1',
      workspaceId: 'ws-123',
      workflow: 'feature',
      name: 'Chat 1',
      status: 'IDLE',
      model: 'sonnet',
      provider: 'CLAUDE',
      providerMetadata: null,
      claudeSessionId: null,
      claudeProjectPath: null,
      claudeProcessPid: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    vi.spyOn(
      worktreeLifecycleServiceModule.worktreeLifecycleService,
      'setInitMode'
    ).mockResolvedValue();
  });

  describe('create', () => {
    describe('MANUAL source', () => {
      it('should create workspace with manual source', async () => {
        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'My Workspace',
          description: 'A test workspace',
          branchName: 'feature/test',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(result.defaultSessionCreated).toBe(true);
        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith({
          projectId: 'proj-1',
          name: 'My Workspace',
          description: 'A test workspace',
          branchName: 'feature/test',
          creationSource: 'MANUAL',
          ratchetEnabled: true,
        });
      });

      it('should use explicit ratchetEnabled value', async () => {
        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'My Workspace',
          ratchetEnabled: false,
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            ratchetEnabled: false,
          })
        );
        expect(userSettingsAccessorModule.userSettingsAccessor.get).not.toHaveBeenCalled();
        expect(
          userSettingsAccessorModule.userSettingsAccessor.getDefaultSessionProvider
        ).toHaveBeenCalled();
      });

      it('should default to user settings ratchetEnabled when not provided', async () => {
        const disabledSettings: UserSettings = {
          id: '1',
          userId: 'default',
          preferredIde: 'cursor',
          customIdeCommand: '',
          playSoundOnComplete: true,
          notificationSoundPath: null,
          workspaceOrder: null,
          cachedSlashCommands: null,
          ratchetEnabled: false,
          defaultSessionProvider: 'CLAUDE',
          createdAt: new Date(),
          updatedAt: new Date(),
        };
        vi.spyOn(userSettingsAccessorModule.userSettingsAccessor, 'get').mockResolvedValue(
          disabledSettings
        );

        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'My Workspace',
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            ratchetEnabled: false,
          })
        );
      });

      it('fetches user settings once when ratchetEnabled is implicit', async () => {
        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'My Workspace',
        };

        await service.create(source);

        expect(userSettingsAccessorModule.userSettingsAccessor.get).toHaveBeenCalledTimes(1);
        expect(
          userSettingsAccessorModule.userSettingsAccessor.getDefaultSessionProvider
        ).not.toHaveBeenCalled();
      });
    });

    describe('RESUME_BRANCH source', () => {
      beforeEach(() => {
        vi.spyOn(projectAccessorModule.projectAccessor, 'findById').mockResolvedValue(mockProject);
        vi.spyOn(gitOpsServiceModule.gitOpsService, 'isBranchCheckedOut').mockResolvedValue(false);
      });

      it('should create workspace from resume branch source', async () => {
        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'existing-branch',
          name: 'Resumed Workspace',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(projectAccessorModule.projectAccessor.findById).toHaveBeenCalledWith('proj-1');
        expect(gitOpsServiceModule.gitOpsService.isBranchCheckedOut).toHaveBeenCalledWith(
          mockProject,
          'existing-branch'
        );
        expect(
          worktreeLifecycleServiceModule.worktreeLifecycleService.setInitMode
        ).toHaveBeenCalledWith('ws-123', true, '/path/to/worktrees');
      });

      it('should use branch name as workspace name when name not provided', async () => {
        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'my-feature-branch',
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            name: 'my-feature-branch',
          })
        );
      });

      it('should throw error when project not found', async () => {
        vi.spyOn(projectAccessorModule.projectAccessor, 'findById').mockResolvedValue(null);

        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'existing-branch',
        };

        await expect(service.create(source)).rejects.toThrow('Project not found: proj-1');
      });

      it('should throw error when branch is already checked out', async () => {
        vi.spyOn(gitOpsServiceModule.gitOpsService, 'isBranchCheckedOut').mockResolvedValue(true);

        const source: WorkspaceCreationSource = {
          type: 'RESUME_BRANCH',
          projectId: 'proj-1',
          branchName: 'existing-branch',
        };

        await expect(service.create(source)).rejects.toThrow(
          "Branch 'existing-branch' is already checked out in another worktree."
        );
      });
    });

    describe('GITHUB_ISSUE source', () => {
      it('should create workspace from GitHub issue source', async () => {
        const source: WorkspaceCreationSource = {
          type: 'GITHUB_ISSUE',
          projectId: 'proj-1',
          issueNumber: 42,
          issueUrl: 'https://github.com/org/repo/issues/42',
          name: 'Fix bug #42',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith({
          projectId: 'proj-1',
          name: 'Fix bug #42',
          githubIssueNumber: 42,
          githubIssueUrl: 'https://github.com/org/repo/issues/42',
          creationSource: 'GITHUB_ISSUE',
          creationMetadata: {
            issueNumber: 42,
            issueUrl: 'https://github.com/org/repo/issues/42',
          },
          ratchetEnabled: true,
        });
      });

      it('should generate default name from issue number when name not provided', async () => {
        const source: WorkspaceCreationSource = {
          type: 'GITHUB_ISSUE',
          projectId: 'proj-1',
          issueNumber: 42,
          issueUrl: 'https://github.com/org/repo/issues/42',
        };

        await service.create(source);

        expect(workspaceAccessorModule.workspaceAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            name: 'Issue #42',
          })
        );
      });
    });

    describe('default session provisioning', () => {
      it('should create default session when max sessions > 0', async () => {
        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'Test',
        };

        const result = await service.create(source);

        expect(result.defaultSessionCreated).toBe(true);
        expect(claudeSessionAccessorModule.claudeSessionAccessor.create).toHaveBeenCalledWith({
          workspaceId: 'ws-123',
          workflow: 'followup',
          name: 'Chat 1',
          provider: 'CLAUDE',
          claudeProjectPath: null,
        });
      });

      it('should not create default session when max sessions is 0', async () => {
        vi.mocked(mockConfigService.getMaxSessionsPerWorkspace).mockReturnValue(0);

        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'Test',
        };

        const result = await service.create(source);

        expect(result.defaultSessionCreated).toBe(false);
        expect(claudeSessionAccessorModule.claudeSessionAccessor.create).not.toHaveBeenCalled();
      });

      it('should handle default session creation failure gracefully', async () => {
        vi.spyOn(claudeSessionAccessorModule.claudeSessionAccessor, 'create').mockRejectedValue(
          new Error('Session creation failed')
        );

        const source: WorkspaceCreationSource = {
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'Test',
        };

        const result = await service.create(source);

        expect(result.workspace).toEqual(mockWorkspace);
        expect(result.defaultSessionCreated).toBe(false);
        expect(mockLogger.warn).toHaveBeenCalledWith(
          'Failed to create default session for workspace',
          expect.objectContaining({
            workspaceId: 'ws-123',
          })
        );
      });

      it('uses user default provider when creating the default session', async () => {
        vi.spyOn(userSettingsAccessorModule.userSettingsAccessor, 'get').mockResolvedValue({
          id: '1',
          userId: 'default',
          preferredIde: 'cursor',
          customIdeCommand: '',
          playSoundOnComplete: true,
          notificationSoundPath: null,
          workspaceOrder: null,
          cachedSlashCommands: null,
          ratchetEnabled: true,
          defaultSessionProvider: 'CODEX',
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        await service.create({
          type: 'MANUAL',
          projectId: 'proj-1',
          name: 'Test',
        });

        expect(claudeSessionAccessorModule.claudeSessionAccessor.create).toHaveBeenCalledWith(
          expect.objectContaining({
            provider: 'CODEX',
            claudeProjectPath: null,
          })
        );
      });
    });
  });
});

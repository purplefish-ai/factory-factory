import * as crypto from 'node:crypto';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { gitCommand, gitCommandC } from '../lib/shell';

/**
 * Check if a branch name matches the auto-generated pattern.
 * Auto-generated branches have format: {prefix}/{6-hex-chars} or just {6-hex-chars}
 * The prefix can contain multiple segments (e.g., "user-name/feature/abc123").
 */
export function isAutoGeneratedBranchName(branchName: string): boolean {
  const hexOnly = /^[a-f0-9]{6}$/;
  const prefixedHex = /^.+\/[a-f0-9]{6}$/;
  return hexOnly.test(branchName) || prefixedHex.test(branchName);
}

export interface GitWorktreeInfo {
  name: string;
  path: string;
  branchName: string;
}

export interface CreateWorktreeOptions {
  /** GitHub username or org for branch prefix (e.g., 'martin-purplefish') */
  branchPrefix?: string;
  /** Workspace name to use for branch (e.g., 'tiger' -> 'martin-purplefish/tiger') */
  workspaceName?: string;
}

export interface GitClientConfig {
  baseRepoPath: string;
  worktreeBase: string;
}

export class GitClient {
  private baseRepoPath: string;
  private worktreeBase: string;

  constructor(config: GitClientConfig) {
    if (!config.baseRepoPath) {
      throw new Error('baseRepoPath is required');
    }
    if (!config.worktreeBase) {
      throw new Error('worktreeBase is required');
    }

    this.baseRepoPath = config.baseRepoPath;
    this.worktreeBase = config.worktreeBase;
  }

  async createWorktree(
    name: string,
    baseBranch = 'main',
    options: CreateWorktreeOptions = {}
  ): Promise<GitWorktreeInfo> {
    const worktreePath = this.getWorktreePath(name);
    const branchName = await this.generateUniqueBranchName(
      options.branchPrefix,
      options.workspaceName
    );

    await fs.mkdir(this.worktreeBase, { recursive: true });

    // Normalize baseBranch: strip 'origin/' prefix if present since we'll add it back
    // This handles cases where callers pass 'origin/main' instead of 'main'
    const localBranchName = baseBranch.startsWith('origin/')
      ? baseBranch.slice('origin/'.length)
      : baseBranch;

    // Fetch the latest from origin to ensure we branch from the most recent commit
    // Non-fatal: if fetch fails (e.g., offline), we fall back to available refs
    const fetchResult = await gitCommandC(this.baseRepoPath, ['fetch', 'origin', localBranchName]);
    const fetchSucceeded = fetchResult.code === 0;

    // Determine which base branch to use, preferring fresh origin refs
    const originBranch = `origin/${localBranchName}`;
    const originExists = await this.branchExists(originBranch);
    const localExists = await this.branchExists(localBranchName);

    // Priority: fresh origin (fetch succeeded) > local > stale origin (fetch failed)
    let actualBaseBranch: string;
    if (fetchSucceeded && originExists) {
      // Best case: use freshly fetched origin
      actualBaseBranch = originBranch;
    } else if (localExists) {
      // Fallback to local branch
      actualBaseBranch = localBranchName;
    } else if (originExists) {
      // Last resort: use stale origin ref (fetch failed but ref exists from previous fetch)
      actualBaseBranch = originBranch;
    } else {
      // Neither exists - let git worktree fail with a clear error
      actualBaseBranch = localBranchName;
    }

    const result = await gitCommandC(this.baseRepoPath, [
      'worktree',
      'add',
      '-b',
      branchName,
      worktreePath,
      actualBaseBranch,
    ]);
    if (result.code !== 0) {
      throw new Error(`Failed to create worktree: ${result.stderr || result.stdout}`);
    }

    return {
      name,
      path: worktreePath,
      branchName,
    };
  }

  /**
   * Check if a branch exists in the repository
   */
  async branchExists(branchName: string): Promise<boolean> {
    const result = await gitCommandC(this.baseRepoPath, ['rev-parse', '--verify', branchName]);
    return result.code === 0;
  }

  async deleteWorktree(name: string): Promise<void> {
    const worktreePath = this.getWorktreePath(name);

    const result = await gitCommandC(this.baseRepoPath, [
      'worktree',
      'remove',
      worktreePath,
      '--force',
    ]);
    if (result.code !== 0) {
      throw new Error(`Failed to delete worktree: ${result.stderr || result.stdout}`);
    }
  }

  getWorktreePath(name: string): string {
    return path.join(this.worktreeBase, name);
  }

  /**
   * Generate a branch name with optional prefix.
   * Format: {prefix}/{workspaceName} or just {workspaceName}
   * If no workspaceName, falls back to random hex for uniqueness.
   * Example: martin-purplefish/flux-1
   */
  generateBranchName(prefix?: string, workspaceName?: string): string {
    const suffix = workspaceName ?? crypto.randomBytes(3).toString('hex');
    return prefix ? `${prefix}/${suffix}` : suffix;
  }

  /**
   * Generate a unique branch name that doesn't conflict with existing branches.
   * If the generated name already exists, appends -1, -2, -3, etc. until finding an available name.
   * Example: martin-purplefish/jaguar -> martin-purplefish/jaguar-1
   */
  async generateUniqueBranchName(prefix?: string, workspaceName?: string): Promise<string> {
    const baseName = this.generateBranchName(prefix, workspaceName);

    // Check if base name is available
    const baseExists = await this.branchExists(baseName);
    if (!baseExists) {
      return baseName;
    }

    // Try numbered suffixes until we find an available name
    let counter = 1;
    while (counter < 1000) {
      // Safety limit to prevent infinite loops
      const numberedName = `${baseName}-${counter}`;
      const exists = await this.branchExists(numberedName);
      if (!exists) {
        return numberedName;
      }
      counter++;
    }

    // Fallback to random hex if we somehow hit the limit
    return this.generateBranchName(prefix, crypto.randomBytes(6).toString('hex'));
  }

  async checkWorktreeExists(name: string): Promise<boolean> {
    const worktreePath = this.getWorktreePath(name);
    const result = await gitCommandC(this.baseRepoPath, ['worktree', 'list']);
    if (result.code !== 0) {
      return false;
    }
    return result.stdout.includes(worktreePath);
  }

  async listWorktrees(): Promise<string[]> {
    const result = await gitCommandC(this.baseRepoPath, ['worktree', 'list', '--porcelain']);
    if (result.code !== 0) {
      throw new Error(`Failed to list worktrees: ${result.stderr || result.stdout}`);
    }

    const worktrees: string[] = [];
    const lines = result.stdout.split('\n');

    for (const line of lines) {
      if (line.startsWith('worktree ')) {
        const worktreePath = line.substring('worktree '.length);
        if (worktreePath.startsWith(this.worktreeBase)) {
          const name = path.basename(worktreePath);
          worktrees.push(name);
        }
      }
    }

    return worktrees;
  }

  /**
   * Merge a branch into another branch within a worktree
   * Used by supervisor to merge worker branches into epic branch
   */
  async mergeBranch(
    worktreePath: string,
    sourceBranch: string,
    commitMessage?: string
  ): Promise<{ success: boolean; mergeCommit: string }> {
    // Merge the source branch into the current branch using spawn (safe - no shell)
    const mergeArgs = commitMessage
      ? ['merge', sourceBranch, '-m', commitMessage]
      : ['merge', sourceBranch];

    const mergeResult = await gitCommand(mergeArgs, worktreePath);
    if (mergeResult.code !== 0) {
      throw new Error(
        `Failed to merge branch ${sourceBranch}: ${mergeResult.stderr || mergeResult.stdout}`
      );
    }

    // Get the merge commit SHA
    const revResult = await gitCommand(['rev-parse', 'HEAD'], worktreePath);
    if (revResult.code !== 0) {
      throw new Error(`Failed to get merge commit: ${revResult.stderr || revResult.stdout}`);
    }

    return {
      success: true,
      mergeCommit: revResult.stdout.trim(),
    };
  }

  /**
   * Push a branch to origin
   * Used by supervisor to push epic branch after merging
   */
  async pushBranch(worktreePath: string, branchName?: string): Promise<void> {
    const branch = branchName || 'HEAD';
    const result = await gitCommand(['push', 'origin', branch], worktreePath);
    if (result.code !== 0) {
      throw new Error(`Failed to push branch: ${result.stderr || result.stdout}`);
    }
  }

  /**
   * Push a branch to origin, setting upstream if needed
   */
  async pushBranchWithUpstream(worktreePath: string): Promise<void> {
    const result = await gitCommand(['push', '-u', 'origin', 'HEAD'], worktreePath);
    if (result.code !== 0) {
      throw new Error(`Failed to push branch with upstream: ${result.stderr || result.stdout}`);
    }
  }

  /**
   * Fetch latest from origin
   */
  async fetch(worktreePath: string): Promise<void> {
    const result = await gitCommand(['fetch', 'origin'], worktreePath);
    if (result.code !== 0) {
      throw new Error(`Failed to fetch: ${result.stderr || result.stdout}`);
    }
  }

  /**
   * Get the current branch name
   */
  async getCurrentBranch(worktreePath: string): Promise<string> {
    const result = await gitCommand(['rev-parse', '--abbrev-ref', 'HEAD'], worktreePath);
    if (result.code !== 0) {
      throw new Error(`Failed to get current branch: ${result.stderr || result.stdout}`);
    }
    return result.stdout.trim();
  }

  /**
   * Get the latest commit message
   */
  async getLatestCommitMessage(worktreePath: string): Promise<string> {
    const result = await gitCommand(['log', '-1', '--format=%s'], worktreePath);
    if (result.code !== 0) {
      throw new Error(`Failed to get latest commit message: ${result.stderr || result.stdout}`);
    }
    return result.stdout.trim();
  }
}

/**
 * Factory for creating project-specific GitClient instances.
 * Caches instances by repo+worktree path combination.
 */
export class GitClientFactory {
  private static instances = new Map<string, GitClient>();

  /**
   * Get or create a GitClient for a specific project.
   */
  static forProject(project: { repoPath: string; worktreeBasePath: string }): GitClient {
    const key = `${project.repoPath}:${project.worktreeBasePath}`;
    const existing = GitClientFactory.instances.get(key);
    if (existing) {
      return existing;
    }
    const client = new GitClient({
      baseRepoPath: project.repoPath,
      worktreeBase: project.worktreeBasePath,
    });
    GitClientFactory.instances.set(key, client);
    return client;
  }

  /**
   * Remove a cached GitClient for a project.
   * Call this when a project is deleted or its paths change.
   */
  static removeProject(project: { repoPath: string; worktreeBasePath: string }): boolean {
    const key = `${project.repoPath}:${project.worktreeBasePath}`;
    return GitClientFactory.instances.delete(key);
  }

  /**
   * Clear all cached instances. Useful for testing.
   */
  static clearCache(): void {
    GitClientFactory.instances.clear();
  }

  /**
   * Get the number of cached instances.
   */
  static get cacheSize(): number {
    return GitClientFactory.instances.size;
  }
}

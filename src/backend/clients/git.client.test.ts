import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const mockGitCommand = vi.fn();
const mockGitCommandC = vi.fn();
const mockMkdir = vi.fn();

vi.mock('@/backend/lib/shell', () => ({
  gitCommand: (...args: unknown[]) => mockGitCommand(...args),
  gitCommandC: (...args: unknown[]) => mockGitCommandC(...args),
}));

vi.mock('node:fs/promises', () => ({
  mkdir: (...args: unknown[]) => mockMkdir(...args),
}));

import { GitClient, GitClientFactory, isAutoGeneratedBranchName } from './git.client';

function commandSuccess(stdout = '') {
  return {
    code: 0,
    stdout,
    stderr: '',
  };
}

function commandFailure(stderr = 'boom', stdout = '') {
  return {
    code: 1,
    stdout,
    stderr,
  };
}

// =============================================================================
// GitClient Unit Tests (non-mocked)
// These tests cover functionality that doesn't require git command execution
// =============================================================================

describe('GitClient', () => {
  const testConfig = {
    baseRepoPath: '/test/repo',
    worktreeBase: '/test/worktrees',
  };

  let client: GitClient;

  beforeEach(() => {
    vi.clearAllMocks();
    mockMkdir.mockResolvedValue(undefined);
    client = new GitClient(testConfig);
  });

  // ===========================================================================
  // Constructor Tests
  // ===========================================================================

  describe('constructor', () => {
    it('should create a client with valid config', () => {
      expect(client).toBeInstanceOf(GitClient);
    });

    it('should throw if baseRepoPath is missing', () => {
      expect(() => new GitClient({ baseRepoPath: '', worktreeBase: '/test' })).toThrow(
        'baseRepoPath is required'
      );
    });

    it('should throw if worktreeBase is missing', () => {
      expect(() => new GitClient({ baseRepoPath: '/test', worktreeBase: '' })).toThrow(
        'worktreeBase is required'
      );
    });

    it('should throw if baseRepoPath is undefined', () => {
      expect(
        () => new GitClient({ baseRepoPath: undefined as never, worktreeBase: '/test' })
      ).toThrow('baseRepoPath is required');
    });

    it('should throw if worktreeBase is undefined', () => {
      expect(
        () => new GitClient({ baseRepoPath: '/test', worktreeBase: undefined as never })
      ).toThrow('worktreeBase is required');
    });
  });

  // ===========================================================================
  // getWorktreePath Tests
  // ===========================================================================

  describe('getWorktreePath', () => {
    it('should return correct path', () => {
      const path = client.getWorktreePath('my-workspace');
      expect(path).toBe('/test/worktrees/my-workspace');
    });

    it('should handle workspace names with hyphens', () => {
      const path = client.getWorktreePath('workspace-123-abc');
      expect(path).toBe('/test/worktrees/workspace-123-abc');
    });

    it('should handle workspace names with underscores', () => {
      const path = client.getWorktreePath('workspace_test');
      expect(path).toBe('/test/worktrees/workspace_test');
    });

    it('should handle long workspace names', () => {
      const longName = 'a'.repeat(100);
      const path = client.getWorktreePath(longName);
      expect(path).toBe(`/test/worktrees/${longName}`);
    });

    it('should handle single character workspace name', () => {
      const path = client.getWorktreePath('x');
      expect(path).toBe('/test/worktrees/x');
    });
  });

  // ===========================================================================
  // generateBranchName Tests
  // ===========================================================================

  describe('generateBranchName', () => {
    it('should generate a branch name without prefix', () => {
      const name = client.generateBranchName();
      // Should be 6 hex characters
      expect(name).toMatch(/^[0-9a-f]{6}$/);
    });

    it('should generate a branch name with prefix', () => {
      const name = client.generateBranchName('martin-purplefish');
      expect(name).toMatch(/^martin-purplefish\/[0-9a-f]{6}$/);
    });

    it('should generate a branch name with complex prefix', () => {
      const name = client.generateBranchName('user-name/feature');
      expect(name).toMatch(/^user-name\/feature\/[0-9a-f]{6}$/);
    });

    it('should generate unique names on successive calls', () => {
      const names = new Set<string>();
      for (let i = 0; i < 100; i++) {
        names.add(client.generateBranchName());
      }
      // All 100 names should be unique.
      expect(names.size).toBe(100);
    });

    it('should generate 6 character hex hash', () => {
      const name = client.generateBranchName();
      expect(name).toHaveLength(6);
      expect(name).toMatch(/^[0-9a-f]+$/);
    });

    it('should handle empty prefix by generating just hash', () => {
      const name = client.generateBranchName('');
      // Empty string is falsy, so it should just return the hash
      expect(name).toMatch(/^[0-9a-f]{6}$/);
    });

    it('should use workspace name without hash when provided', () => {
      const name = client.generateBranchName('martin-purplefish', 'flux-1');
      expect(name).toBe('martin-purplefish/flux-1');
    });

    it('should use workspace name only when no prefix', () => {
      const name = client.generateBranchName(undefined, 'flux-1');
      expect(name).toBe('flux-1');
    });

    it('should use workspace name only when empty prefix', () => {
      const name = client.generateBranchName('', 'flux-1');
      expect(name).toBe('flux-1');
    });

    it('should handle workspace names with hyphens', () => {
      const name = client.generateBranchName('martin-purplefish', 'tiger-2');
      expect(name).toBe('martin-purplefish/tiger-2');
    });
  });

  // ===========================================================================
  // generateUniqueBranchName Tests
  // ===========================================================================

  describe('generateUniqueBranchName', () => {
    it('should return base name when branch does not exist', async () => {
      // Mock branchExists to always return false
      client.branchExists = () => Promise.resolve(false);

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      expect(name).toBe('martin-purplefish/jaguar');
    });

    it('should append -1 when base branch exists', async () => {
      let callCount = 0;
      client.branchExists = (_branchName: string) => {
        callCount++;
        // First call: base name exists
        if (callCount === 1) {
          return Promise.resolve(true);
        }
        // Second call: -1 doesn't exist
        return Promise.resolve(false);
      };

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      expect(name).toBe('martin-purplefish/jaguar-1');
    });

    it('should increment until finding available name', async () => {
      const existingNames = new Set([
        'martin-purplefish/jaguar',
        'martin-purplefish/jaguar-1',
        'martin-purplefish/jaguar-2',
      ]);

      client.branchExists = (branchName: string) => Promise.resolve(existingNames.has(branchName));

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      expect(name).toBe('martin-purplefish/jaguar-3');
    });

    it('should work without prefix', async () => {
      let callCount = 0;
      client.branchExists = () => {
        callCount++;
        return Promise.resolve(callCount === 1); // First one exists, second doesn't
      };

      const name = await client.generateUniqueBranchName(undefined, 'jaguar');
      expect(name).toBe('jaguar-1');
    });

    it('should fallback to random hex after 1000 attempts', async () => {
      // All branches exist
      client.branchExists = () => Promise.resolve(true);

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      // Should fallback to random 12-character hex
      expect(name).toMatch(/^martin-purplefish\/[0-9a-f]{12}$/);
    });

    it('should handle auto-generated names (no workspace name)', async () => {
      client.branchExists = () => Promise.resolve(false);

      const name = await client.generateUniqueBranchName('martin-purplefish');
      // Should be prefix + 6 hex chars
      expect(name).toMatch(/^martin-purplefish\/[0-9a-f]{6}$/);
    });
  });

  describe('sanitizeBranchName', () => {
    it('normalizes separators and removes invalid characters', () => {
      const value = client.sanitizeBranchName(' Feature Name_with.$Special***Chars ');
      expect(value).toBe('feature-name-withspecialchars');
    });

    it('collapses repeated dashes and trims edges', () => {
      const value = client.sanitizeBranchName('__my----branch___');
      expect(value).toBe('my-branch');
    });

    it('truncates long names to 50 characters', () => {
      const longName = 'very-long-branch-name-'.repeat(5);
      expect(client.sanitizeBranchName(longName)).toHaveLength(50);
    });
  });

  describe('createWorktree', () => {
    it('creates orphan worktree in blank repositories', async () => {
      vi.spyOn(client, 'generateUniqueBranchName').mockResolvedValue('martin-purplefish/tiger');
      vi.spyOn(client, 'isBlankRepository').mockResolvedValue(true);
      mockGitCommandC.mockResolvedValue(commandSuccess());

      const result = await client.createWorktree('ws-1');

      expect(mockMkdir).toHaveBeenCalledWith('/test/worktrees', { recursive: true });
      expect(mockGitCommandC).toHaveBeenCalledWith('/test/repo', [
        'worktree',
        'add',
        '--orphan',
        '-b',
        'martin-purplefish/tiger',
        '/test/worktrees/ws-1',
      ]);
      expect(result).toEqual({
        name: 'ws-1',
        path: '/test/worktrees/ws-1',
        branchName: 'martin-purplefish/tiger',
      });
    });

    it('throws when orphan worktree creation fails', async () => {
      vi.spyOn(client, 'generateUniqueBranchName').mockResolvedValue('martin-purplefish/tiger');
      vi.spyOn(client, 'isBlankRepository').mockResolvedValue(true);
      mockGitCommandC.mockResolvedValue(commandFailure('orphan failed'));

      await expect(client.createWorktree('ws-1')).rejects.toThrow(
        'Failed to create worktree in blank repository: orphan failed'
      );
    });

    it('prefers freshly fetched origin branch when available', async () => {
      vi.spyOn(client, 'generateUniqueBranchName').mockResolvedValue('martin-purplefish/tiger');
      vi.spyOn(client, 'isBlankRepository').mockResolvedValue(false);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(true).mockResolvedValueOnce(false);
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandSuccess());

      const result = await client.createWorktree('ws-1', 'origin/main');

      expect(mockGitCommandC).toHaveBeenNthCalledWith(1, '/test/repo', ['fetch', 'origin', 'main']);
      expect(mockGitCommandC).toHaveBeenNthCalledWith(2, '/test/repo', [
        'worktree',
        'add',
        '-b',
        'martin-purplefish/tiger',
        '/test/worktrees/ws-1',
        'origin/main',
      ]);
      expect(result.branchName).toBe('martin-purplefish/tiger');
    });

    it('falls back to local branch when fetch fails and local branch exists', async () => {
      vi.spyOn(client, 'generateUniqueBranchName').mockResolvedValue('martin-purplefish/tiger');
      vi.spyOn(client, 'isBlankRepository').mockResolvedValue(false);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(false).mockResolvedValueOnce(true);
      mockGitCommandC
        .mockResolvedValueOnce(commandFailure('offline'))
        .mockResolvedValueOnce(commandSuccess());

      await client.createWorktree('ws-1', 'main');

      expect(mockGitCommandC).toHaveBeenNthCalledWith(2, '/test/repo', [
        'worktree',
        'add',
        '-b',
        'martin-purplefish/tiger',
        '/test/worktrees/ws-1',
        'main',
      ]);
    });

    it('falls back to stale origin branch when fetch fails and only origin exists', async () => {
      vi.spyOn(client, 'generateUniqueBranchName').mockResolvedValue('martin-purplefish/tiger');
      vi.spyOn(client, 'isBlankRepository').mockResolvedValue(false);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(true).mockResolvedValueOnce(false);
      mockGitCommandC
        .mockResolvedValueOnce(commandFailure('offline'))
        .mockResolvedValueOnce(commandSuccess());

      await client.createWorktree('ws-1', 'main');

      expect(mockGitCommandC).toHaveBeenNthCalledWith(2, '/test/repo', [
        'worktree',
        'add',
        '-b',
        'martin-purplefish/tiger',
        '/test/worktrees/ws-1',
        'origin/main',
      ]);
    });

    it('throws when non-blank worktree creation fails', async () => {
      vi.spyOn(client, 'generateUniqueBranchName').mockResolvedValue('martin-purplefish/tiger');
      vi.spyOn(client, 'isBlankRepository').mockResolvedValue(false);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(false).mockResolvedValueOnce(false);
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandFailure('cannot create'));

      await expect(client.createWorktree('ws-1', 'main')).rejects.toThrow(
        'Failed to create worktree: cannot create'
      );
    });
  });

  describe('createWorktreeFromExistingBranch', () => {
    it('throws when branch is already checked out in another worktree', async () => {
      vi.spyOn(client, 'listWorktreesWithBranches').mockResolvedValue([
        { path: '/other/worktree', branchName: 'refs/heads/feature-1' },
      ]);

      await expect(client.createWorktreeFromExistingBranch('ws-1', 'feature-1')).rejects.toThrow(
        'Branch feature-1 is already checked out in another workspace worktree.'
      );
    });

    it('force resets local branch to origin when remote branch is requested', async () => {
      vi.spyOn(client, 'listWorktreesWithBranches').mockResolvedValue([]);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(true).mockResolvedValueOnce(true);
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandSuccess());

      const result = await client.createWorktreeFromExistingBranch('ws-1', 'origin/feature-1');

      expect(mockGitCommandC).toHaveBeenNthCalledWith(1, '/test/repo', [
        'fetch',
        'origin',
        'feature-1',
      ]);
      expect(mockGitCommandC).toHaveBeenNthCalledWith(2, '/test/repo', [
        'worktree',
        'add',
        '-B',
        'feature-1',
        '/test/worktrees/ws-1',
        'origin/feature-1',
      ]);
      expect(result.branchName).toBe('feature-1');
    });

    it('resets to origin when local branch is behind fetched origin', async () => {
      vi.spyOn(client, 'listWorktreesWithBranches').mockResolvedValue([]);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(true).mockResolvedValueOnce(true);
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandSuccess('local-sha\n'))
        .mockResolvedValueOnce(commandSuccess('origin-sha\n'))
        .mockResolvedValueOnce(commandSuccess());

      await client.createWorktreeFromExistingBranch('ws-1', 'feature-1');

      expect(mockGitCommandC).toHaveBeenNthCalledWith(2, '/test/repo', [
        'merge-base',
        '--is-ancestor',
        'feature-1',
        'origin/feature-1',
      ]);
      expect(mockGitCommandC).toHaveBeenNthCalledWith(5, '/test/repo', [
        'worktree',
        'add',
        '-B',
        'feature-1',
        '/test/worktrees/ws-1',
        'origin/feature-1',
      ]);
    });

    it('uses local existing branch without creating a new one when reset is not needed', async () => {
      vi.spyOn(client, 'listWorktreesWithBranches').mockResolvedValue([]);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(true).mockResolvedValueOnce(false);
      mockGitCommandC
        .mockResolvedValueOnce(commandFailure('offline'))
        .mockResolvedValueOnce(commandSuccess());

      await client.createWorktreeFromExistingBranch('ws-1', 'feature-1');

      expect(mockGitCommandC).toHaveBeenNthCalledWith(2, '/test/repo', [
        'worktree',
        'add',
        '/test/worktrees/ws-1',
        'feature-1',
      ]);
    });

    it('creates a new local branch when local does not exist', async () => {
      vi.spyOn(client, 'listWorktreesWithBranches').mockResolvedValue([]);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(false).mockResolvedValueOnce(true);
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandSuccess());

      await client.createWorktreeFromExistingBranch('ws-1', 'feature-1');

      expect(mockGitCommandC).toHaveBeenNthCalledWith(2, '/test/repo', [
        'worktree',
        'add',
        '-b',
        'feature-1',
        '/test/worktrees/ws-1',
        'origin/feature-1',
      ]);
    });

    it('throws when creating worktree from branch fails', async () => {
      vi.spyOn(client, 'listWorktreesWithBranches').mockResolvedValue([]);
      vi.spyOn(client, 'branchExists').mockResolvedValueOnce(false).mockResolvedValueOnce(false);
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandFailure('cannot create worktree'));

      await expect(client.createWorktreeFromExistingBranch('ws-1', 'feature-1')).rejects.toThrow(
        'Failed to create worktree from branch: cannot create worktree'
      );
    });
  });

  describe('git command wrappers', () => {
    it('checks branch existence from rev-parse exit code', async () => {
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandFailure());

      await expect(client.branchExists('feature-1')).resolves.toBe(true);
      await expect(client.branchExists('feature-2')).resolves.toBe(false);
    });

    it('checks blank repository status from HEAD rev-parse', async () => {
      mockGitCommandC
        .mockResolvedValueOnce(commandFailure())
        .mockResolvedValueOnce(commandSuccess());

      await expect(client.isBlankRepository()).resolves.toBe(true);
      await expect(client.isBlankRepository()).resolves.toBe(false);
    });

    it('deletes worktree with force', async () => {
      mockGitCommandC.mockResolvedValue(commandSuccess());

      await client.deleteWorktree('ws-1');

      expect(mockGitCommandC).toHaveBeenCalledWith('/test/repo', [
        'worktree',
        'remove',
        '/test/worktrees/ws-1',
        '--force',
      ]);
    });

    it('throws when deleting worktree fails', async () => {
      mockGitCommandC.mockResolvedValue(commandFailure('remove failed'));

      await expect(client.deleteWorktree('ws-1')).rejects.toThrow(
        'Failed to delete worktree: remove failed'
      );
    });

    it('checks worktree existence from worktree list output', async () => {
      mockGitCommandC
        .mockResolvedValueOnce(commandSuccess('/test/worktrees/ws-1\n'))
        .mockResolvedValueOnce(commandSuccess('/test/worktrees/other\n'))
        .mockResolvedValueOnce(commandFailure());

      await expect(client.checkWorktreeExists('ws-1')).resolves.toBe(true);
      await expect(client.checkWorktreeExists('ws-1')).resolves.toBe(false);
      await expect(client.checkWorktreeExists('ws-1')).resolves.toBe(false);
    });

    it('lists only worktrees under configured base path', async () => {
      mockGitCommandC.mockResolvedValue(
        commandSuccess(
          [
            'worktree /test/repo',
            'HEAD abc123',
            'worktree /test/worktrees/ws-1',
            'branch refs/heads/feature-1',
            'worktree /test/worktrees/ws-2',
            'branch refs/heads/feature-2',
            'worktree /external/path/ws-3',
          ].join('\n')
        )
      );

      await expect(client.listWorktrees()).resolves.toEqual(['ws-1', 'ws-2']);
    });

    it('throws when listWorktrees command fails', async () => {
      mockGitCommandC.mockResolvedValue(commandFailure('list failed'));

      await expect(client.listWorktrees()).rejects.toThrow('Failed to list worktrees: list failed');
    });

    it('lists worktrees with normalized branch names', async () => {
      mockGitCommandC.mockResolvedValue(
        commandSuccess(
          [
            'worktree /test/repo',
            'HEAD abc',
            'worktree /test/worktrees/ws-1',
            'branch refs/heads/feature-1',
            'worktree /test/worktrees/ws-2',
            'branch origin/feature-2',
            'worktree /test/worktrees/ws-3',
          ].join('\n')
        )
      );

      await expect(client.listWorktreesWithBranches()).resolves.toEqual([
        { path: '/test/repo' },
        { path: '/test/worktrees/ws-1', branchName: 'feature-1' },
        { path: '/test/worktrees/ws-2', branchName: 'origin/feature-2' },
        { path: '/test/worktrees/ws-3' },
      ]);
    });

    it('throws when listWorktreesWithBranches command fails', async () => {
      mockGitCommandC.mockResolvedValue(commandFailure('porcelain failed'));

      await expect(client.listWorktreesWithBranches()).rejects.toThrow(
        'Failed to list worktrees: porcelain failed'
      );
    });

    it('merges branch and returns merge commit SHA', async () => {
      mockGitCommand
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandSuccess('abc123\n'));

      await expect(client.mergeBranch('/tmp/ws', 'feature-1', 'merge msg')).resolves.toEqual({
        success: true,
        mergeCommit: 'abc123',
      });
      expect(mockGitCommand).toHaveBeenNthCalledWith(
        1,
        ['merge', 'feature-1', '-m', 'merge msg'],
        '/tmp/ws'
      );
      expect(mockGitCommand).toHaveBeenNthCalledWith(2, ['rev-parse', 'HEAD'], '/tmp/ws');
    });

    it('throws when merge command fails', async () => {
      mockGitCommand.mockResolvedValue(commandFailure('conflict'));

      await expect(client.mergeBranch('/tmp/ws', 'feature-1')).rejects.toThrow(
        'Failed to merge branch feature-1: conflict'
      );
    });

    it('throws when merge commit lookup fails', async () => {
      mockGitCommand
        .mockResolvedValueOnce(commandSuccess())
        .mockResolvedValueOnce(commandFailure('rev failed'));

      await expect(client.mergeBranch('/tmp/ws', 'feature-1')).rejects.toThrow(
        'Failed to get merge commit: rev failed'
      );
    });

    it('pushes branch or HEAD to origin', async () => {
      mockGitCommand.mockResolvedValue(commandSuccess());

      await client.pushBranch('/tmp/ws', 'feature-1');
      await client.pushBranch('/tmp/ws');

      expect(mockGitCommand).toHaveBeenNthCalledWith(1, ['push', 'origin', 'feature-1'], '/tmp/ws');
      expect(mockGitCommand).toHaveBeenNthCalledWith(2, ['push', 'origin', 'HEAD'], '/tmp/ws');
    });

    it('throws when push/fetch helpers fail', async () => {
      mockGitCommand
        .mockResolvedValueOnce(commandFailure('push failed'))
        .mockResolvedValueOnce(commandFailure('push -u failed'))
        .mockResolvedValueOnce(commandFailure('fetch failed'));

      await expect(client.pushBranch('/tmp/ws')).rejects.toThrow(
        'Failed to push branch: push failed'
      );
      await expect(client.pushBranchWithUpstream('/tmp/ws')).rejects.toThrow(
        'Failed to push branch with upstream: push -u failed'
      );
      await expect(client.fetch('/tmp/ws')).rejects.toThrow('Failed to fetch: fetch failed');
    });

    it('returns branch and latest commit message when commands succeed', async () => {
      mockGitCommand
        .mockResolvedValueOnce(commandSuccess('feature-1\n'))
        .mockResolvedValueOnce(commandSuccess('feat: do thing\n'));

      await expect(client.getCurrentBranch('/tmp/ws')).resolves.toBe('feature-1');
      await expect(client.getLatestCommitMessage('/tmp/ws')).resolves.toBe('feat: do thing');
    });

    it('throws when current branch or latest commit lookup fails', async () => {
      mockGitCommand
        .mockResolvedValueOnce(commandFailure('branch failed'))
        .mockResolvedValueOnce(commandFailure('message failed'));

      await expect(client.getCurrentBranch('/tmp/ws')).rejects.toThrow(
        'Failed to get current branch: branch failed'
      );
      await expect(client.getLatestCommitMessage('/tmp/ws')).rejects.toThrow(
        'Failed to get latest commit message: message failed'
      );
    });
  });
});

// =============================================================================
// isAutoGeneratedBranchName Tests
// =============================================================================

describe('isAutoGeneratedBranchName', () => {
  describe('hex-only branches (no prefix)', () => {
    it('should match 6 hex characters', () => {
      expect(isAutoGeneratedBranchName('abc123')).toBe(true);
      expect(isAutoGeneratedBranchName('000000')).toBe(true);
      expect(isAutoGeneratedBranchName('ffffff')).toBe(true);
      expect(isAutoGeneratedBranchName('a1b2c3')).toBe(true);
    });

    it('should not match non-hex characters that are not workspace words', () => {
      expect(isAutoGeneratedBranchName('ghijkl')).toBe(false);
      expect(isAutoGeneratedBranchName('xyz123')).toBe(false);
      expect(isAutoGeneratedBranchName('ABCDEF')).toBe(false); // uppercase not hex
    });

    it('should not match wrong length hex', () => {
      expect(isAutoGeneratedBranchName('abc12')).toBe(false); // 5 chars
      expect(isAutoGeneratedBranchName('abc1234')).toBe(false); // 7 chars
      expect(isAutoGeneratedBranchName('')).toBe(false);
    });
  });

  describe('prefixed branches with hex (single segment)', () => {
    it('should match single-segment prefix with 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('martin-purplefish/abc123')).toBe(true);
      expect(isAutoGeneratedBranchName('user/ffffff')).toBe(true);
      expect(isAutoGeneratedBranchName('feature/000000')).toBe(true);
    });

    it('should not match single-segment prefix with non-hex, non-workspace-word suffix', () => {
      expect(isAutoGeneratedBranchName('prefix/notahex')).toBe(false);
      expect(isAutoGeneratedBranchName('prefix/abc12g')).toBe(false);
    });
  });

  describe('prefixed branches with hex (multi-segment)', () => {
    it('should match multi-segment prefix with 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('user-name/feature/abc123')).toBe(true);
      expect(isAutoGeneratedBranchName('a/b/c/d/e/ffffff')).toBe(true);
      expect(isAutoGeneratedBranchName('org/team/project/000000')).toBe(true);
    });

    it('should not match multi-segment prefix with non-hex, non-workspace-word suffix', () => {
      expect(isAutoGeneratedBranchName('user/feature/notahex')).toBe(false);
      expect(isAutoGeneratedBranchName('a/b/c/ABCDEF')).toBe(false); // uppercase
    });
  });

  describe('workspace word branches (no prefix)', () => {
    it('should match workspace words without numeric suffix', () => {
      expect(isAutoGeneratedBranchName('tiger')).toBe(true);
      expect(isAutoGeneratedBranchName('falcon')).toBe(true);
      expect(isAutoGeneratedBranchName('pulse')).toBe(true);
      expect(isAutoGeneratedBranchName('flux')).toBe(true);
      expect(isAutoGeneratedBranchName('nova')).toBe(true);
      expect(isAutoGeneratedBranchName('thunder')).toBe(true);
    });

    it('should match workspace words with numeric suffix', () => {
      expect(isAutoGeneratedBranchName('tiger-1')).toBe(true);
      expect(isAutoGeneratedBranchName('pulse-2')).toBe(true);
      expect(isAutoGeneratedBranchName('flux-42')).toBe(true);
      expect(isAutoGeneratedBranchName('nova-999')).toBe(true);
    });
  });

  describe('prefixed workspace word branches', () => {
    it('should match prefixed workspace words without numeric suffix', () => {
      expect(isAutoGeneratedBranchName('adeeshaek/pulse')).toBe(true);
      expect(isAutoGeneratedBranchName('martin-purplefish/tiger')).toBe(true);
      expect(isAutoGeneratedBranchName('user/falcon')).toBe(true);
      expect(isAutoGeneratedBranchName('org/team/nova')).toBe(true);
    });

    it('should match prefixed workspace words with numeric suffix', () => {
      expect(isAutoGeneratedBranchName('adeeshaek/pulse-1')).toBe(true);
      expect(isAutoGeneratedBranchName('martin-purplefish/tiger-5')).toBe(true);
      expect(isAutoGeneratedBranchName('user/flux-99')).toBe(true);
      expect(isAutoGeneratedBranchName('org/team/project/dragon-2')).toBe(true);
    });
  });

  describe('non-matching branches (meaningful names)', () => {
    it('should not match meaningful branch names', () => {
      expect(isAutoGeneratedBranchName('main')).toBe(false);
      expect(isAutoGeneratedBranchName('develop')).toBe(false);
      expect(isAutoGeneratedBranchName('feature/add-login')).toBe(false);
      expect(isAutoGeneratedBranchName('martin-purplefish/fix-bug-123')).toBe(false);
      expect(isAutoGeneratedBranchName('hotfix/security-patch')).toBe(false);
    });

    it('should not match branches with descriptive names after rename', () => {
      // These are branches that have been renamed from auto-generated to meaningful
      expect(isAutoGeneratedBranchName('adeeshaek/add-user-auth')).toBe(false);
      expect(isAutoGeneratedBranchName('user/implement-caching')).toBe(false);
      expect(isAutoGeneratedBranchName('feature/refactor-api')).toBe(false);
    });

    it('should not match branches ending with more than 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('prefix/abc1234')).toBe(false); // 7 chars
      expect(isAutoGeneratedBranchName('prefix/abc12345678')).toBe(false);
    });

    it('should not match branches ending with fewer than 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('prefix/abc12')).toBe(false); // 5 chars
      expect(isAutoGeneratedBranchName('prefix/abc')).toBe(false);
    });
  });

  describe('edge cases', () => {
    it('should not match empty string', () => {
      expect(isAutoGeneratedBranchName('')).toBe(false);
    });

    it('should not match just a slash', () => {
      expect(isAutoGeneratedBranchName('/')).toBe(false);
      expect(isAutoGeneratedBranchName('/abc123')).toBe(false); // empty prefix
    });

    it('should not match trailing slash', () => {
      expect(isAutoGeneratedBranchName('abc123/')).toBe(false);
      expect(isAutoGeneratedBranchName('prefix/abc123/')).toBe(false);
    });

    it('should not match workspace words with non-numeric suffixes', () => {
      // "pulse-foo" is not auto-generated - it has a meaningful suffix
      expect(isAutoGeneratedBranchName('pulse-foo')).toBe(false);
      expect(isAutoGeneratedBranchName('tiger-feature')).toBe(false);
      expect(isAutoGeneratedBranchName('adeeshaek/flux-update')).toBe(false);
    });

    it('should not match partial workspace words', () => {
      expect(isAutoGeneratedBranchName('tig')).toBe(false); // partial "tiger"
      expect(isAutoGeneratedBranchName('puls')).toBe(false); // partial "pulse"
    });
  });
});

// =============================================================================
// GitClientFactory Tests
// =============================================================================

describe('GitClientFactory', () => {
  afterEach(() => {
    GitClientFactory.clearCache();
  });

  describe('forProject', () => {
    it('should create a new client for a project', () => {
      const client = GitClientFactory.forProject({
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees',
      });

      expect(client).toBeInstanceOf(GitClient);
    });

    it('should return cached client for same project', () => {
      const project = {
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees',
      };

      const client1 = GitClientFactory.forProject(project);
      const client2 = GitClientFactory.forProject(project);

      expect(client1).toBe(client2);
    });

    it('should create different clients for different projects', () => {
      const client1 = GitClientFactory.forProject({
        repoPath: '/test/repo1',
        worktreeBasePath: '/test/worktrees1',
      });
      const client2 = GitClientFactory.forProject({
        repoPath: '/test/repo2',
        worktreeBasePath: '/test/worktrees2',
      });

      expect(client1).not.toBe(client2);
    });

    it('should differentiate by repoPath', () => {
      const client1 = GitClientFactory.forProject({
        repoPath: '/test/repo1',
        worktreeBasePath: '/test/worktrees',
      });
      const client2 = GitClientFactory.forProject({
        repoPath: '/test/repo2',
        worktreeBasePath: '/test/worktrees',
      });

      expect(client1).not.toBe(client2);
    });

    it('should differentiate by worktreeBasePath', () => {
      const client1 = GitClientFactory.forProject({
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees1',
      });
      const client2 = GitClientFactory.forProject({
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees2',
      });

      expect(client1).not.toBe(client2);
    });
  });

  describe('removeProject', () => {
    it('should remove cached client', () => {
      const project = {
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees',
      };

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);

      const removed = GitClientFactory.removeProject(project);
      expect(removed).toBe(true);
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should return false if project not cached', () => {
      const removed = GitClientFactory.removeProject({
        repoPath: '/nonexistent',
        worktreeBasePath: '/nonexistent',
      });

      expect(removed).toBe(false);
    });

    it('should only remove the specified project', () => {
      const project1 = { repoPath: '/repo1', worktreeBasePath: '/wt1' };
      const project2 = { repoPath: '/repo2', worktreeBasePath: '/wt2' };

      GitClientFactory.forProject(project1);
      GitClientFactory.forProject(project2);
      expect(GitClientFactory.cacheSize).toBe(2);

      GitClientFactory.removeProject(project1);
      expect(GitClientFactory.cacheSize).toBe(1);

      // project2 should still be cached
      const client = GitClientFactory.forProject(project2);
      expect(client).toBeInstanceOf(GitClient);
    });
  });

  describe('clearCache', () => {
    it('should clear all cached clients', () => {
      GitClientFactory.forProject({ repoPath: '/repo1', worktreeBasePath: '/wt1' });
      GitClientFactory.forProject({ repoPath: '/repo2', worktreeBasePath: '/wt2' });
      GitClientFactory.forProject({ repoPath: '/repo3', worktreeBasePath: '/wt3' });

      expect(GitClientFactory.cacheSize).toBe(3);

      GitClientFactory.clearCache();
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should work on empty cache', () => {
      expect(GitClientFactory.cacheSize).toBe(0);
      GitClientFactory.clearCache();
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should allow new clients to be created after clear', () => {
      const project = { repoPath: '/repo', worktreeBasePath: '/wt' };

      const client1 = GitClientFactory.forProject(project);
      GitClientFactory.clearCache();
      const client2 = GitClientFactory.forProject(project);

      // Should be different instances since cache was cleared
      expect(client1).not.toBe(client2);
    });
  });

  describe('cacheSize', () => {
    it('should return 0 for empty cache', () => {
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should return correct count after adding clients', () => {
      GitClientFactory.forProject({ repoPath: '/repo1', worktreeBasePath: '/wt1' });
      expect(GitClientFactory.cacheSize).toBe(1);

      GitClientFactory.forProject({ repoPath: '/repo2', worktreeBasePath: '/wt2' });
      expect(GitClientFactory.cacheSize).toBe(2);

      GitClientFactory.forProject({ repoPath: '/repo3', worktreeBasePath: '/wt3' });
      expect(GitClientFactory.cacheSize).toBe(3);
    });

    it('should not increase when getting same project', () => {
      const project = { repoPath: '/repo', worktreeBasePath: '/wt' };

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);
    });
  });
});

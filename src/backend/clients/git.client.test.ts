import { afterEach, beforeEach, describe, expect, it } from 'vitest';
import { GitClient, GitClientFactory, isAutoGeneratedBranchName } from './git.client';

// =============================================================================
// GitClient Unit Tests (non-mocked)
// These tests cover functionality that doesn't require git command execution
// =============================================================================

describe('GitClient', () => {
  const testConfig = {
    baseRepoPath: '/test/repo',
    worktreeBase: '/test/worktrees',
  };

  let client: GitClient;

  beforeEach(() => {
    client = new GitClient(testConfig);
  });

  // ===========================================================================
  // Constructor Tests
  // ===========================================================================

  describe('constructor', () => {
    it('should create a client with valid config', () => {
      expect(client).toBeInstanceOf(GitClient);
    });

    it('should throw if baseRepoPath is missing', () => {
      expect(() => new GitClient({ baseRepoPath: '', worktreeBase: '/test' })).toThrow(
        'baseRepoPath is required'
      );
    });

    it('should throw if worktreeBase is missing', () => {
      expect(() => new GitClient({ baseRepoPath: '/test', worktreeBase: '' })).toThrow(
        'worktreeBase is required'
      );
    });

    it('should throw if baseRepoPath is undefined', () => {
      expect(
        () => new GitClient({ baseRepoPath: undefined as never, worktreeBase: '/test' })
      ).toThrow('baseRepoPath is required');
    });

    it('should throw if worktreeBase is undefined', () => {
      expect(
        () => new GitClient({ baseRepoPath: '/test', worktreeBase: undefined as never })
      ).toThrow('worktreeBase is required');
    });
  });

  // ===========================================================================
  // getWorktreePath Tests
  // ===========================================================================

  describe('getWorktreePath', () => {
    it('should return correct path', () => {
      const path = client.getWorktreePath('my-workspace');
      expect(path).toBe('/test/worktrees/my-workspace');
    });

    it('should handle workspace names with hyphens', () => {
      const path = client.getWorktreePath('workspace-123-abc');
      expect(path).toBe('/test/worktrees/workspace-123-abc');
    });

    it('should handle workspace names with underscores', () => {
      const path = client.getWorktreePath('workspace_test');
      expect(path).toBe('/test/worktrees/workspace_test');
    });

    it('should handle long workspace names', () => {
      const longName = 'a'.repeat(100);
      const path = client.getWorktreePath(longName);
      expect(path).toBe(`/test/worktrees/${longName}`);
    });

    it('should handle single character workspace name', () => {
      const path = client.getWorktreePath('x');
      expect(path).toBe('/test/worktrees/x');
    });
  });

  // ===========================================================================
  // generateBranchName Tests
  // ===========================================================================

  describe('generateBranchName', () => {
    it('should generate a branch name without prefix', () => {
      const name = client.generateBranchName();
      // Should be 6 hex characters
      expect(name).toMatch(/^[0-9a-f]{6}$/);
    });

    it('should generate a branch name with prefix', () => {
      const name = client.generateBranchName('martin-purplefish');
      expect(name).toMatch(/^martin-purplefish\/[0-9a-f]{6}$/);
    });

    it('should generate a branch name with complex prefix', () => {
      const name = client.generateBranchName('user-name/feature');
      expect(name).toMatch(/^user-name\/feature\/[0-9a-f]{6}$/);
    });

    it('should generate unique names on successive calls', () => {
      const names = new Set<string>();
      for (let i = 0; i < 100; i++) {
        names.add(client.generateBranchName());
      }
      // All 100 names should be unique (extremely unlikely to have collisions)
      expect(names.size).toBe(100);
    });

    it('should generate 6 character hex hash', () => {
      const name = client.generateBranchName();
      expect(name).toHaveLength(6);
      expect(name).toMatch(/^[0-9a-f]+$/);
    });

    it('should handle empty prefix by generating just hash', () => {
      const name = client.generateBranchName('');
      // Empty string is falsy, so it should just return the hash
      expect(name).toMatch(/^[0-9a-f]{6}$/);
    });

    it('should use workspace name without hash when provided', () => {
      const name = client.generateBranchName('martin-purplefish', 'flux-1');
      expect(name).toBe('martin-purplefish/flux-1');
    });

    it('should use workspace name only when no prefix', () => {
      const name = client.generateBranchName(undefined, 'flux-1');
      expect(name).toBe('flux-1');
    });

    it('should use workspace name only when empty prefix', () => {
      const name = client.generateBranchName('', 'flux-1');
      expect(name).toBe('flux-1');
    });

    it('should handle workspace names with hyphens', () => {
      const name = client.generateBranchName('martin-purplefish', 'tiger-2');
      expect(name).toBe('martin-purplefish/tiger-2');
    });
  });

  // ===========================================================================
  // generateUniqueBranchName Tests
  // ===========================================================================

  describe('generateUniqueBranchName', () => {
    it('should return base name when branch does not exist', async () => {
      // Mock branchExists to always return false
      client.branchExists = () => Promise.resolve(false);

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      expect(name).toBe('martin-purplefish/jaguar');
    });

    it('should append -1 when base branch exists', async () => {
      let callCount = 0;
      client.branchExists = (_branchName: string) => {
        callCount++;
        // First call: base name exists
        if (callCount === 1) {
          return Promise.resolve(true);
        }
        // Second call: -1 doesn't exist
        return Promise.resolve(false);
      };

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      expect(name).toBe('martin-purplefish/jaguar-1');
    });

    it('should increment until finding available name', async () => {
      const existingNames = new Set([
        'martin-purplefish/jaguar',
        'martin-purplefish/jaguar-1',
        'martin-purplefish/jaguar-2',
      ]);

      client.branchExists = (branchName: string) => Promise.resolve(existingNames.has(branchName));

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      expect(name).toBe('martin-purplefish/jaguar-3');
    });

    it('should work without prefix', async () => {
      let callCount = 0;
      client.branchExists = () => {
        callCount++;
        return Promise.resolve(callCount === 1); // First one exists, second doesn't
      };

      const name = await client.generateUniqueBranchName(undefined, 'jaguar');
      expect(name).toBe('jaguar-1');
    });

    it('should fallback to random hex after 1000 attempts', async () => {
      // All branches exist
      client.branchExists = () => Promise.resolve(true);

      const name = await client.generateUniqueBranchName('martin-purplefish', 'jaguar');
      // Should fallback to random 12-character hex
      expect(name).toMatch(/^martin-purplefish\/[0-9a-f]{12}$/);
    });

    it('should handle auto-generated names (no workspace name)', async () => {
      client.branchExists = () => Promise.resolve(false);

      const name = await client.generateUniqueBranchName('martin-purplefish');
      // Should be prefix + 6 hex chars
      expect(name).toMatch(/^martin-purplefish\/[0-9a-f]{6}$/);
    });
  });
});

// =============================================================================
// isAutoGeneratedBranchName Tests
// =============================================================================

describe('isAutoGeneratedBranchName', () => {
  describe('hex-only branches (no prefix)', () => {
    it('should match 6 hex characters', () => {
      expect(isAutoGeneratedBranchName('abc123')).toBe(true);
      expect(isAutoGeneratedBranchName('000000')).toBe(true);
      expect(isAutoGeneratedBranchName('ffffff')).toBe(true);
      expect(isAutoGeneratedBranchName('a1b2c3')).toBe(true);
    });

    it('should not match non-hex characters that are not workspace words', () => {
      expect(isAutoGeneratedBranchName('ghijkl')).toBe(false);
      expect(isAutoGeneratedBranchName('xyz123')).toBe(false);
      expect(isAutoGeneratedBranchName('ABCDEF')).toBe(false); // uppercase not hex
    });

    it('should not match wrong length hex', () => {
      expect(isAutoGeneratedBranchName('abc12')).toBe(false); // 5 chars
      expect(isAutoGeneratedBranchName('abc1234')).toBe(false); // 7 chars
      expect(isAutoGeneratedBranchName('')).toBe(false);
    });
  });

  describe('prefixed branches with hex (single segment)', () => {
    it('should match single-segment prefix with 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('martin-purplefish/abc123')).toBe(true);
      expect(isAutoGeneratedBranchName('user/ffffff')).toBe(true);
      expect(isAutoGeneratedBranchName('feature/000000')).toBe(true);
    });

    it('should not match single-segment prefix with non-hex, non-workspace-word suffix', () => {
      expect(isAutoGeneratedBranchName('prefix/notahex')).toBe(false);
      expect(isAutoGeneratedBranchName('prefix/abc12g')).toBe(false);
    });
  });

  describe('prefixed branches with hex (multi-segment)', () => {
    it('should match multi-segment prefix with 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('user-name/feature/abc123')).toBe(true);
      expect(isAutoGeneratedBranchName('a/b/c/d/e/ffffff')).toBe(true);
      expect(isAutoGeneratedBranchName('org/team/project/000000')).toBe(true);
    });

    it('should not match multi-segment prefix with non-hex, non-workspace-word suffix', () => {
      expect(isAutoGeneratedBranchName('user/feature/notahex')).toBe(false);
      expect(isAutoGeneratedBranchName('a/b/c/ABCDEF')).toBe(false); // uppercase
    });
  });

  describe('workspace word branches (no prefix)', () => {
    it('should match workspace words without numeric suffix', () => {
      expect(isAutoGeneratedBranchName('tiger')).toBe(true);
      expect(isAutoGeneratedBranchName('falcon')).toBe(true);
      expect(isAutoGeneratedBranchName('pulse')).toBe(true);
      expect(isAutoGeneratedBranchName('flux')).toBe(true);
      expect(isAutoGeneratedBranchName('nova')).toBe(true);
      expect(isAutoGeneratedBranchName('thunder')).toBe(true);
    });

    it('should match workspace words with numeric suffix', () => {
      expect(isAutoGeneratedBranchName('tiger-1')).toBe(true);
      expect(isAutoGeneratedBranchName('pulse-2')).toBe(true);
      expect(isAutoGeneratedBranchName('flux-42')).toBe(true);
      expect(isAutoGeneratedBranchName('nova-999')).toBe(true);
    });
  });

  describe('prefixed workspace word branches', () => {
    it('should match prefixed workspace words without numeric suffix', () => {
      expect(isAutoGeneratedBranchName('adeeshaek/pulse')).toBe(true);
      expect(isAutoGeneratedBranchName('martin-purplefish/tiger')).toBe(true);
      expect(isAutoGeneratedBranchName('user/falcon')).toBe(true);
      expect(isAutoGeneratedBranchName('org/team/nova')).toBe(true);
    });

    it('should match prefixed workspace words with numeric suffix', () => {
      expect(isAutoGeneratedBranchName('adeeshaek/pulse-1')).toBe(true);
      expect(isAutoGeneratedBranchName('martin-purplefish/tiger-5')).toBe(true);
      expect(isAutoGeneratedBranchName('user/flux-99')).toBe(true);
      expect(isAutoGeneratedBranchName('org/team/project/dragon-2')).toBe(true);
    });
  });

  describe('non-matching branches (meaningful names)', () => {
    it('should not match meaningful branch names', () => {
      expect(isAutoGeneratedBranchName('main')).toBe(false);
      expect(isAutoGeneratedBranchName('develop')).toBe(false);
      expect(isAutoGeneratedBranchName('feature/add-login')).toBe(false);
      expect(isAutoGeneratedBranchName('martin-purplefish/fix-bug-123')).toBe(false);
      expect(isAutoGeneratedBranchName('hotfix/security-patch')).toBe(false);
    });

    it('should not match branches with descriptive names after rename', () => {
      // These are branches that have been renamed from auto-generated to meaningful
      expect(isAutoGeneratedBranchName('adeeshaek/add-user-auth')).toBe(false);
      expect(isAutoGeneratedBranchName('user/implement-caching')).toBe(false);
      expect(isAutoGeneratedBranchName('feature/refactor-api')).toBe(false);
    });

    it('should not match branches ending with more than 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('prefix/abc1234')).toBe(false); // 7 chars
      expect(isAutoGeneratedBranchName('prefix/abc12345678')).toBe(false);
    });

    it('should not match branches ending with fewer than 6 hex chars', () => {
      expect(isAutoGeneratedBranchName('prefix/abc12')).toBe(false); // 5 chars
      expect(isAutoGeneratedBranchName('prefix/abc')).toBe(false);
    });
  });

  describe('edge cases', () => {
    it('should not match empty string', () => {
      expect(isAutoGeneratedBranchName('')).toBe(false);
    });

    it('should not match just a slash', () => {
      expect(isAutoGeneratedBranchName('/')).toBe(false);
      expect(isAutoGeneratedBranchName('/abc123')).toBe(false); // empty prefix
    });

    it('should not match trailing slash', () => {
      expect(isAutoGeneratedBranchName('abc123/')).toBe(false);
      expect(isAutoGeneratedBranchName('prefix/abc123/')).toBe(false);
    });

    it('should not match workspace words with non-numeric suffixes', () => {
      // "pulse-foo" is not auto-generated - it has a meaningful suffix
      expect(isAutoGeneratedBranchName('pulse-foo')).toBe(false);
      expect(isAutoGeneratedBranchName('tiger-feature')).toBe(false);
      expect(isAutoGeneratedBranchName('adeeshaek/flux-update')).toBe(false);
    });

    it('should not match partial workspace words', () => {
      expect(isAutoGeneratedBranchName('tig')).toBe(false); // partial "tiger"
      expect(isAutoGeneratedBranchName('puls')).toBe(false); // partial "pulse"
    });
  });
});

// =============================================================================
// GitClientFactory Tests
// =============================================================================

describe('GitClientFactory', () => {
  afterEach(() => {
    GitClientFactory.clearCache();
  });

  describe('forProject', () => {
    it('should create a new client for a project', () => {
      const client = GitClientFactory.forProject({
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees',
      });

      expect(client).toBeInstanceOf(GitClient);
    });

    it('should return cached client for same project', () => {
      const project = {
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees',
      };

      const client1 = GitClientFactory.forProject(project);
      const client2 = GitClientFactory.forProject(project);

      expect(client1).toBe(client2);
    });

    it('should create different clients for different projects', () => {
      const client1 = GitClientFactory.forProject({
        repoPath: '/test/repo1',
        worktreeBasePath: '/test/worktrees1',
      });
      const client2 = GitClientFactory.forProject({
        repoPath: '/test/repo2',
        worktreeBasePath: '/test/worktrees2',
      });

      expect(client1).not.toBe(client2);
    });

    it('should differentiate by repoPath', () => {
      const client1 = GitClientFactory.forProject({
        repoPath: '/test/repo1',
        worktreeBasePath: '/test/worktrees',
      });
      const client2 = GitClientFactory.forProject({
        repoPath: '/test/repo2',
        worktreeBasePath: '/test/worktrees',
      });

      expect(client1).not.toBe(client2);
    });

    it('should differentiate by worktreeBasePath', () => {
      const client1 = GitClientFactory.forProject({
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees1',
      });
      const client2 = GitClientFactory.forProject({
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees2',
      });

      expect(client1).not.toBe(client2);
    });
  });

  describe('removeProject', () => {
    it('should remove cached client', () => {
      const project = {
        repoPath: '/test/repo',
        worktreeBasePath: '/test/worktrees',
      };

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);

      const removed = GitClientFactory.removeProject(project);
      expect(removed).toBe(true);
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should return false if project not cached', () => {
      const removed = GitClientFactory.removeProject({
        repoPath: '/nonexistent',
        worktreeBasePath: '/nonexistent',
      });

      expect(removed).toBe(false);
    });

    it('should only remove the specified project', () => {
      const project1 = { repoPath: '/repo1', worktreeBasePath: '/wt1' };
      const project2 = { repoPath: '/repo2', worktreeBasePath: '/wt2' };

      GitClientFactory.forProject(project1);
      GitClientFactory.forProject(project2);
      expect(GitClientFactory.cacheSize).toBe(2);

      GitClientFactory.removeProject(project1);
      expect(GitClientFactory.cacheSize).toBe(1);

      // project2 should still be cached
      const client = GitClientFactory.forProject(project2);
      expect(client).toBeInstanceOf(GitClient);
    });
  });

  describe('clearCache', () => {
    it('should clear all cached clients', () => {
      GitClientFactory.forProject({ repoPath: '/repo1', worktreeBasePath: '/wt1' });
      GitClientFactory.forProject({ repoPath: '/repo2', worktreeBasePath: '/wt2' });
      GitClientFactory.forProject({ repoPath: '/repo3', worktreeBasePath: '/wt3' });

      expect(GitClientFactory.cacheSize).toBe(3);

      GitClientFactory.clearCache();
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should work on empty cache', () => {
      expect(GitClientFactory.cacheSize).toBe(0);
      GitClientFactory.clearCache();
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should allow new clients to be created after clear', () => {
      const project = { repoPath: '/repo', worktreeBasePath: '/wt' };

      const client1 = GitClientFactory.forProject(project);
      GitClientFactory.clearCache();
      const client2 = GitClientFactory.forProject(project);

      // Should be different instances since cache was cleared
      expect(client1).not.toBe(client2);
    });
  });

  describe('cacheSize', () => {
    it('should return 0 for empty cache', () => {
      expect(GitClientFactory.cacheSize).toBe(0);
    });

    it('should return correct count after adding clients', () => {
      GitClientFactory.forProject({ repoPath: '/repo1', worktreeBasePath: '/wt1' });
      expect(GitClientFactory.cacheSize).toBe(1);

      GitClientFactory.forProject({ repoPath: '/repo2', worktreeBasePath: '/wt2' });
      expect(GitClientFactory.cacheSize).toBe(2);

      GitClientFactory.forProject({ repoPath: '/repo3', worktreeBasePath: '/wt3' });
      expect(GitClientFactory.cacheSize).toBe(3);
    });

    it('should not increase when getting same project', () => {
      const project = { repoPath: '/repo', worktreeBasePath: '/wt' };

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);

      GitClientFactory.forProject(project);
      expect(GitClientFactory.cacheSize).toBe(1);
    });
  });
});

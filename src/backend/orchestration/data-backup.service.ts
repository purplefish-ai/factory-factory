/**
 * Data Backup Service
 *
 * Handles export and import of database data for backup/restore purposes.
 * Used when database migrations require a reset.
 */

import type { Prisma } from '@prisma-gen/client';
import type { z } from 'zod';
import {
  type DataBackupTransactionClient,
  dataBackupAccessor,
} from '@/backend/resource_accessors/data-backup.accessor';
import { createLogger } from '@/backend/services/logger.service';
import type {
  ExportData,
  exportedAgentSessionSchema,
  exportedProjectSchema,
  exportedTerminalSessionSchema,
  exportedUserSettingsSchema,
  exportedWorkspaceSchema,
} from '@/shared/schemas/export-data.schema';

type TransactionClient = DataBackupTransactionClient;

const logger = createLogger('data-backup');

// ============================================================================
// Types
// ============================================================================

export interface ImportCounter {
  imported: number;
  skipped: number;
}

export interface ImportResults {
  projects: ImportCounter;
  workspaces: ImportCounter;
  agentSessions: ImportCounter;
  terminalSessions: ImportCounter;
  userSettings: { imported: boolean; skipped: boolean };
}

// Internal types extracted from schemas (using explicit exports instead of Zod internals)
type ExportedProject = z.infer<typeof exportedProjectSchema>;
type ExportedWorkspace = z.infer<typeof exportedWorkspaceSchema>;
type ExportedAgentSession = z.infer<typeof exportedAgentSessionSchema>;
type ExportedTerminalSession = z.infer<typeof exportedTerminalSessionSchema>;
type ExportedUserSettings = z.infer<typeof exportedUserSettingsSchema>;

// ============================================================================
// Helpers
// ============================================================================

const toISOString = (date: Date | null): string | null => (date ? date.toISOString() : null);
const parseDate = (str: string | null): Date | null => (str ? new Date(str) : null);

// ============================================================================
// Import Functions
// ============================================================================

async function importProjects(
  projects: ExportedProject[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const p of projects) {
    const existing = await tx.project.findUnique({ where: { id: p.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const slugConflict = await tx.project.findUnique({ where: { slug: p.slug } });
    if (slugConflict) {
      logger.warn('Skipping project due to slug conflict', { id: p.id, slug: p.slug });
      counter.skipped++;
      continue;
    }

    await tx.project.create({
      data: {
        id: p.id,
        name: p.name,
        slug: p.slug,
        repoPath: p.repoPath,
        worktreeBasePath: p.worktreeBasePath,
        defaultBranch: p.defaultBranch,
        githubOwner: p.githubOwner,
        githubRepo: p.githubRepo,
        isArchived: p.isArchived,
        startupScriptCommand: p.startupScriptCommand,
        startupScriptPath: p.startupScriptPath,
        startupScriptTimeout: p.startupScriptTimeout,
        createdAt: new Date(p.createdAt),
        updatedAt: new Date(p.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importWorkspaces(
  workspaces: ExportedWorkspace[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const workspace of workspaces) {
    const existing = await tx.workspace.findUnique({ where: { id: workspace.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const project = await tx.project.findUnique({ where: { id: workspace.projectId } });
    if (!project) {
      logger.warn('Skipping workspace due to missing project', {
        workspaceId: workspace.id,
        projectId: workspace.projectId,
      });
      counter.skipped++;
      continue;
    }

    await tx.workspace.create({
      data: {
        id: workspace.id,
        projectId: workspace.projectId,
        name: workspace.name,
        description: workspace.description,
        status: workspace.status,
        worktreePath: workspace.worktreePath,
        branchName: workspace.branchName,
        isAutoGeneratedBranch: workspace.isAutoGeneratedBranch,
        creationSource: workspace.creationSource,
        creationMetadata:
          workspace.creationMetadata != null
            ? (workspace.creationMetadata as Prisma.InputJsonValue)
            : undefined,
        initErrorMessage: workspace.initErrorMessage,
        initOutput: workspace.initOutput,
        initStartedAt: parseDate(workspace.initStartedAt),
        initCompletedAt: parseDate(workspace.initCompletedAt),
        initRetryCount: workspace.initRetryCount,
        runScriptCommand: workspace.runScriptCommand,
        runScriptCleanupCommand: workspace.runScriptCleanupCommand,
        runScriptPid: workspace.runScriptPid,
        runScriptPort: workspace.runScriptPort,
        runScriptStartedAt: parseDate(workspace.runScriptStartedAt),
        runScriptStatus: workspace.runScriptStatus,
        prUrl: workspace.prUrl,
        githubIssueNumber: workspace.githubIssueNumber,
        githubIssueUrl: workspace.githubIssueUrl,
        defaultSessionProvider: workspace.defaultSessionProvider,
        ratchetSessionProvider: workspace.ratchetSessionProvider,
        prNumber: workspace.prNumber,
        prState: workspace.prState,
        prReviewState: workspace.prReviewState,
        prCiStatus: workspace.prCiStatus,
        prUpdatedAt: parseDate(workspace.prUpdatedAt),
        prCiFailedAt: parseDate(workspace.prCiFailedAt),
        prCiLastNotifiedAt: parseDate(workspace.prCiLastNotifiedAt),
        // Phase 3+ PR review tracking fields
        prReviewLastCheckedAt: parseDate(workspace.prReviewLastCheckedAt),
        prReviewLastCommentId: workspace.prReviewLastCommentId,
        // Phase 3+ ratchet fields
        ratchetEnabled: workspace.ratchetEnabled,
        ratchetState: workspace.ratchetState,
        ratchetLastCheckedAt: parseDate(workspace.ratchetLastCheckedAt),
        ratchetActiveSessionId: workspace.ratchetActiveSessionId,
        ratchetLastCiRunId: workspace.ratchetLastCiRunId,
        hasHadSessions: workspace.hasHadSessions,
        cachedKanbanColumn: workspace.cachedKanbanColumn,
        stateComputedAt: parseDate(workspace.stateComputedAt),
        createdAt: new Date(workspace.createdAt),
        updatedAt: new Date(workspace.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importAgentSessions(
  sessions: ExportedAgentSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.agentSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping agent session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.agentSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        workflow: s.workflow,
        model: s.model,
        status: s.status,
        provider: s.provider,
        providerSessionId: s.providerSessionId,
        providerProjectPath: s.providerProjectPath,
        providerProcessPid: s.providerProcessPid,
        providerMetadata:
          s.providerMetadata != null ? (s.providerMetadata as Prisma.InputJsonValue) : undefined,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importTerminalSessions(
  sessions: ExportedTerminalSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.terminalSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping terminal session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.terminalSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        status: s.status,
        pid: s.pid,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importUserSettings(
  settings: ExportedUserSettings | null,
  tx: TransactionClient
): Promise<{ imported: boolean; skipped: boolean }> {
  if (!settings) {
    return { imported: false, skipped: false };
  }

  const existing = await tx.userSettings.findFirst({ where: { userId: 'default' } });
  if (existing) {
    return { imported: false, skipped: true };
  }

  await tx.userSettings.create({
    data: {
      userId: 'default',
      preferredIde: settings.preferredIde,
      customIdeCommand: settings.customIdeCommand,
      playSoundOnComplete: settings.playSoundOnComplete,
      notificationSoundPath: settings.notificationSoundPath,
      // Ratchet settings
      ratchetEnabled: settings.ratchetEnabled,
      defaultSessionProvider: settings.defaultSessionProvider,
      // Note: workspaceOrder and cachedSlashCommands are intentionally not imported
      // as they are rebuild-able cache data
    },
  });

  return { imported: true, skipped: false };
}

// ============================================================================
// Service Class
// ============================================================================

class DataBackupService {
  /**
   * Export all data for backup/migration.
   * Exports projects, workspaces, sessions, and user preferences.
   * Excludes cached data (workspaceOrder, cachedSlashCommands) which will rebuild.
   * Exports in schema version 3 format.
   */
  async exportData(appVersion: string): Promise<ExportData> {
    logger.info('Exporting database data');

    // Fetch all data
    const { projects, workspaces, agentSessions, terminalSessions, userSettings } =
      await dataBackupAccessor.getSnapshotForExport();

    const exportData: ExportData = {
      meta: {
        exportedAt: new Date().toISOString(),
        version: appVersion,
        schemaVersion: 3,
      },
      data: {
        projects: projects.map((p) => ({
          id: p.id,
          name: p.name,
          slug: p.slug,
          repoPath: p.repoPath,
          worktreeBasePath: p.worktreeBasePath,
          defaultBranch: p.defaultBranch,
          githubOwner: p.githubOwner,
          githubRepo: p.githubRepo,
          isArchived: p.isArchived,
          startupScriptCommand: p.startupScriptCommand,
          startupScriptPath: p.startupScriptPath,
          startupScriptTimeout: p.startupScriptTimeout,
          createdAt: p.createdAt.toISOString(),
          updatedAt: p.updatedAt.toISOString(),
        })),
        workspaces: workspaces.map((w) => ({
          id: w.id,
          projectId: w.projectId,
          name: w.name,
          description: w.description,
          status: w.status,
          worktreePath: w.worktreePath,
          branchName: w.branchName,
          isAutoGeneratedBranch: w.isAutoGeneratedBranch,
          creationSource: w.creationSource,
          creationMetadata: w.creationMetadata,
          initErrorMessage: w.initErrorMessage,
          initOutput: w.initOutput,
          initStartedAt: toISOString(w.initStartedAt),
          initCompletedAt: toISOString(w.initCompletedAt),
          initRetryCount: w.initRetryCount,
          runScriptCommand: w.runScriptCommand,
          runScriptCleanupCommand: w.runScriptCleanupCommand,
          runScriptPid: w.runScriptPid,
          runScriptPort: w.runScriptPort,
          runScriptStartedAt: toISOString(w.runScriptStartedAt),
          runScriptStatus: w.runScriptStatus,
          prUrl: w.prUrl,
          githubIssueNumber: w.githubIssueNumber,
          githubIssueUrl: w.githubIssueUrl,
          defaultSessionProvider: w.defaultSessionProvider,
          ratchetSessionProvider: w.ratchetSessionProvider,
          prNumber: w.prNumber,
          prState: w.prState,
          prReviewState: w.prReviewState,
          prCiStatus: w.prCiStatus,
          prUpdatedAt: toISOString(w.prUpdatedAt),
          prCiFailedAt: toISOString(w.prCiFailedAt),
          prCiLastNotifiedAt: toISOString(w.prCiLastNotifiedAt),
          // Phase 3+ PR review tracking fields
          prReviewLastCheckedAt: toISOString(w.prReviewLastCheckedAt),
          prReviewLastCommentId: w.prReviewLastCommentId,
          // Phase 3+ ratchet tracking fields
          ratchetEnabled: w.ratchetEnabled,
          ratchetState: w.ratchetState,
          ratchetLastCheckedAt: toISOString(w.ratchetLastCheckedAt),
          ratchetActiveSessionId: w.ratchetActiveSessionId,
          ratchetLastCiRunId: w.ratchetLastCiRunId,
          hasHadSessions: w.hasHadSessions,
          cachedKanbanColumn: w.cachedKanbanColumn,
          stateComputedAt: toISOString(w.stateComputedAt),
          createdAt: w.createdAt.toISOString(),
          updatedAt: w.updatedAt.toISOString(),
        })),
        agentSessions: agentSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          workflow: s.workflow,
          model: s.model,
          status: s.status,
          provider: s.provider,
          providerSessionId: s.providerSessionId,
          providerProjectPath: s.providerProjectPath,
          providerProcessPid: s.providerProcessPid,
          providerMetadata: s.providerMetadata,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        terminalSessions: terminalSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          status: s.status,
          pid: s.pid,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        userSettings: userSettings
          ? {
              preferredIde: userSettings.preferredIde,
              customIdeCommand: userSettings.customIdeCommand,
              playSoundOnComplete: userSettings.playSoundOnComplete,
              notificationSoundPath: userSettings.notificationSoundPath,
              // Ratchet settings
              ratchetEnabled: userSettings.ratchetEnabled,
              defaultSessionProvider: userSettings.defaultSessionProvider,
              // Note: workspaceOrder and cachedSlashCommands are intentionally excluded
              // as they are rebuild-able cache data (per design doc)
            }
          : null,
      },
    };

    logger.info('Export completed', {
      projectCount: projects.length,
      workspaceCount: workspaces.length,
      agentSessionCount: agentSessions.length,
      terminalSessionCount: terminalSessions.length,
    });

    return exportData;
  }

  /**
   * Import data from a backup file.
   * Accepts strict schema version 3 payloads only.
   * Skips records that already exist (by ID).
   * Returns counts of imported/skipped records.
   * All imports are wrapped in a transaction for atomicity.
   */
  async importData(input: ExportData): Promise<ImportResults> {
    logger.info('Starting data import', {
      schemaVersion: input.meta.schemaVersion,
      exportedAt: input.meta.exportedAt,
      projectCount: input.data.projects.length,
      workspaceCount: input.data.workspaces.length,
    });

    // Import in dependency order within a transaction for atomicity
    const results = await dataBackupAccessor.runInTransaction(async (tx) => {
      const projects = await importProjects(input.data.projects, tx);
      const workspaces = await importWorkspaces(input.data.workspaces, tx);
      const agentSessions = await importAgentSessions(input.data.agentSessions, tx);
      const terminalSessions = await importTerminalSessions(input.data.terminalSessions, tx);
      const userSettings = await importUserSettings(input.data.userSettings, tx);

      return {
        projects,
        workspaces,
        agentSessions,
        terminalSessions,
        userSettings,
      };
    });

    logger.info('Import completed', {
      schemaVersion: input.meta.schemaVersion,
      projects: results.projects,
      workspaces: results.workspaces,
      agentSessions: results.agentSessions,
      terminalSessions: results.terminalSessions,
    });

    return results;
  }
}

// Export singleton instance
export const dataBackupService = new DataBackupService();

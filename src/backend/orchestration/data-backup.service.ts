/**
 * Data Backup Service
 *
 * Handles export and import of database data for backup/restore purposes.
 * Used when database migrations require a reset.
 */

import { RatchetState, RunScriptStatus } from '@factory-factory/core';
import type { Prisma } from '@prisma-gen/client';
import type { z } from 'zod';
import {
  type DataBackupTransactionClient,
  dataBackupAccessor,
} from '@/backend/resource_accessors/data-backup.accessor';
import { createLogger } from '@/backend/services/logger.service';
import type {
  ExportData,
  ExportDataV1,
  ExportDataV2,
  exportedClaudeSessionSchema,
  exportedProjectSchema,
  exportedTerminalSessionSchema,
  exportedUserSettingsSchemaV1,
  exportedUserSettingsSchemaV2,
  exportedWorkspaceSchemaV1,
  exportedWorkspaceSchemaV2,
} from '@/shared/schemas/export-data.schema';

type TransactionClient = DataBackupTransactionClient;

const logger = createLogger('data-backup');

// ============================================================================
// Types
// ============================================================================

export interface ImportCounter {
  imported: number;
  skipped: number;
}

export interface ImportResults {
  projects: ImportCounter;
  workspaces: ImportCounter;
  claudeSessions: ImportCounter;
  terminalSessions: ImportCounter;
  userSettings: { imported: boolean; skipped: boolean };
}

// Internal types extracted from schemas (using explicit exports instead of Zod internals)
type ExportedProject = z.infer<typeof exportedProjectSchema>;
type ExportedWorkspaceV1 = z.infer<typeof exportedWorkspaceSchemaV1>;
type ExportedWorkspaceV2 = z.infer<typeof exportedWorkspaceSchemaV2>;
type ExportedClaudeSession = z.infer<typeof exportedClaudeSessionSchema>;
type ExportedTerminalSession = z.infer<typeof exportedTerminalSessionSchema>;
type ExportedUserSettingsV1 = z.infer<typeof exportedUserSettingsSchemaV1>;
type ExportedUserSettingsV2 = z.infer<typeof exportedUserSettingsSchemaV2>;

function normalizeRunScriptStatus(
  status: z.infer<typeof exportedWorkspaceSchemaV1.shape.runScriptStatus>
): RunScriptStatus {
  return status === 'PAUSED' ? RunScriptStatus.IDLE : status;
}

/**
 * Migrates v1 workspace data to v2 format by adding default values for new fields.
 * Uses ?? to preserve any existing v2 fields in forward-filled/mixed backups.
 */
function migrateWorkspaceV1ToV2(
  v1:
    | ExportedWorkspaceV1
    | (ExportedWorkspaceV1 & Partial<ExportedWorkspaceV2>)
    | (ExportedWorkspaceV2 & Partial<ExportedWorkspaceV1>)
): ExportedWorkspaceV2 {
  const partial = v1 as Partial<ExportedWorkspaceV2>;
  return {
    ...v1,
    // Set defaults for Phase 3 creation tracking fields
    isAutoGeneratedBranch: v1.isAutoGeneratedBranch ?? false,
    creationSource: v1.creationSource ?? 'MANUAL',
    creationMetadata: v1.creationMetadata ?? null,
    // Set defaults for Phase 3+ PR review tracking fields (preserve if present)
    prReviewLastCheckedAt: partial.prReviewLastCheckedAt ?? null,
    prReviewLastCommentId: partial.prReviewLastCommentId ?? null,
    // Set defaults for Phase 3+ ratchet fields (preserve if present)
    ratchetEnabled: partial.ratchetEnabled ?? true, // Default to enabled (matches schema default)
    ratchetState: partial.ratchetState ?? RatchetState.IDLE,
    ratchetLastCheckedAt: partial.ratchetLastCheckedAt ?? null,
    ratchetLastPushAt: partial.ratchetLastPushAt ?? null,
    ratchetActiveSessionId: partial.ratchetActiveSessionId ?? null,
    ratchetLastCiRunId: partial.ratchetLastCiRunId ?? null,
    ratchetLastNotifiedState: partial.ratchetLastNotifiedState ?? null,
  };
}

/**
 * Migrates v1 user settings to v2 format by adding default values for new fields.
 * Uses ?? to preserve any existing v2 fields in forward-filled/mixed backups.
 * Note: ratchetAutoFixCi, ratchetAutoFixReviews, ratchetAutoMerge, and ratchetAllowedReviewers
 * were removed in later versions but are preserved here for backward compatibility with old exports.
 */
function migrateUserSettingsV1ToV2(
  v1:
    | ExportedUserSettingsV1
    | (ExportedUserSettingsV1 & Partial<ExportedUserSettingsV2> & Record<string, unknown>)
    | (ExportedUserSettingsV2 & Partial<ExportedUserSettingsV1> & Record<string, unknown>)
): ExportedUserSettingsV2 {
  const partial = v1 as Partial<ExportedUserSettingsV2> & Record<string, unknown>;
  return {
    ...v1,
    // Set defaults for Phase 3+ ratchet settings (preserve if present, match schema defaults)
    ratchetEnabled: partial.ratchetEnabled ?? false,
    // The following fields were removed from the schema but are kept here for importing old backups
    // They will be ignored when creating the UserSettings record
  };
}

// ============================================================================
// Helpers
// ============================================================================

const toISOString = (date: Date | null): string | null => (date ? date.toISOString() : null);
const parseDate = (str: string | null): Date | null => (str ? new Date(str) : null);

/**
 * Ensures v2 workspace has all required fields and defaults for optional fields.
 * Validates that claimed v2 data actually has v2 fields to prevent runtime errors.
 */
function ensureWorkspaceV2Defaults(w: ExportedWorkspaceV2): ExportedWorkspaceV2 {
  // Validate all required v2 fields are present (not undefined)
  const missingRequired =
    w.ratchetEnabled === undefined ||
    w.ratchetState === undefined ||
    w.prReviewLastCheckedAt === undefined ||
    w.prReviewLastCommentId === undefined;

  if (missingRequired) {
    logger.warn('V2 workspace missing required v2 fields, applying migration', {
      workspaceId: w.id,
      hasRatchetEnabled: w.ratchetEnabled !== undefined,
      hasRatchetState: w.ratchetState !== undefined,
      hasPrReviewLastCheckedAt: w.prReviewLastCheckedAt !== undefined,
      hasPrReviewLastCommentId: w.prReviewLastCommentId !== undefined,
    });
    // Fallback to migration if required fields are missing
    return migrateWorkspaceV1ToV2(w);
  }

  // Ensure optional Phase 3 fields have defaults
  return {
    ...w,
    isAutoGeneratedBranch: w.isAutoGeneratedBranch ?? false,
    creationSource: w.creationSource ?? 'MANUAL',
    creationMetadata: w.creationMetadata ?? null,
  };
}

/**
 * Ensures v2 user settings has all required fields.
 * Validates that claimed v2 data actually has v2 fields to prevent runtime errors.
 */
function ensureUserSettingsV2Defaults(s: ExportedUserSettingsV2): ExportedUserSettingsV2 {
  // Validate required v2 fields are present (not undefined)
  if (s.ratchetEnabled === undefined) {
    logger.warn('V2 user settings missing required ratchet fields, applying migration', {
      hasRatchetEnabled: s.ratchetEnabled !== undefined,
    });
    // Fallback to migration if required fields are missing
    return migrateUserSettingsV1ToV2(s);
  }

  return s;
}

// ============================================================================
// Import Functions
// ============================================================================

async function importProjects(
  projects: ExportedProject[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const p of projects) {
    const existing = await tx.project.findUnique({ where: { id: p.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const slugConflict = await tx.project.findUnique({ where: { slug: p.slug } });
    if (slugConflict) {
      logger.warn('Skipping project due to slug conflict', { id: p.id, slug: p.slug });
      counter.skipped++;
      continue;
    }

    await tx.project.create({
      data: {
        id: p.id,
        name: p.name,
        slug: p.slug,
        repoPath: p.repoPath,
        worktreeBasePath: p.worktreeBasePath,
        defaultBranch: p.defaultBranch,
        githubOwner: p.githubOwner,
        githubRepo: p.githubRepo,
        isArchived: p.isArchived,
        startupScriptCommand: p.startupScriptCommand,
        startupScriptPath: p.startupScriptPath,
        startupScriptTimeout: p.startupScriptTimeout,
        createdAt: new Date(p.createdAt),
        updatedAt: new Date(p.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importWorkspaces(
  workspaces: Array<ExportedWorkspaceV1 | ExportedWorkspaceV2>,
  schemaVersion: number,
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const workspace of workspaces) {
    const existing = await tx.workspace.findUnique({ where: { id: workspace.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const project = await tx.project.findUnique({ where: { id: workspace.projectId } });
    if (!project) {
      logger.warn('Skipping workspace due to missing project', {
        workspaceId: workspace.id,
        projectId: workspace.projectId,
      });
      counter.skipped++;
      continue;
    }

    // Migrate v1 to v2 if needed (based on schema version from meta)
    // For v2, also ensure optional fields have defaults and validate required v2 fields
    const w: ExportedWorkspaceV2 =
      schemaVersion >= 2
        ? ensureWorkspaceV2Defaults(workspace as ExportedWorkspaceV2)
        : migrateWorkspaceV1ToV2(workspace);

    await tx.workspace.create({
      data: {
        id: w.id,
        projectId: w.projectId,
        name: w.name,
        description: w.description,
        status: w.status,
        worktreePath: w.worktreePath,
        branchName: w.branchName,
        isAutoGeneratedBranch: w.isAutoGeneratedBranch ?? false,
        creationSource: w.creationSource ?? 'MANUAL',
        creationMetadata:
          w.creationMetadata != null ? (w.creationMetadata as Prisma.InputJsonValue) : undefined,
        initErrorMessage: w.initErrorMessage,
        initOutput: w.initOutput,
        initStartedAt: parseDate(w.initStartedAt),
        initCompletedAt: parseDate(w.initCompletedAt),
        initRetryCount: w.initRetryCount,
        runScriptCommand: w.runScriptCommand,
        runScriptCleanupCommand: w.runScriptCleanupCommand,
        runScriptPid: w.runScriptPid,
        runScriptPort: w.runScriptPort,
        runScriptStartedAt: parseDate(w.runScriptStartedAt),
        runScriptStatus: normalizeRunScriptStatus(w.runScriptStatus),
        prUrl: w.prUrl,
        githubIssueNumber: w.githubIssueNumber,
        githubIssueUrl: w.githubIssueUrl,
        prNumber: w.prNumber,
        prState: w.prState,
        prReviewState: w.prReviewState,
        prCiStatus: w.prCiStatus,
        prUpdatedAt: parseDate(w.prUpdatedAt),
        prCiFailedAt: parseDate(w.prCiFailedAt),
        prCiLastNotifiedAt: parseDate(w.prCiLastNotifiedAt),
        // Phase 3+ PR review tracking fields
        prReviewLastCheckedAt: parseDate(w.prReviewLastCheckedAt),
        prReviewLastCommentId: w.prReviewLastCommentId,
        // Phase 3+ ratchet fields
        ratchetEnabled: w.ratchetEnabled,
        ratchetState: w.ratchetState,
        ratchetLastCheckedAt: parseDate(w.ratchetLastCheckedAt),
        ratchetLastPushAt: parseDate(w.ratchetLastPushAt),
        ratchetActiveSessionId: w.ratchetActiveSessionId,
        ratchetLastCiRunId: w.ratchetLastCiRunId,
        ratchetLastNotifiedState: w.ratchetLastNotifiedState,
        hasHadSessions: w.hasHadSessions,
        cachedKanbanColumn: w.cachedKanbanColumn,
        stateComputedAt: parseDate(w.stateComputedAt),
        createdAt: new Date(w.createdAt),
        updatedAt: new Date(w.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importClaudeSessions(
  sessions: ExportedClaudeSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.claudeSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping claude session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.claudeSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        workflow: s.workflow,
        model: s.model,
        status: s.status,
        claudeSessionId: s.claudeSessionId,
        claudeProjectPath: s.claudeProjectPath,
        claudeProcessPid: s.claudeProcessPid,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importTerminalSessions(
  sessions: ExportedTerminalSession[],
  tx: TransactionClient
): Promise<ImportCounter> {
  const counter: ImportCounter = { imported: 0, skipped: 0 };

  for (const s of sessions) {
    const existing = await tx.terminalSession.findUnique({ where: { id: s.id } });
    if (existing) {
      counter.skipped++;
      continue;
    }

    const workspace = await tx.workspace.findUnique({ where: { id: s.workspaceId } });
    if (!workspace) {
      logger.warn('Skipping terminal session due to missing workspace', {
        sessionId: s.id,
        workspaceId: s.workspaceId,
      });
      counter.skipped++;
      continue;
    }

    await tx.terminalSession.create({
      data: {
        id: s.id,
        workspaceId: s.workspaceId,
        name: s.name,
        status: s.status,
        pid: s.pid,
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
      },
    });
    counter.imported++;
  }

  return counter;
}

async function importUserSettings(
  settings: ExportedUserSettingsV1 | ExportedUserSettingsV2 | null,
  schemaVersion: number,
  tx: TransactionClient
): Promise<{ imported: boolean; skipped: boolean }> {
  if (!settings) {
    return { imported: false, skipped: false };
  }

  const existing = await tx.userSettings.findFirst({ where: { userId: 'default' } });
  if (existing) {
    return { imported: false, skipped: true };
  }

  // Migrate v1 to v2 if needed (based on schema version from meta)
  // For v2, also ensure all required fields are present
  const s: ExportedUserSettingsV2 =
    schemaVersion >= 2
      ? ensureUserSettingsV2Defaults(settings as ExportedUserSettingsV2)
      : migrateUserSettingsV1ToV2(settings);

  await tx.userSettings.create({
    data: {
      userId: 'default',
      preferredIde: s.preferredIde,
      customIdeCommand: s.customIdeCommand,
      playSoundOnComplete: s.playSoundOnComplete,
      notificationSoundPath: s.notificationSoundPath,
      // Ratchet settings
      ratchetEnabled: s.ratchetEnabled,
      // Note: workspaceOrder and cachedSlashCommands are intentionally not imported
      // as they are rebuild-able cache data
      // Deprecated fields are ignored - they no longer exist in the schema
    },
  });

  return { imported: true, skipped: false };
}

// ============================================================================
// Service Class
// ============================================================================

class DataBackupService {
  /**
   * Export all data for backup/migration.
   * Exports projects, workspaces, sessions, and user preferences.
   * Excludes cached data (workspaceOrder, cachedSlashCommands) which will rebuild.
   * Exports in schema version 2 format.
   */
  async exportData(appVersion: string): Promise<ExportData> {
    logger.info('Exporting database data');

    // Fetch all data
    const { projects, workspaces, claudeSessions, terminalSessions, userSettings } =
      await dataBackupAccessor.getSnapshotForExport();

    const exportData: ExportData = {
      meta: {
        exportedAt: new Date().toISOString(),
        version: appVersion,
        schemaVersion: 2,
      },
      data: {
        projects: projects.map((p) => ({
          id: p.id,
          name: p.name,
          slug: p.slug,
          repoPath: p.repoPath,
          worktreeBasePath: p.worktreeBasePath,
          defaultBranch: p.defaultBranch,
          githubOwner: p.githubOwner,
          githubRepo: p.githubRepo,
          isArchived: p.isArchived,
          startupScriptCommand: p.startupScriptCommand,
          startupScriptPath: p.startupScriptPath,
          startupScriptTimeout: p.startupScriptTimeout,
          createdAt: p.createdAt.toISOString(),
          updatedAt: p.updatedAt.toISOString(),
        })),
        workspaces: workspaces.map((w) => ({
          id: w.id,
          projectId: w.projectId,
          name: w.name,
          description: w.description,
          status: w.status,
          worktreePath: w.worktreePath,
          branchName: w.branchName,
          isAutoGeneratedBranch: w.isAutoGeneratedBranch,
          creationSource: w.creationSource,
          creationMetadata: w.creationMetadata,
          initErrorMessage: w.initErrorMessage,
          initOutput: w.initOutput,
          initStartedAt: toISOString(w.initStartedAt),
          initCompletedAt: toISOString(w.initCompletedAt),
          initRetryCount: w.initRetryCount,
          runScriptCommand: w.runScriptCommand,
          runScriptCleanupCommand: w.runScriptCleanupCommand,
          runScriptPid: w.runScriptPid,
          runScriptPort: w.runScriptPort,
          runScriptStartedAt: toISOString(w.runScriptStartedAt),
          runScriptStatus: w.runScriptStatus,
          prUrl: w.prUrl,
          githubIssueNumber: w.githubIssueNumber,
          githubIssueUrl: w.githubIssueUrl,
          prNumber: w.prNumber,
          prState: w.prState,
          prReviewState: w.prReviewState,
          prCiStatus: w.prCiStatus,
          prUpdatedAt: toISOString(w.prUpdatedAt),
          prCiFailedAt: toISOString(w.prCiFailedAt),
          prCiLastNotifiedAt: toISOString(w.prCiLastNotifiedAt),
          // Phase 3+ PR review tracking fields
          prReviewLastCheckedAt: toISOString(w.prReviewLastCheckedAt),
          prReviewLastCommentId: w.prReviewLastCommentId,
          // Phase 3+ ratchet tracking fields
          ratchetEnabled: w.ratchetEnabled,
          ratchetState: w.ratchetState,
          ratchetLastCheckedAt: toISOString(w.ratchetLastCheckedAt),
          ratchetLastPushAt: toISOString(w.ratchetLastPushAt),
          ratchetActiveSessionId: w.ratchetActiveSessionId,
          ratchetLastCiRunId: w.ratchetLastCiRunId,
          ratchetLastNotifiedState: w.ratchetLastNotifiedState,
          hasHadSessions: w.hasHadSessions,
          cachedKanbanColumn: w.cachedKanbanColumn,
          stateComputedAt: toISOString(w.stateComputedAt),
          createdAt: w.createdAt.toISOString(),
          updatedAt: w.updatedAt.toISOString(),
        })),
        claudeSessions: claudeSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          workflow: s.workflow,
          model: s.model,
          status: s.status,
          claudeSessionId: s.claudeSessionId,
          claudeProjectPath: s.claudeProjectPath,
          claudeProcessPid: s.claudeProcessPid,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        terminalSessions: terminalSessions.map((s) => ({
          id: s.id,
          workspaceId: s.workspaceId,
          name: s.name,
          status: s.status,
          pid: s.pid,
          createdAt: s.createdAt.toISOString(),
          updatedAt: s.updatedAt.toISOString(),
        })),
        userSettings: userSettings
          ? {
              preferredIde: userSettings.preferredIde,
              customIdeCommand: userSettings.customIdeCommand,
              playSoundOnComplete: userSettings.playSoundOnComplete,
              notificationSoundPath: userSettings.notificationSoundPath,
              // Ratchet settings
              ratchetEnabled: userSettings.ratchetEnabled,
              // Note: workspaceOrder and cachedSlashCommands are intentionally excluded
              // as they are rebuild-able cache data (per design doc)
            }
          : null,
      },
    };

    logger.info('Export completed', {
      projectCount: projects.length,
      workspaceCount: workspaces.length,
      claudeSessionCount: claudeSessions.length,
      terminalSessionCount: terminalSessions.length,
    });

    return exportData;
  }

  /**
   * Import data from a backup file.
   * Supports both v1 and v2 schema versions with automatic migration.
   * Skips records that already exist (by ID).
   * Returns counts of imported/skipped records.
   * All imports are wrapped in a transaction for atomicity.
   */
  async importData(input: ExportDataV1 | ExportDataV2): Promise<ImportResults> {
    logger.info('Starting data import', {
      schemaVersion: input.meta.schemaVersion,
      exportedAt: input.meta.exportedAt,
      projectCount: input.data.projects.length,
      workspaceCount: input.data.workspaces.length,
    });

    // Import in dependency order within a transaction for atomicity
    const results = await dataBackupAccessor.runInTransaction(async (tx) => {
      const schemaVersion = input.meta.schemaVersion;
      const projects = await importProjects(input.data.projects, tx);
      const workspaces = await importWorkspaces(input.data.workspaces, schemaVersion, tx);
      const claudeSessions = await importClaudeSessions(input.data.claudeSessions, tx);
      const terminalSessions = await importTerminalSessions(input.data.terminalSessions, tx);
      const userSettings = await importUserSettings(input.data.userSettings, schemaVersion, tx);

      return {
        projects,
        workspaces,
        claudeSessions,
        terminalSessions,
        userSettings,
      };
    });

    logger.info('Import completed', {
      schemaVersion: input.meta.schemaVersion,
      projects: results.projects,
      workspaces: results.workspaces,
      claudeSessions: results.claudeSessions,
      terminalSessions: results.terminalSessions,
    });

    return results;
  }
}

// Export singleton instance
export const dataBackupService = new DataBackupService();

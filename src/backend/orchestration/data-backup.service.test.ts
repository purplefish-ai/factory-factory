import {
  type AgentSession,
  type Project,
  SessionProvider,
  type TerminalSession,
  type UserSettings,
  type Workspace,
  WorkspaceProviderSelection,
} from '@prisma-gen/client';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import {
  CIStatus,
  KanbanColumn,
  PRState,
  RatchetState,
  RunScriptStatus,
  WorkspaceCreationSource,
  WorkspaceStatus,
} from '@/shared/core';
import type { ExportData } from '@/shared/schemas/export-data.schema';
import { exportDataSchema } from '@/shared/schemas/export-data.schema';

const mockTx = vi.hoisted(() => ({
  project: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  workspace: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  agentSession: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  terminalSession: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  userSettings: {
    findFirst: vi.fn(),
    create: vi.fn(),
  },
}));

vi.mock('@/backend/db', () => ({
  prisma: {
    project: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    workspace: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    agentSession: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    terminalSession: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
      create: vi.fn(),
    },
    userSettings: {
      findFirst: vi.fn(),
      create: vi.fn(),
    },
    $transaction: vi.fn((callback) => callback(mockTx)),
  },
}));

import { prisma } from '@/backend/db';
import { dataBackupService } from './data-backup.service';

const mockProject: Project = {
  id: 'proj-1',
  name: 'Test Project',
  slug: 'test-project',
  repoPath: '/path/to/repo',
  worktreeBasePath: '/path/to/worktrees',
  defaultBranch: 'main',
  githubOwner: 'test-owner',
  githubRepo: 'test-repo',
  issueProvider: 'GITHUB' as const,
  issueTrackerConfig: null,
  isArchived: false,
  startupScriptCommand: 'npm install',
  startupScriptPath: null,
  startupScriptTimeout: 300,
  createdAt: new Date('2025-01-01T00:00:00.000Z'),
  updatedAt: new Date('2025-01-01T00:00:00.000Z'),
};

const mockWorkspace: Workspace = {
  id: 'ws-1',
  projectId: 'proj-1',
  name: 'Test Workspace',
  description: 'Test description',
  status: WorkspaceStatus.READY,
  worktreePath: '/path/to/worktree',
  branchName: 'feature/test',
  isAutoGeneratedBranch: true,
  isAutoGeneratedName: false,
  creationSource: WorkspaceCreationSource.GITHUB_ISSUE,
  creationMetadata: { issueNumber: 123 },
  initErrorMessage: null,
  initOutput: 'Init output',
  initStartedAt: new Date('2025-01-01T00:00:00.000Z'),
  initCompletedAt: new Date('2025-01-01T00:05:00.000Z'),
  initRetryCount: 0,
  runScriptCommand: 'npm run dev',
  runScriptCleanupCommand: 'npm run cleanup',
  runScriptPid: 12_345,
  runScriptPort: 3000,
  runScriptStartedAt: new Date('2025-01-01T00:10:00.000Z'),
  runScriptStatus: RunScriptStatus.RUNNING,
  prUrl: 'https://github.com/test/repo/pull/1',
  githubIssueNumber: 123,
  githubIssueUrl: 'https://github.com/test/repo/issues/123',
  linearIssueId: null,
  linearIssueIdentifier: null,
  linearIssueUrl: null,
  defaultSessionProvider: WorkspaceProviderSelection.CLAUDE,
  ratchetSessionProvider: WorkspaceProviderSelection.WORKSPACE_DEFAULT,
  prNumber: 1,
  prState: PRState.OPEN,
  prReviewState: 'APPROVED',
  prCiStatus: CIStatus.SUCCESS,
  prUpdatedAt: new Date('2025-01-01T00:15:00.000Z'),
  prCiFailedAt: null,
  prCiLastNotifiedAt: null,
  prReviewLastCheckedAt: new Date('2025-01-01T00:20:00.000Z'),
  prReviewLastCommentId: 'comment-123',
  ratchetEnabled: true,
  ratchetState: RatchetState.READY,
  ratchetLastCheckedAt: new Date('2025-01-01T00:25:00.000Z'),
  ratchetActiveSessionId: 'session-123',
  ratchetLastCiRunId: 'run-123',
  hasHadSessions: true,
  cachedKanbanColumn: KanbanColumn.WORKING,
  stateComputedAt: new Date('2025-01-01T00:35:00.000Z'),
  createdAt: new Date('2025-01-01T00:00:00.000Z'),
  updatedAt: new Date('2025-01-01T00:35:00.000Z'),
};

const mockAgentSession: AgentSession = {
  id: 'session-1',
  workspaceId: 'ws-1',
  name: 'Codex Session',
  workflow: 'followup',
  model: 'sonnet',
  status: 'RUNNING',
  provider: SessionProvider.CODEX,
  providerSessionId: 'thread-123',
  providerProjectPath: '/tmp/worktree',
  providerProcessPid: null,
  providerMetadata: { transport: 'app-server' },
  createdAt: new Date('2025-01-01T00:00:00.000Z'),
  updatedAt: new Date('2025-01-01T00:05:00.000Z'),
};

const mockTerminalSession: TerminalSession = {
  id: 'term-1',
  workspaceId: 'ws-1',
  name: 'Terminal',
  status: 'RUNNING',
  pid: 1234,
  createdAt: new Date('2025-01-01T00:00:00.000Z'),
  updatedAt: new Date('2025-01-01T00:05:00.000Z'),
};

const mockUserSettings: UserSettings = {
  id: 'settings-1',
  userId: 'default',
  preferredIde: 'cursor',
  customIdeCommand: null,
  playSoundOnComplete: true,
  notificationSoundPath: '/path/to/sound.mp3',
  workspaceOrder: { 'proj-1': ['ws-1', 'ws-2'] },
  cachedSlashCommands: { commands: [] },
  ratchetEnabled: true,
  defaultSessionProvider: SessionProvider.CLAUDE,
  defaultWorkspacePermissions: 'STRICT',
  ratchetPermissions: 'YOLO',
  createdAt: new Date('2025-01-01T00:00:00.000Z'),
  updatedAt: new Date('2025-01-01T00:00:00.000Z'),
};

function createImportData(overrides?: Partial<ExportData['data']>): ExportData {
  return {
    meta: {
      exportedAt: '2025-01-01T00:00:00.000Z',
      version: '1.0.0',
      schemaVersion: 4,
    },
    data: {
      projects: [
        {
          id: 'proj-1',
          name: 'Test Project',
          slug: 'test-project',
          repoPath: '/path/to/repo',
          worktreeBasePath: '/path/to/worktrees',
          defaultBranch: 'main',
          githubOwner: null,
          githubRepo: null,
          issueProvider: 'GITHUB',
          issueTrackerConfig: null,
          isArchived: false,
          startupScriptCommand: null,
          startupScriptPath: null,
          startupScriptTimeout: 300,
          createdAt: '2025-01-01T00:00:00.000Z',
          updatedAt: '2025-01-01T00:00:00.000Z',
        },
      ],
      workspaces: [
        {
          id: 'ws-1',
          projectId: 'proj-1',
          name: 'Test Workspace',
          description: 'Test description',
          status: WorkspaceStatus.READY,
          worktreePath: '/path/to/worktree',
          branchName: 'feature/test',
          isAutoGeneratedBranch: true,
          creationSource: WorkspaceCreationSource.GITHUB_ISSUE,
          creationMetadata: { issueNumber: 123 },
          initErrorMessage: null,
          initOutput: 'Init output',
          initStartedAt: '2025-01-01T00:00:00.000Z',
          initCompletedAt: '2025-01-01T00:05:00.000Z',
          initRetryCount: 0,
          runScriptCommand: 'npm run dev',
          runScriptCleanupCommand: 'npm run cleanup',
          runScriptPid: 12_345,
          runScriptPort: 3000,
          runScriptStartedAt: '2025-01-01T00:10:00.000Z',
          runScriptStatus: RunScriptStatus.RUNNING,
          prUrl: 'https://github.com/test/repo/pull/1',
          githubIssueNumber: 123,
          githubIssueUrl: 'https://github.com/test/repo/issues/123',
          linearIssueId: null,
          linearIssueIdentifier: null,
          linearIssueUrl: null,
          defaultSessionProvider: WorkspaceProviderSelection.CLAUDE,
          ratchetSessionProvider: WorkspaceProviderSelection.WORKSPACE_DEFAULT,
          prNumber: 1,
          prState: PRState.OPEN,
          prReviewState: 'APPROVED',
          prCiStatus: CIStatus.SUCCESS,
          prUpdatedAt: '2025-01-01T00:15:00.000Z',
          prCiFailedAt: null,
          prCiLastNotifiedAt: null,
          prReviewLastCheckedAt: '2025-01-01T00:20:00.000Z',
          prReviewLastCommentId: 'comment-123',
          ratchetEnabled: true,
          ratchetState: RatchetState.READY,
          ratchetLastCheckedAt: '2025-01-01T00:25:00.000Z',
          ratchetActiveSessionId: 'session-123',
          ratchetLastCiRunId: 'run-123',
          hasHadSessions: true,
          cachedKanbanColumn: KanbanColumn.WORKING,
          stateComputedAt: '2025-01-01T00:35:00.000Z',
          createdAt: '2025-01-01T00:00:00.000Z',
          updatedAt: '2025-01-01T00:35:00.000Z',
        },
      ],
      agentSessions: [
        {
          id: 'session-1',
          workspaceId: 'ws-1',
          name: 'Codex Session',
          workflow: 'followup',
          model: 'sonnet',
          status: 'RUNNING',
          provider: SessionProvider.CODEX,
          providerSessionId: 'thread-123',
          providerProjectPath: null,
          providerProcessPid: null,
          providerMetadata: { transport: 'app-server' },
          createdAt: '2025-01-01T00:00:00.000Z',
          updatedAt: '2025-01-01T00:05:00.000Z',
        },
      ],
      terminalSessions: [
        {
          id: 'term-1',
          workspaceId: 'ws-1',
          name: 'Terminal',
          status: 'RUNNING',
          pid: 1234,
          createdAt: '2025-01-01T00:00:00.000Z',
          updatedAt: '2025-01-01T00:05:00.000Z',
        },
      ],
      userSettings: {
        preferredIde: 'cursor',
        customIdeCommand: null,
        playSoundOnComplete: true,
        notificationSoundPath: '/path/to/sound.mp3',
        ratchetEnabled: true,
        defaultSessionProvider: SessionProvider.CLAUDE,
        defaultWorkspacePermissions: 'STRICT',
        ratchetPermissions: 'YOLO',
      },
      ...overrides,
    },
  };
}

describe('DataBackupService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('exportData', () => {
    it('exports v4 format with all fields', async () => {
      vi.mocked(prisma.project.findMany).mockResolvedValue([mockProject]);
      vi.mocked(prisma.workspace.findMany).mockResolvedValue([mockWorkspace]);
      vi.mocked(prisma.agentSession.findMany).mockResolvedValue([mockAgentSession]);
      vi.mocked(prisma.terminalSession.findMany).mockResolvedValue([mockTerminalSession]);
      vi.mocked(prisma.userSettings.findFirst).mockResolvedValue(mockUserSettings);

      const result = await dataBackupService.exportData('1.0.0');

      expect(result.meta.schemaVersion).toBe(4);
      expect(result.data.agentSessions).toHaveLength(1);
      expect(result.data.agentSessions[0]).toEqual(
        expect.objectContaining({
          id: 'session-1',
          provider: SessionProvider.CODEX,
          providerSessionId: 'thread-123',
        })
      );
      expect(result.data.userSettings).toEqual(
        expect.objectContaining({
          ratchetEnabled: true,
          defaultSessionProvider: SessionProvider.CLAUDE,
          defaultWorkspacePermissions: 'STRICT',
          ratchetPermissions: 'YOLO',
        })
      );
      expect(exportDataSchema.safeParse(result).success).toBe(true);
    });

    it('exports null user settings when absent', async () => {
      vi.mocked(prisma.project.findMany).mockResolvedValue([]);
      vi.mocked(prisma.workspace.findMany).mockResolvedValue([]);
      vi.mocked(prisma.agentSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.terminalSession.findMany).mockResolvedValue([]);
      vi.mocked(prisma.userSettings.findFirst).mockResolvedValue(null);

      const result = await dataBackupService.exportData('1.0.0');

      expect(result.data.userSettings).toBeNull();
    });
  });

  describe('importData', () => {
    it('imports strict v4 data', async () => {
      const exportedData = createImportData();

      vi.mocked(mockTx.project.findUnique)
        .mockResolvedValueOnce(null)
        .mockResolvedValueOnce(null)
        .mockResolvedValue(mockProject);
      vi.mocked(mockTx.project.create).mockResolvedValue(mockProject);

      vi.mocked(mockTx.workspace.findUnique)
        .mockResolvedValueOnce(null)
        .mockResolvedValueOnce({ id: 'ws-1' } as never)
        .mockResolvedValueOnce({ id: 'ws-1' } as never);
      vi.mocked(mockTx.workspace.create).mockResolvedValue(mockWorkspace);

      vi.mocked(mockTx.agentSession.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.agentSession.create).mockResolvedValue(mockAgentSession);

      vi.mocked(mockTx.terminalSession.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.terminalSession.create).mockResolvedValue(mockTerminalSession);

      vi.mocked(mockTx.userSettings.findFirst).mockResolvedValue(null);
      vi.mocked(mockTx.userSettings.create).mockResolvedValue(mockUserSettings);

      const result = await dataBackupService.importData(exportedData);

      expect(result.projects.imported).toBe(1);
      expect(result.workspaces.imported).toBe(1);
      expect(result.agentSessions.imported).toBe(1);
      expect(result.terminalSessions.imported).toBe(1);
      expect(result.userSettings.imported).toBe(true);

      expect(mockTx.workspace.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          id: 'ws-1',
          runScriptStatus: RunScriptStatus.RUNNING,
          ratchetState: RatchetState.READY,
        }),
      });

      expect(mockTx.agentSession.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          id: 'session-1',
          provider: SessionProvider.CODEX,
          providerSessionId: 'thread-123',
          providerMetadata: { transport: 'app-server' },
        }),
      });
    });

    it('skips existing projects', async () => {
      const exportedData = createImportData({
        workspaces: [],
        agentSessions: [],
        terminalSessions: [],
        userSettings: null,
      });

      vi.mocked(mockTx.project.findUnique).mockResolvedValue(mockProject);

      const result = await dataBackupService.importData(exportedData);

      expect(result.projects.imported).toBe(0);
      expect(result.projects.skipped).toBe(1);
      expect(mockTx.project.create).not.toHaveBeenCalled();
    });

    it('skips workspaces with missing projects', async () => {
      const exportedData = createImportData({
        projects: [],
        agentSessions: [],
        terminalSessions: [],
      });

      vi.mocked(mockTx.workspace.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.project.findUnique).mockResolvedValue(null);
      vi.mocked(mockTx.userSettings.findFirst).mockResolvedValue(null);
      vi.mocked(mockTx.userSettings.create).mockResolvedValue(mockUserSettings);

      const result = await dataBackupService.importData(exportedData);

      expect(result.workspaces.imported).toBe(0);
      expect(result.workspaces.skipped).toBe(1);
      expect(mockTx.workspace.create).not.toHaveBeenCalled();
    });

    it('skips user settings when already present', async () => {
      const exportedData = createImportData({
        projects: [],
        workspaces: [],
        agentSessions: [],
        terminalSessions: [],
      });

      vi.mocked(mockTx.userSettings.findFirst).mockResolvedValue(mockUserSettings);

      const result = await dataBackupService.importData(exportedData);

      expect(result.userSettings.imported).toBe(false);
      expect(result.userSettings.skipped).toBe(true);
      expect(mockTx.userSettings.create).not.toHaveBeenCalled();
    });
  });
});

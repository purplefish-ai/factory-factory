import type {
  CIStatus,
  KanbanColumn,
  PRState,
  Prisma,
  RatchetState,
  SessionStatus,
  Workspace,
  WorkspaceStatus,
} from '@prisma-gen/client';
import { prisma } from '../db';

/**
 * Threshold for considering a PROVISIONING workspace as stale.
 * Workspaces in PROVISIONING state for longer than this are considered
 * stuck (e.g., due to server crash) and will be recovered by reconciliation.
 */
const STALE_PROVISIONING_THRESHOLD_MS = 10 * 60 * 1000; // 10 minutes

interface CreateWorkspaceInput {
  projectId: string;
  name: string;
  description?: string;
  branchName?: string;
  githubIssueNumber?: number;
  githubIssueUrl?: string;
  isAutoGeneratedBranch?: boolean;
  ratchetEnabled?: boolean;
}

interface UpdateWorkspaceInput {
  name?: string;
  description?: string;
  // Note: status changes must go through workspaceStateMachine, not direct updates
  worktreePath?: string | null;
  branchName?: string | null;
  isAutoGeneratedBranch?: boolean;
  prUrl?: string | null;
  githubIssueNumber?: number | null;
  githubIssueUrl?: string | null;
  // PR tracking fields
  prNumber?: number | null;
  prState?: PRState;
  prReviewState?: string | null;
  prCiStatus?: CIStatus;
  prUpdatedAt?: Date | null;
  // CI failure tracking
  prCiFailedAt?: Date | null;
  prCiLastNotifiedAt?: Date | null;
  // PR Review tracking
  prReviewLastCheckedAt?: Date | null;
  prReviewLastCommentId?: string | null;
  // Ratchet tracking
  ratchetEnabled?: boolean;
  ratchetState?: RatchetState;
  ratchetLastCheckedAt?: Date | null;
  ratchetLastPushAt?: Date | null;
  ratchetActiveSessionId?: string | null;
  ratchetLastCiRunId?: string | null;
  ratchetLastNotifiedState?: RatchetState | null;
  // Activity tracking
  hasHadSessions?: boolean;
  // Cached kanban column
  cachedKanbanColumn?: KanbanColumn;
  stateComputedAt?: Date | null;
  // Run script tracking
  hasFactoryConfig?: boolean;
  runScriptCommand?: string | null;
  runScriptCleanupCommand?: string | null;
  runScriptPid?: number | null;
  runScriptPort?: number | null;
  runScriptStartedAt?: Date | null;
  runScriptStatus?: SessionStatus;
}

interface FindByProjectIdFilters {
  status?: WorkspaceStatus;
  excludeStatuses?: WorkspaceStatus[];
  kanbanColumn?: KanbanColumn;
  limit?: number;
  offset?: number;
}

// Type for Workspace with sessions included
type WorkspaceWithSessions = Prisma.WorkspaceGetPayload<{
  include: { claudeSessions: true; terminalSessions: true };
}>;

// Type for Workspace with project included
type WorkspaceWithProject = Prisma.WorkspaceGetPayload<{
  include: { project: true };
}>;

class WorkspaceAccessor {
  create(data: CreateWorkspaceInput): Promise<Workspace> {
    return prisma.workspace.create({
      data: {
        projectId: data.projectId,
        name: data.name,
        description: data.description,
        branchName: data.branchName,
        githubIssueNumber: data.githubIssueNumber,
        githubIssueUrl: data.githubIssueUrl,
        isAutoGeneratedBranch: data.isAutoGeneratedBranch ?? false,
        ratchetEnabled: data.ratchetEnabled,
      },
    });
  }

  findById(id: string): Promise<WorkspaceWithSessions | null> {
    return prisma.workspace.findUnique({
      where: { id },
      include: {
        claudeSessions: true,
        terminalSessions: true,
      },
    });
  }

  findByProjectId(projectId: string, filters?: FindByProjectIdFilters): Promise<Workspace[]> {
    const where: Prisma.WorkspaceWhereInput = { projectId };

    if (filters?.status) {
      where.status = filters.status;
    }

    if (filters?.kanbanColumn) {
      where.cachedKanbanColumn = filters.kanbanColumn;
    }

    return prisma.workspace.findMany({
      where,
      take: filters?.limit,
      skip: filters?.offset,
      orderBy: { updatedAt: 'desc' },
    });
  }

  /**
   * Find workspaces with sessions included (for kanban state computation).
   *
   * @throws Error if both status and excludeStatuses filters are specified
   */
  findByProjectIdWithSessions(
    projectId: string,
    filters?: FindByProjectIdFilters
  ): Promise<WorkspaceWithSessions[]> {
    // Validate mutually exclusive filters
    if (filters?.status && filters?.excludeStatuses?.length) {
      throw new Error('Cannot specify both status and excludeStatuses filters');
    }

    const where: Prisma.WorkspaceWhereInput = { projectId };

    if (filters?.status) {
      where.status = filters.status;
    }

    if (filters?.excludeStatuses && filters.excludeStatuses.length > 0) {
      where.status = { notIn: filters.excludeStatuses };
    }

    if (filters?.kanbanColumn) {
      where.cachedKanbanColumn = filters.kanbanColumn;
    }

    return prisma.workspace.findMany({
      where,
      take: filters?.limit,
      skip: filters?.offset,
      orderBy: { updatedAt: 'desc' },
      include: {
        claudeSessions: true,
        terminalSessions: true,
      },
    });
  }

  update(id: string, data: UpdateWorkspaceInput): Promise<Workspace> {
    return prisma.workspace.update({
      where: { id },
      data,
    });
  }

  delete(id: string): Promise<Workspace> {
    return prisma.workspace.delete({
      where: { id },
    });
  }

  // Note: archive functionality is provided by workspaceStateMachine.archive()

  /**
   * Find workspaces that need worktree creation or recovery.
   * Returns:
   * - NEW workspaces that haven't started provisioning yet
   * - PROVISIONING workspaces that are stale (>10 minutes) and likely stuck due to server crash
   *
   * Used for reconciliation to ensure all workspaces are initialized.
   * Includes project for worktree creation.
   */
  findNeedingWorktree(): Promise<WorkspaceWithProject[]> {
    const staleThreshold = new Date(Date.now() - STALE_PROVISIONING_THRESHOLD_MS);

    return prisma.workspace.findMany({
      where: {
        OR: [
          { status: 'NEW' },
          {
            status: 'PROVISIONING',
            initStartedAt: { lt: staleThreshold },
          },
        ],
      },
      include: {
        project: true,
      },
      orderBy: { createdAt: 'asc' },
    });
  }

  /**
   * Find workspace by ID with project included.
   * Used when project info is needed (e.g., for worktree creation).
   */
  findByIdWithProject(id: string): Promise<WorkspaceWithProject | null> {
    return prisma.workspace.findUnique({
      where: { id },
      include: {
        project: true,
      },
    });
  }

  /**
   * Find READY workspaces with PR URLs that need sync.
   * Used for Inngest PR status sync job.
   */
  findNeedingPRSync(staleThresholdMinutes = 5): Promise<WorkspaceWithProject[]> {
    const staleThreshold = new Date(Date.now() - staleThresholdMinutes * 60 * 1000);

    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: { not: null },
        OR: [{ prUpdatedAt: null }, { prUpdatedAt: { lt: staleThreshold } }],
      },
      include: {
        project: true,
      },
      orderBy: { prUpdatedAt: 'asc' }, // Oldest first
    });
  }

  /**
   * Find READY workspaces without PR URLs that have a branch name.
   * Used for detecting newly created PRs.
   */
  findNeedingPRDiscovery(): Promise<WorkspaceWithProject[]> {
    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: null,
        branchName: { not: null },
      },
      include: {
        project: true,
      },
      orderBy: { updatedAt: 'desc' },
    });
  }

  /**
   * Find ACTIVE workspaces with PR URLs for CI monitoring.
   * Returns workspaces that have PRs to monitor for CI status changes.
   */
  findWithPRsForCIMonitoring(): Promise<
    Array<{
      id: string;
      prUrl: string;
      prCiStatus: CIStatus;
      prCiFailedAt: Date | null;
      prCiLastNotifiedAt: Date | null;
    }>
  > {
    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: { not: null },
      },
      select: {
        id: true,
        prUrl: true,
        prCiStatus: true,
        prCiFailedAt: true,
        prCiLastNotifiedAt: true,
      },
      orderBy: { prUpdatedAt: 'asc' },
    }) as Promise<
      Array<{
        id: string;
        prUrl: string;
        prCiStatus: CIStatus;
        prCiFailedAt: Date | null;
        prCiLastNotifiedAt: Date | null;
      }>
    >;
  }

  /**
   * Find ACTIVE workspaces with PR URLs for PR review monitoring.
   * Returns workspaces that have PRs to monitor for review comments.
   */
  findWithPRsForReviewMonitoring(): Promise<
    Array<{
      id: string;
      prUrl: string;
      prNumber: number;
      prReviewLastCheckedAt: Date | null;
      prReviewLastCommentId: string | null;
    }>
  > {
    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: { not: null },
        prNumber: { not: null },
      },
      select: {
        id: true,
        prUrl: true,
        prNumber: true,
        prReviewLastCheckedAt: true,
        prReviewLastCommentId: true,
      },
      orderBy: { prReviewLastCheckedAt: 'asc' },
    }) as Promise<
      Array<{
        id: string;
        prUrl: string;
        prNumber: number;
        prReviewLastCheckedAt: Date | null;
        prReviewLastCommentId: string | null;
      }>
    >;
  }

  /**
   * Mark workspace as having had sessions (for kanban backlog/waiting distinction).
   * Uses atomic conditional update to prevent race conditions when multiple sessions start.
   */
  async markHasHadSessions(id: string): Promise<void> {
    await prisma.workspace.updateMany({
      where: { id, hasHadSessions: false },
      data: { hasHadSessions: true },
    });
  }

  /**
   * Append output to initOutput field during startup script execution.
   * Truncates from the beginning if output exceeds maxSize to prevent unbounded growth.
   */
  async appendInitOutput(id: string, output: string, maxSize = 50 * 1024): Promise<void> {
    const workspace = await prisma.workspace.findUnique({
      where: { id },
      select: { initOutput: true },
    });

    let newOutput = (workspace?.initOutput ?? '') + output;

    // Truncate from the beginning if too large
    if (newOutput.length > maxSize) {
      const truncationMarker = '[...truncated...]\n';
      const keepSize = maxSize - truncationMarker.length;
      newOutput = `${truncationMarker}${newOutput.slice(-keepSize)}`;
    }

    await prisma.workspace.update({
      where: { id },
      data: { initOutput: newOutput },
    });
  }

  /**
   * Clear initOutput field (called when retrying initialization).
   */
  async clearInitOutput(id: string): Promise<void> {
    await prisma.workspace.update({
      where: { id },
      data: { initOutput: null },
    });
  }

  /**
   * Find multiple workspaces by their IDs.
   * Used for batch lookups when enriching process info.
   */
  findByIds(ids: string[]): Promise<Workspace[]> {
    if (ids.length === 0) {
      return Promise.resolve([]);
    }
    return prisma.workspace.findMany({
      where: {
        id: { in: ids },
      },
    });
  }

  /**
   * Find multiple workspaces by their IDs with project included.
   * Used for batch lookups when project info is needed (e.g., admin process list).
   */
  findByIdsWithProject(ids: string[]): Promise<WorkspaceWithProject[]> {
    if (ids.length === 0) {
      return Promise.resolve([]);
    }
    return prisma.workspace.findMany({
      where: {
        id: { in: ids },
      },
      include: {
        project: true,
      },
    });
  }

  /**
   * Find READY workspaces with PR URLs for ratchet monitoring.
   * Returns workspaces that have PRs to monitor for progression.
   */
  findWithPRsForRatchet(): Promise<
    Array<{
      id: string;
      prUrl: string;
      prNumber: number;
      ratchetEnabled: boolean;
      ratchetState: RatchetState;
      ratchetActiveSessionId: string | null;
      ratchetLastNotifiedState: RatchetState | null;
      prReviewLastCheckedAt: Date | null;
    }>
  > {
    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: { not: null },
        prNumber: { not: null },
      },
      select: {
        id: true,
        prUrl: true,
        prNumber: true,
        ratchetEnabled: true,
        ratchetState: true,
        ratchetActiveSessionId: true,
        ratchetLastNotifiedState: true,
        prReviewLastCheckedAt: true,
      },
      orderBy: { ratchetLastCheckedAt: 'asc' }, // Check oldest first
    }) as Promise<
      Array<{
        id: string;
        prUrl: string;
        prNumber: number;
        ratchetEnabled: boolean;
        ratchetState: RatchetState;
        ratchetActiveSessionId: string | null;
        ratchetLastNotifiedState: RatchetState | null;
        prReviewLastCheckedAt: Date | null;
      }>
    >;
  }
}

export const workspaceAccessor = new WorkspaceAccessor();

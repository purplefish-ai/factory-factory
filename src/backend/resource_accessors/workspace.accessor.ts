import type { Prisma, Workspace, WorkspaceProviderSelection } from '@prisma-gen/client';
import { prisma } from '@/backend/db';
import type {
  CIStatus,
  KanbanColumn,
  PRState,
  RatchetState,
  RunScriptStatus,
  WorkspaceStatus,
} from '@/shared/core';

/**
 * Threshold for considering a PROVISIONING workspace as stale.
 * Workspaces in PROVISIONING state for longer than this are considered
 * stuck (e.g., due to server crash) and will be recovered by reconciliation.
 */
const STALE_PROVISIONING_THRESHOLD_MS = 10 * 60 * 1000; // 10 minutes

interface CreateWorkspaceInput {
  projectId: string;
  name: string;
  description?: string;
  branchName?: string;
  githubIssueNumber?: number;
  githubIssueUrl?: string;
  isAutoGeneratedBranch?: boolean;
  ratchetEnabled?: boolean;
  defaultSessionProvider?: Prisma.WorkspaceCreateInput['defaultSessionProvider'];
  ratchetSessionProvider?: Prisma.WorkspaceCreateInput['ratchetSessionProvider'];
  creationSource?: 'MANUAL' | 'RESUME_BRANCH' | 'GITHUB_ISSUE';
  creationMetadata?: Prisma.InputJsonValue;
}

interface UpdateWorkspaceInput {
  name?: string;
  description?: string;
  // Note: status changes must go through workspaceStateMachine, not direct updates
  worktreePath?: string | null;
  branchName?: string | null;
  isAutoGeneratedBranch?: boolean;
  prUrl?: string | null;
  githubIssueNumber?: number | null;
  githubIssueUrl?: string | null;
  // PR tracking fields
  prNumber?: number | null;
  prState?: PRState;
  prReviewState?: string | null;
  prCiStatus?: CIStatus;
  prUpdatedAt?: Date | null;
  // CI failure tracking
  prCiFailedAt?: Date | null;
  prCiLastNotifiedAt?: Date | null;
  // PR Review tracking
  prReviewLastCheckedAt?: Date | null;
  prReviewLastCommentId?: string | null;
  // Ratchet tracking
  ratchetEnabled?: boolean;
  defaultSessionProvider?: Prisma.WorkspaceUpdateInput['defaultSessionProvider'];
  ratchetSessionProvider?: Prisma.WorkspaceUpdateInput['ratchetSessionProvider'];
  ratchetState?: RatchetState;
  ratchetLastCheckedAt?: Date | null;
  ratchetActiveSessionId?: string | null;
  ratchetLastCiRunId?: string | null;
  // Activity tracking
  hasHadSessions?: boolean;
  // Cached kanban column
  cachedKanbanColumn?: KanbanColumn;
  stateComputedAt?: Date | null;
  // Run script tracking
  runScriptCommand?: string | null;
  runScriptCleanupCommand?: string | null;
  runScriptPid?: number | null;
  runScriptPort?: number | null;
  runScriptStartedAt?: Date | null;
  runScriptStatus?: RunScriptStatus;
}

interface FindByProjectIdFilters {
  status?: WorkspaceStatus;
  excludeStatuses?: WorkspaceStatus[];
  kanbanColumn?: KanbanColumn;
  limit?: number;
  offset?: number;
}

type WorkspaceWithAgentSessions = Prisma.WorkspaceGetPayload<{
  include: { agentSessions: true; terminalSessions: true };
}>;

type WorkspaceForRatchet = {
  id: string;
  prUrl: string;
  prNumber: number | null;
  prState: PRState;
  prCiStatus: CIStatus;
  defaultSessionProvider: WorkspaceProviderSelection;
  ratchetSessionProvider: WorkspaceProviderSelection;
  ratchetEnabled: boolean;
  ratchetState: RatchetState;
  ratchetActiveSessionId: string | null;
  ratchetLastCiRunId: string | null;
  prReviewLastCheckedAt: Date | null;
};

export type WorkspaceWithSessions = WorkspaceWithAgentSessions;

// Type for Workspace with project included
type WorkspaceWithProject = Prisma.WorkspaceGetPayload<{
  include: { project: true };
}>;

type WorkspaceWithAgentSessionsAndProject = Prisma.WorkspaceGetPayload<{
  include: { agentSessions: true; terminalSessions: true; project: true };
}>;

// Type for Workspace with sessions and project included (used by reconciliation)
export type WorkspaceWithSessionsAndProject = WorkspaceWithAgentSessionsAndProject;

class WorkspaceAccessor {
  create(data: CreateWorkspaceInput): Promise<Workspace> {
    return prisma.workspace.create({
      data: {
        projectId: data.projectId,
        name: data.name,
        description: data.description,
        branchName: data.branchName,
        githubIssueNumber: data.githubIssueNumber,
        githubIssueUrl: data.githubIssueUrl,
        isAutoGeneratedBranch: data.isAutoGeneratedBranch ?? false,
        ratchetEnabled: data.ratchetEnabled,
        defaultSessionProvider: data.defaultSessionProvider,
        ratchetSessionProvider: data.ratchetSessionProvider,
        creationSource: data.creationSource,
        creationMetadata: data.creationMetadata,
      },
    });
  }

  findById(id: string): Promise<WorkspaceWithSessions | null> {
    return prisma.workspace.findUnique({
      where: { id },
      include: {
        agentSessions: true,
        terminalSessions: true,
      },
    });
  }

  /**
   * Find a workspace without relation includes.
   * Used by state machines that only need the raw row.
   */
  findRawById(id: string): Promise<Workspace | null> {
    return prisma.workspace.findUnique({
      where: { id },
    });
  }

  /**
   * Find a workspace without relation includes and throw if missing.
   * Used by state machines after compare-and-swap updates.
   */
  findRawByIdOrThrow(id: string): Promise<Workspace> {
    return prisma.workspace.findUniqueOrThrow({
      where: { id },
    });
  }

  findByProjectId(projectId: string, filters?: FindByProjectIdFilters): Promise<Workspace[]> {
    const where: Prisma.WorkspaceWhereInput = { projectId };

    if (filters?.status) {
      where.status = filters.status;
    }

    if (filters?.kanbanColumn) {
      where.cachedKanbanColumn = filters.kanbanColumn;
    }

    return prisma.workspace.findMany({
      where,
      take: filters?.limit,
      skip: filters?.offset,
      orderBy: { updatedAt: 'desc' },
    });
  }

  /**
   * Find workspaces with sessions included (for kanban state computation).
   *
   * @throws Error if both status and excludeStatuses filters are specified
   */
  findByProjectIdWithSessions(
    projectId: string,
    filters?: FindByProjectIdFilters
  ): Promise<WorkspaceWithSessions[]> {
    // Validate mutually exclusive filters
    if (filters?.status && filters?.excludeStatuses?.length) {
      throw new Error('Cannot specify both status and excludeStatuses filters');
    }

    const where: Prisma.WorkspaceWhereInput = { projectId };

    if (filters?.status) {
      where.status = filters.status;
    }

    if (filters?.excludeStatuses && filters.excludeStatuses.length > 0) {
      where.status = { notIn: filters.excludeStatuses };
    }

    if (filters?.kanbanColumn) {
      where.cachedKanbanColumn = filters.kanbanColumn;
    }

    return prisma.workspace.findMany({
      where,
      take: filters?.limit,
      skip: filters?.offset,
      orderBy: { updatedAt: 'desc' },
      include: {
        agentSessions: true,
        terminalSessions: true,
      },
    });
  }

  /**
   * Find all non-archived workspaces with sessions and project included.
   * Used by the reconciliation service for single-query fetch of all workspace data.
   */
  findAllNonArchivedWithSessionsAndProject(): Promise<WorkspaceWithSessionsAndProject[]> {
    return prisma.workspace.findMany({
      where: { status: { not: 'ARCHIVED' } },
      include: {
        agentSessions: true,
        terminalSessions: true,
        project: true,
      },
      orderBy: { updatedAt: 'desc' },
    });
  }

  update(id: string, data: UpdateWorkspaceInput): Promise<Workspace> {
    return prisma.workspace.update({
      where: { id },
      data,
    });
  }

  /**
   * Atomic compare-and-swap transition for workspace status.
   * Returns count=1 only when current status matches fromStatus.
   * Used to prevent race conditions in state transitions.
   */
  transitionWithCas(
    id: string,
    fromStatus: WorkspaceStatus,
    data: Prisma.WorkspaceUpdateManyMutationInput
  ): Promise<{ count: number }> {
    return prisma.workspace.updateMany({
      where: { id, status: fromStatus },
      data,
    });
  }

  /**
   * Compare-and-swap update for run script status transitions.
   * Returns count=1 only when current status matches.
   */
  casRunScriptStatusUpdate(
    id: string,
    currentStatus: RunScriptStatus,
    data: Prisma.WorkspaceUpdateManyMutationInput
  ): Promise<{ count: number }> {
    return prisma.workspace.updateMany({
      where: { id, runScriptStatus: currentStatus },
      data,
    });
  }

  /**
   * Conditional provisioning retry transition (FAILED -> PROVISIONING).
   * Returns count=1 when retry is allowed and transition was applied.
   */
  startProvisioningRetryIfAllowed(id: string, maxRetries: number): Promise<{ count: number }> {
    return prisma.workspace.updateMany({
      where: {
        id,
        status: 'FAILED',
        initRetryCount: { lt: maxRetries },
      },
      data: {
        status: 'PROVISIONING',
        initRetryCount: { increment: 1 },
        initStartedAt: new Date(),
        initErrorMessage: null,
      },
    });
  }

  /**
   * Conditional reset transition (FAILED -> NEW).
   * Returns count=1 when retry is allowed and transition was applied.
   */
  resetToNewIfAllowed(id: string, maxRetries: number): Promise<{ count: number }> {
    return prisma.workspace.updateMany({
      where: {
        id,
        status: 'FAILED',
        initRetryCount: { lt: maxRetries },
      },
      data: {
        status: 'NEW',
        initRetryCount: { increment: 1 },
        initStartedAt: null,
        initCompletedAt: null,
        initErrorMessage: null,
      },
    });
  }

  delete(id: string): Promise<Workspace> {
    return prisma.workspace.delete({
      where: { id },
    });
  }

  // Note: archive functionality is provided by workspaceStateMachine.archive()

  /**
   * Find workspaces that need worktree creation or recovery.
   * Returns:
   * - NEW workspaces that haven't started provisioning yet
   * - PROVISIONING workspaces that are stale (>10 minutes) and likely stuck due to server crash
   *
   * Used for reconciliation to ensure all workspaces are initialized.
   * Includes project for worktree creation.
   */
  findNeedingWorktree(): Promise<WorkspaceWithProject[]> {
    const staleThreshold = new Date(Date.now() - STALE_PROVISIONING_THRESHOLD_MS);

    return prisma.workspace.findMany({
      where: {
        OR: [
          { status: 'NEW' },
          {
            status: 'PROVISIONING',
            initStartedAt: { lt: staleThreshold },
          },
        ],
      },
      include: {
        project: true,
      },
      orderBy: { createdAt: 'asc' },
    });
  }

  /**
   * Find workspace by ID with project included.
   * Used when project info is needed (e.g., for worktree creation).
   */
  findByIdWithProject(id: string): Promise<WorkspaceWithProject | null> {
    return prisma.workspace.findUnique({
      where: { id },
      include: {
        project: true,
      },
    });
  }

  /**
   * Find READY workspaces with PR URLs that need sync.
   * Used for Inngest PR status sync job.
   */
  findNeedingPRSync(staleThresholdMinutes = 5): Promise<WorkspaceWithProject[]> {
    const staleThreshold = new Date(Date.now() - staleThresholdMinutes * 60 * 1000);

    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: { not: null },
        OR: [{ prUpdatedAt: null }, { prUpdatedAt: { lt: staleThreshold } }],
      },
      include: {
        project: true,
      },
      orderBy: { prUpdatedAt: 'asc' }, // Oldest first
    });
  }

  /**
   * Find READY workspaces without PR URLs that have a branch name.
   * Used for detecting newly created PRs.
   */
  findNeedingPRDiscovery(): Promise<WorkspaceWithProject[]> {
    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: null,
        branchName: { not: null },
      },
      include: {
        project: true,
      },
      orderBy: { updatedAt: 'desc' },
    });
  }

  /**
   * Mark workspace as having had sessions (for kanban backlog/waiting distinction).
   * Uses atomic conditional update to prevent race conditions when multiple sessions start.
   */
  async markHasHadSessions(id: string): Promise<void> {
    await prisma.workspace.updateMany({
      where: { id, hasHadSessions: false },
      data: { hasHadSessions: true },
    });
  }

  /**
   * Clear ratchetActiveSessionId if it still points to the given session.
   * Called on session exit to eagerly clean up stale fixer references.
   */
  async clearRatchetActiveSession(workspaceId: string, sessionId: string): Promise<void> {
    await prisma.workspace.updateMany({
      where: { id: workspaceId, ratchetActiveSessionId: sessionId },
      data: { ratchetActiveSessionId: null },
    });
  }

  /**
   * Append output to initOutput field during startup script execution.
   * Truncates from the beginning if output exceeds maxSize to prevent unbounded growth.
   */
  async appendInitOutput(id: string, output: string, maxSize = 50 * 1024): Promise<void> {
    const workspace = await prisma.workspace.findUnique({
      where: { id },
      select: { initOutput: true },
    });

    let newOutput = (workspace?.initOutput ?? '') + output;

    // Truncate from the beginning if too large
    if (newOutput.length > maxSize) {
      const truncationMarker = '[...truncated...]\n';
      const keepSize = maxSize - truncationMarker.length;
      newOutput = `${truncationMarker}${newOutput.slice(-keepSize)}`;
    }

    await prisma.workspace.update({
      where: { id },
      data: { initOutput: newOutput },
    });
  }

  /**
   * Clear initOutput field (called when retrying initialization).
   */
  async clearInitOutput(id: string): Promise<void> {
    await prisma.workspace.update({
      where: { id },
      data: { initOutput: null },
    });
  }

  /**
   * Find multiple workspaces by their IDs.
   * Used for batch lookups when enriching process info.
   */
  findByIds(ids: string[]): Promise<Workspace[]> {
    if (ids.length === 0) {
      return Promise.resolve([]);
    }
    return prisma.workspace.findMany({
      where: {
        id: { in: ids },
      },
    });
  }

  /**
   * Find multiple workspaces by their IDs with project included.
   * Used for batch lookups when project info is needed (e.g., admin process list).
   */
  findByIdsWithProject(ids: string[]): Promise<WorkspaceWithProject[]> {
    if (ids.length === 0) {
      return Promise.resolve([]);
    }
    return prisma.workspace.findMany({
      where: {
        id: { in: ids },
      },
      include: {
        project: true,
      },
    });
  }

  /**
   * Find READY workspaces with PR URLs for ratchet monitoring.
   * Returns workspaces that have PRs to monitor for progression.
   */
  findWithPRsForRatchet(): Promise<WorkspaceForRatchet[]> {
    return prisma.workspace.findMany({
      where: {
        status: 'READY',
        prUrl: { not: null },
        // Skip disabled and terminal workspaces to avoid unnecessary GitHub API calls
        ratchetEnabled: true,
        ratchetState: { not: 'MERGED' },
      },
      select: {
        id: true,
        prUrl: true,
        prNumber: true,
        prState: true,
        prCiStatus: true,
        defaultSessionProvider: true,
        ratchetSessionProvider: true,
        ratchetEnabled: true,
        ratchetState: true,
        ratchetActiveSessionId: true,
        ratchetLastCiRunId: true,
        prReviewLastCheckedAt: true,
      },
      orderBy: { ratchetLastCheckedAt: 'asc' }, // Check oldest first
    }) as Promise<WorkspaceForRatchet[]>;
  }

  /**
   * Find a single READY workspace with PR for ratchet processing.
   */
  findForRatchetById(id: string): Promise<WorkspaceForRatchet | null> {
    return prisma.workspace.findFirst({
      where: {
        id,
        status: 'READY',
        prUrl: { not: null },
      },
      select: {
        id: true,
        prUrl: true,
        prNumber: true,
        prState: true,
        prCiStatus: true,
        defaultSessionProvider: true,
        ratchetSessionProvider: true,
        ratchetEnabled: true,
        ratchetState: true,
        ratchetActiveSessionId: true,
        ratchetLastCiRunId: true,
        prReviewLastCheckedAt: true,
      },
    }) as Promise<WorkspaceForRatchet | null>;
  }
}

export const workspaceAccessor = new WorkspaceAccessor();

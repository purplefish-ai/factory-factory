import { readdirSync, readFileSync } from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';
import ts from 'typescript';

const SOURCE_EXTENSIONS = ['.ts', '.tsx', '.mts', '.cts'];
const WORKSPACE_ACCESSOR_REL_PATH = 'src/backend/resource_accessors/workspace.accessor.ts';

const workspaceFieldOwners = {
  prUrl: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prNumber: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prState: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prReviewState: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prCiStatus: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prUpdatedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prCiFailedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prCiLastNotifiedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prReviewLastCheckedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prReviewLastCommentId: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),

  ratchetEnabled: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetState: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetLastCheckedAt: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetActiveSessionId: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetLastCiRunId: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),

  cachedKanbanColumn: new Set(['src/backend/domains/workspace/state/kanban-state.ts']),
  stateComputedAt: new Set(['src/backend/domains/workspace/state/kanban-state.ts']),

  worktreePath: new Set(['src/backend/orchestration/workspace-init.orchestrator.ts']),
  branchName: new Set([
    'src/backend/orchestration/workspace-init.orchestrator.ts',
    'src/backend/interceptors/branch-rename.interceptor.ts',
    'src/backend/domains/workspace/lifecycle/data.service.ts',
  ]),
  isAutoGeneratedBranch: new Set([
    'src/backend/orchestration/workspace-init.orchestrator.ts',
    'src/backend/domains/workspace/lifecycle/data.service.ts',
  ]),

  runScriptCommand: new Set([
    'src/backend/orchestration/workspace-init.orchestrator.ts',
    'src/backend/domains/workspace/query/workspace-query.service.ts',
    'src/backend/domains/workspace/lifecycle/data.service.ts',
  ]),
  runScriptCleanupCommand: new Set([
    'src/backend/orchestration/workspace-init.orchestrator.ts',
    'src/backend/domains/workspace/query/workspace-query.service.ts',
    'src/backend/domains/workspace/lifecycle/data.service.ts',
  ]),
};

const workspaceMutationRules = {
  update: { type: 'payload', payloadIndex: 1, requireStaticPayload: true },
  transitionWithCas: { type: 'payload', payloadIndex: 2, requireStaticPayload: false },
  casRunScriptStatusUpdate: { type: 'payload', payloadIndex: 2, requireStaticPayload: false },
  startProvisioningRetryIfAllowed: {
    type: 'static',
    fields: ['status', 'initRetryCount', 'initStartedAt', 'initErrorMessage'],
  },
  resetToNewIfAllowed: {
    type: 'static',
    fields: ['status', 'initRetryCount', 'initStartedAt', 'initCompletedAt', 'initErrorMessage'],
  },
  markHasHadSessions: { type: 'static', fields: ['hasHadSessions'] },
  clearRatchetActiveSession: { type: 'static', fields: ['ratchetActiveSessionId'] },
  clearInitOutput: { type: 'static', fields: ['initOutput'] },
};

function collectSourceFiles(dir) {
  const files = [];
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    if (entry.name === 'node_modules' || entry.name === 'dist') {
      continue;
    }
    const entryPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...collectSourceFiles(entryPath));
      continue;
    }
    if (SOURCE_EXTENSIONS.some((ext) => entry.name.endsWith(ext))) {
      files.push(entryPath);
    }
  }
  return files;
}

function isTestPath(relPath) {
  return (
    relPath.endsWith('.test.ts') ||
    relPath.endsWith('.test.tsx') ||
    relPath.endsWith('.stories.tsx') ||
    relPath.includes('/testing/')
  );
}

function getScriptKind(filePath) {
  if (filePath.endsWith('.tsx')) {
    return ts.ScriptKind.TSX;
  }
  return ts.ScriptKind.TS;
}

function getPropertyName(nameNode) {
  if (ts.isIdentifier(nameNode) || ts.isStringLiteral(nameNode) || ts.isNumericLiteral(nameNode)) {
    return nameNode.text;
  }
  return null;
}

function mergeExtraction(into, next) {
  for (const key of next.fields) {
    into.fields.add(key);
  }
  into.dynamic = into.dynamic || next.dynamic;
  return into;
}

function extractObjectFields(expression) {
  if (ts.isParenthesizedExpression(expression)) {
    return extractObjectFields(expression.expression);
  }

  if (ts.isAsExpression(expression) || ts.isSatisfiesExpression(expression)) {
    return extractObjectFields(expression.expression);
  }

  if (ts.isConditionalExpression(expression)) {
    const whenTrue = extractObjectFields(expression.whenTrue);
    const whenFalse = extractObjectFields(expression.whenFalse);
    return mergeExtraction(whenTrue, whenFalse);
  }

  if (ts.isBinaryExpression(expression)) {
    if (
      expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      expression.operatorToken.kind === ts.SyntaxKind.BarBarToken ||
      expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken
    ) {
      return extractObjectFields(expression.right);
    }
    return { fields: new Set(), dynamic: true };
  }

  if (!ts.isObjectLiteralExpression(expression)) {
    return { fields: new Set(), dynamic: true };
  }

  const result = { fields: new Set(), dynamic: false };

  for (const prop of expression.properties) {
    if (ts.isPropertyAssignment(prop)) {
      const name = getPropertyName(prop.name);
      if (name) {
        result.fields.add(name);
      } else {
        result.dynamic = true;
      }
      continue;
    }

    if (ts.isShorthandPropertyAssignment(prop)) {
      result.fields.add(prop.name.text);
      continue;
    }

    if (ts.isSpreadAssignment(prop)) {
      mergeExtraction(result, extractObjectFields(prop.expression));
      continue;
    }

    result.dynamic = true;
  }

  return result;
}

function isWorkspaceAccessorCallReceiver(receiver) {
  if (ts.isIdentifier(receiver) && receiver.text === 'workspaceAccessor') {
    return true;
  }

  return (
    ts.isPropertyAccessExpression(receiver) &&
    receiver.expression.kind === ts.SyntaxKind.ThisKeyword &&
    receiver.name.text === 'workspaces'
  );
}

function getWorkspaceMutationCall(node) {
  if (!ts.isCallExpression(node) || !ts.isPropertyAccessExpression(node.expression)) {
    return null;
  }

  const method = node.expression.name.text;
  const rule = workspaceMutationRules[method];
  if (!rule) {
    return null;
  }

  if (!isWorkspaceAccessorCallReceiver(node.expression.expression)) {
    return null;
  }

  return { method, rule };
}

function checkRestrictedProcedures(relPath, sourceText, violations) {
  if (relPath === 'src/backend/trpc/workspace.trpc.ts') {
    const hasGenericWorkspaceUpdate = /^\s*update:\s*publicProcedure/m.test(sourceText);
    if (hasGenericWorkspaceUpdate) {
      violations.push(
        `${relPath}: generic workspace update mutation is forbidden; use intent-specific procedures.`
      );
    }
  }

  if (relPath === 'src/backend/trpc/session.trpc.ts') {
    const hasTerminalStatusWrite =
      /updateTerminalSession[\s\S]*status:\s*z\.nativeEnum/.test(sourceText) ||
      /updateTerminalSession[\s\S]*pid:\s*z\.number/.test(sourceText);
    if (hasTerminalStatusWrite) {
      violations.push(
        `${relPath}: updateTerminalSession must not accept status/pid writes from tRPC.`
      );
    }
  }
}

function checkOwnershipForFields(relPath, fields, violations) {
  for (const field of fields) {
    const owners = workspaceFieldOwners[field];
    if (!owners) {
      continue;
    }

    if (!owners.has(relPath)) {
      const ownerList = Array.from(owners).join(', ');
      violations.push(
        `${relPath}: unauthorized write of workspace field "${field}". Allowed writer(s): ${ownerList}`
      );
    }
  }
}

function collectWorkspaceMutatingMethods(workspaceAccessorText, filePath = WORKSPACE_ACCESSOR_REL_PATH) {
  const sourceFile = ts.createSourceFile(
    filePath,
    workspaceAccessorText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath)
  );

  const mutatingMethods = new Set();

  function methodCallsWorkspacePrismaWrite(node) {
    let writes = false;

    function visit(inner) {
      if (writes) {
        return;
      }

      if (ts.isCallExpression(inner) && ts.isPropertyAccessExpression(inner.expression)) {
        const methodTarget = inner.expression.expression;
        if (
          ts.isPropertyAccessExpression(methodTarget) &&
          ts.isIdentifier(methodTarget.expression) &&
          methodTarget.expression.text === 'prisma' &&
          methodTarget.name.text === 'workspace' &&
          (inner.expression.name.text === 'update' || inner.expression.name.text === 'updateMany')
        ) {
          writes = true;
          return;
        }
      }

      ts.forEachChild(inner, visit);
    }

    visit(node);
    return writes;
  }

  function visit(node) {
    if (ts.isMethodDeclaration(node) && node.body && ts.isIdentifier(node.name)) {
      if (methodCallsWorkspacePrismaWrite(node.body)) {
        mutatingMethods.add(node.name.text);
      }
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return mutatingMethods;
}

function checkWorkspaceMutatorCoverage({ rootDir, violations }) {
  const accessorPath = path.join(rootDir, WORKSPACE_ACCESSOR_REL_PATH);
  const accessorText = readFileSync(accessorPath, 'utf8');
  const discovered = collectWorkspaceMutatingMethods(accessorText, accessorPath);
  const configured = new Set(Object.keys(workspaceMutationRules));

  const missingRules = Array.from(discovered)
    .filter((method) => !configured.has(method))
    .sort();
  if (missingRules.length > 0) {
    violations.push(
      `${WORKSPACE_ACCESSOR_REL_PATH}: workspace mutator(s) missing from checker rules: ${missingRules.join(', ')}`
    );
  }

  const staleRules = Array.from(configured)
    .filter((method) => !discovered.has(method))
    .sort();
  if (staleRules.length > 0) {
    violations.push(
      `${WORKSPACE_ACCESSOR_REL_PATH}: checker has stale mutator rule(s): ${staleRules.join(', ')}`
    );
  }
}

function checkSourceText(relPath, sourceText, violations) {
  checkRestrictedProcedures(relPath, sourceText, violations);

  const sourceFile = ts.createSourceFile(
    relPath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(relPath)
  );

  function visit(node) {
    const mutationCall = getWorkspaceMutationCall(node);
    if (mutationCall) {
      if (mutationCall.rule.type === 'payload') {
        const payload = node.arguments[mutationCall.rule.payloadIndex];
        if (!payload) {
          violations.push(
            `${relPath}: workspaceAccessor.${mutationCall.method} call is missing payload argument.`
          );
        } else {
          const extraction = extractObjectFields(payload);
          if (extraction.dynamic && mutationCall.rule.requireStaticPayload) {
            violations.push(
              `${relPath}: workspaceAccessor.${mutationCall.method} payload must be statically analyzable object literal.`
            );
          }
          checkOwnershipForFields(relPath, extraction.fields, violations);
        }
      } else {
        checkOwnershipForFields(relPath, mutationCall.rule.fields, violations);
      }
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
}

function checkFile(filePath, rootDir, violations) {
  const relPath = path.relative(rootDir, filePath).replaceAll(path.sep, '/');
  if (isTestPath(relPath)) {
    return;
  }

  const sourceText = readFileSync(filePath, 'utf8');
  checkSourceText(relPath, sourceText, violations);
}

export function collectSingleWriterViolations({
  rootDir = process.cwd(),
  backendDir = path.join(rootDir, 'src/backend'),
} = {}) {
  const violations = [];
  checkWorkspaceMutatorCoverage({ rootDir, violations });

  const sourceFiles = collectSourceFiles(backendDir);
  for (const filePath of sourceFiles) {
    checkFile(filePath, rootDir, violations);
  }

  return violations;
}

function reportViolations(violations) {
  if (violations.length === 0) {
    return;
  }

  console.error('Single-writer ownership violations found:\n');
  for (const violation of violations) {
    console.error(`- ${violation}`);
  }
}

export function runSingleWriterCheck(options = {}) {
  const violations = collectSingleWriterViolations(options);
  reportViolations(violations);
  return violations.length === 0;
}

function isExecutedDirectly() {
  const entryPath = process.argv[1];
  if (!entryPath) {
    return false;
  }
  return path.resolve(entryPath) === fileURLToPath(import.meta.url);
}

if (isExecutedDirectly()) {
  const passed = runSingleWriterCheck();
  if (!passed) {
    process.exit(1);
  }
}

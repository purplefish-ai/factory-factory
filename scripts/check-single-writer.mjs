import { readdirSync, readFileSync } from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import ts from 'typescript';

const ROOT_DIR = process.cwd();
const BACKEND_DIR = path.join(ROOT_DIR, 'src/backend');
const SOURCE_EXTENSIONS = ['.ts', '.tsx', '.mts', '.cts'];

const workspaceFieldOwners = {
  prUrl: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prNumber: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prState: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prReviewState: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prCiStatus: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prUpdatedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prCiFailedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prCiLastNotifiedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prReviewLastCheckedAt: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),
  prReviewLastCommentId: new Set(['src/backend/domains/github/pr-snapshot.service.ts']),

  ratchetEnabled: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetState: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetLastCheckedAt: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetLastPushAt: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetActiveSessionId: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),
  ratchetLastCiRunId: new Set(['src/backend/domains/ratchet/ratchet.service.ts']),

  cachedKanbanColumn: new Set(['src/backend/domains/workspace/state/kanban-state.ts']),
  stateComputedAt: new Set(['src/backend/domains/workspace/state/kanban-state.ts']),

  worktreePath: new Set(['src/backend/orchestration/workspace-init.orchestrator.ts']),
  branchName: new Set([
    'src/backend/orchestration/workspace-init.orchestrator.ts',
    'src/backend/interceptors/branch-rename.interceptor.ts',
    'src/backend/domains/workspace/lifecycle/data.service.ts',
  ]),
  isAutoGeneratedBranch: new Set(['src/backend/orchestration/workspace-init.orchestrator.ts']),

  runScriptCommand: new Set([
    'src/backend/orchestration/workspace-init.orchestrator.ts',
    'src/backend/domains/workspace/query/workspace-query.service.ts',
  ]),
  runScriptCleanupCommand: new Set([
    'src/backend/orchestration/workspace-init.orchestrator.ts',
    'src/backend/domains/workspace/query/workspace-query.service.ts',
  ]),
};

function collectSourceFiles(dir) {
  const files = [];
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    if (entry.name === 'node_modules' || entry.name === 'dist') {
      continue;
    }
    const entryPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...collectSourceFiles(entryPath));
      continue;
    }
    if (SOURCE_EXTENSIONS.some((ext) => entry.name.endsWith(ext))) {
      files.push(entryPath);
    }
  }
  return files;
}

function isTestPath(relPath) {
  return (
    relPath.endsWith('.test.ts') ||
    relPath.endsWith('.test.tsx') ||
    relPath.endsWith('.stories.tsx') ||
    relPath.includes('/testing/')
  );
}

function getScriptKind(filePath) {
  if (filePath.endsWith('.tsx')) {
    return ts.ScriptKind.TSX;
  }
  return ts.ScriptKind.TS;
}

function getPropertyName(nameNode) {
  if (ts.isIdentifier(nameNode) || ts.isStringLiteral(nameNode) || ts.isNumericLiteral(nameNode)) {
    return nameNode.text;
  }
  return null;
}

function mergeExtraction(into, next) {
  for (const key of next.fields) {
    into.fields.add(key);
  }
  into.dynamic = into.dynamic || next.dynamic;
  return into;
}

function extractObjectFields(expression) {
  if (ts.isParenthesizedExpression(expression)) {
    return extractObjectFields(expression.expression);
  }

  if (ts.isAsExpression(expression) || ts.isSatisfiesExpression(expression)) {
    return extractObjectFields(expression.expression);
  }

  if (ts.isConditionalExpression(expression)) {
    const whenTrue = extractObjectFields(expression.whenTrue);
    const whenFalse = extractObjectFields(expression.whenFalse);
    return mergeExtraction(whenTrue, whenFalse);
  }

  if (ts.isBinaryExpression(expression)) {
    if (
      expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken ||
      expression.operatorToken.kind === ts.SyntaxKind.BarBarToken ||
      expression.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken
    ) {
      return extractObjectFields(expression.right);
    }
    return { fields: new Set(), dynamic: true };
  }

  if (!ts.isObjectLiteralExpression(expression)) {
    return { fields: new Set(), dynamic: true };
  }

  const result = { fields: new Set(), dynamic: false };

  for (const prop of expression.properties) {
    if (ts.isPropertyAssignment(prop)) {
      const name = getPropertyName(prop.name);
      if (name) {
        result.fields.add(name);
      } else {
        result.dynamic = true;
      }
      continue;
    }

    if (ts.isShorthandPropertyAssignment(prop)) {
      result.fields.add(prop.name.text);
      continue;
    }

    if (ts.isSpreadAssignment(prop)) {
      mergeExtraction(result, extractObjectFields(prop.expression));
      continue;
    }

    result.dynamic = true;
  }

  return result;
}

function isWorkspaceAccessorUpdateCall(node) {
  if (!ts.isCallExpression(node)) {
    return false;
  }
  if (!ts.isPropertyAccessExpression(node.expression)) {
    return false;
  }
  const target = node.expression.expression;
  const method = node.expression.name.text;
  return ts.isIdentifier(target) && target.text === 'workspaceAccessor' && method === 'update';
}

function checkRestrictedProcedures(relPath, sourceText, violations) {
  if (relPath === 'src/backend/trpc/workspace.trpc.ts') {
    const hasGenericWorkspaceUpdate = /^\s*update:\s*publicProcedure/m.test(sourceText);
    if (hasGenericWorkspaceUpdate) {
      violations.push(
        `${relPath}: generic workspace update mutation is forbidden; use intent-specific procedures.`
      );
    }
  }

  if (relPath === 'src/backend/trpc/session.trpc.ts') {
    const hasTerminalStatusWrite =
      /updateTerminalSession[\s\S]*status:\s*z\.nativeEnum/.test(sourceText) ||
      /updateTerminalSession[\s\S]*pid:\s*z\.number/.test(sourceText);
    if (hasTerminalStatusWrite) {
      violations.push(
        `${relPath}: updateTerminalSession must not accept status/pid writes from tRPC.`
      );
    }
  }
}

function checkFile(filePath, violations) {
  const relPath = path.relative(ROOT_DIR, filePath).replaceAll(path.sep, '/');
  if (isTestPath(relPath)) {
    return;
  }

  const sourceText = readFileSync(filePath, 'utf8');
  checkRestrictedProcedures(relPath, sourceText, violations);

  const sourceFile = ts.createSourceFile(
    filePath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    getScriptKind(filePath)
  );

  function visit(node) {
    if (isWorkspaceAccessorUpdateCall(node)) {
      const payload = node.arguments[1];
      if (!payload) {
        violations.push(`${relPath}: workspaceAccessor.update call is missing payload argument.`);
      } else {
        const extraction = extractObjectFields(payload);
        if (extraction.dynamic) {
          violations.push(
            `${relPath}: workspaceAccessor.update payload must be statically analyzable object literal.`
          );
        }

        for (const field of extraction.fields) {
          const owners = workspaceFieldOwners[field];
          if (!owners) {
            continue;
          }
          if (!owners.has(relPath)) {
            const ownerList = Array.from(owners).join(', ');
            violations.push(
              `${relPath}: unauthorized write of workspace field "${field}". Allowed writer(s): ${ownerList}`
            );
          }
        }
      }
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
}

const sourceFiles = collectSourceFiles(BACKEND_DIR);
const violations = [];

for (const filePath of sourceFiles) {
  checkFile(filePath, violations);
}

if (violations.length > 0) {
  console.error('Single-writer ownership violations found:\n');
  for (const violation of violations) {
    console.error(`- ${violation}`);
  }
  process.exit(1);
}

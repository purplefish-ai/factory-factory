---
phase: 11-snapshot-store
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/backend/services/workspace-snapshot-store.service.test.ts
autonomous: true

must_haves:
  truths:
    - "Store creates entries on first upsert and returns them by workspaceId"
    - "Version counter increments on every upsert to the same workspace"
    - "Debug metadata (computedAt, source) is set on every upsert"
    - "Remove deletes entries and project index references"
    - "Field-level timestamps prevent older updates from overwriting newer data"
    - "Derived state recomputes correctly when raw fields change"
    - "Events are emitted on upsert and remove"
    - "Project index enables getByProjectId to return correct entries"
  artifacts:
    - path: "src/backend/services/workspace-snapshot-store.service.test.ts"
      provides: "Comprehensive test suite for WorkspaceSnapshotStore"
      min_lines: 250
  key_links:
    - from: "src/backend/services/workspace-snapshot-store.service.test.ts"
      to: "src/backend/services/workspace-snapshot-store.service.ts"
      via: "imports WorkspaceSnapshotStore class for fresh instance testing"
      pattern: "import.*WorkspaceSnapshotStore.*from"
---

<objective>
Create a comprehensive test suite for the WorkspaceSnapshotStore service, covering all 8 requirements (STORE-01 through STORE-06, ARCH-01, ARCH-02) and all public methods.

Purpose: Verify correctness of the snapshot store before downstream phases build on it. Tests validate CRUD operations, version counting, field-level timestamp merging, derived state recomputation, event emission, project indexing, and cleanup.

Output: A co-located test file with passing tests that serve as a specification for the store's behavior.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-snapshot-store/11-RESEARCH.md
@.planning/phases/11-snapshot-store/11-01-SUMMARY.md
@src/backend/services/workspace-snapshot-store.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test suite for store CRUD, versioning, timestamps, and project index</name>
  <files>src/backend/services/workspace-snapshot-store.service.test.ts</files>
  <action>
Create `src/backend/services/workspace-snapshot-store.service.test.ts` following existing test patterns (see `scheduler.service.test.ts`, `data-backup.service.test.ts` for conventions).

**Setup:**

Mock the logger service (standard pattern):
```typescript
vi.mock('./logger.service', () => ({
  createLogger: () => ({
    info: vi.fn(),
    debug: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));
```

Import the `WorkspaceSnapshotStore` CLASS (not the singleton) so each test gets a fresh instance. Import Prisma enums from `@prisma-gen/client`.

Create a `beforeEach` that instantiates a fresh store and configures it with mock derivation functions:
```typescript
let store: WorkspaceSnapshotStore;

beforeEach(() => {
  store = new WorkspaceSnapshotStore();
  store.configure({
    deriveFlowState: (input) => ({
      phase: 'NO_PR' as const,
      ciObservation: 'CHECKS_UNKNOWN' as const,
      isWorking: false,
      shouldAnimateRatchetButton: false,
    }),
    computeKanbanColumn: (input) => KanbanColumn.WORKING,
    deriveSidebarStatus: (input) => ({
      activityState: 'IDLE' as const,
      ciState: 'NONE' as const,
    }),
  });
});
```

Create a helper function `makeUpdate(overrides?)` that returns a valid `SnapshotUpdateInput` with sensible defaults including `projectId`.

**Test cases to implement:**

**describe('STORE-01: Basic CRUD operations')**

1. `'creates entry on first upsert'` -- upsert with workspaceId + projectId, verify getByWorkspaceId returns entry with correct workspaceId and projectId.

2. `'returns undefined for non-existent workspaceId'` -- getByWorkspaceId('nonexistent') returns undefined.

3. `'updates existing entry on subsequent upsert'` -- upsert twice with same workspaceId but different name. Verify getByWorkspaceId returns updated name.

4. `'getByProjectId returns entries for a project'` -- upsert 3 entries: 2 for project A, 1 for project B. Verify getByProjectId('A') returns exactly 2, getByProjectId('B') returns exactly 1.

5. `'getByProjectId returns empty array for unknown project'` -- getByProjectId('nonexistent') returns [].

6. `'size returns correct count'` -- upsert 3 entries, verify size() === 3.

**describe('STORE-02: Version counter')**

7. `'version starts at 1 on first upsert'` -- upsert once, verify version === 1.

8. `'version increments on each upsert'` -- upsert same workspaceId 5 times, verify version === 5.

9. `'each workspace has independent version counter'` -- upsert workspace A twice, workspace B once. A.version === 2, B.version === 1.

10. `'getVersion returns version for existing entry'` -- upsert, then getVersion returns same as entry.version.

11. `'getVersion returns undefined for non-existent entry'` -- getVersion('nonexistent') returns undefined.

**describe('STORE-03: Debug metadata')**

12. `'sets computedAt as ISO timestamp on upsert'` -- upsert, verify computedAt is a valid ISO string (can parse with new Date()).

13. `'sets source from upsert argument'` -- upsert with source='event:pr_state_change', verify entry.source matches.

14. `'updates computedAt and source on each upsert'` -- upsert twice with different sources, verify source reflects the latest call.

**describe('STORE-04: Cleanup on remove')**

15. `'remove deletes entry'` -- upsert then remove, verify getByWorkspaceId returns undefined.

16. `'remove cleans up project index'` -- upsert 2 entries for project A, remove one. getByProjectId('A') returns 1 entry. Remove the other. getByProjectId('A') returns [].

17. `'remove returns true when entry existed'` -- upsert then remove returns true.

18. `'remove returns false when entry did not exist'` -- remove('nonexistent') returns false.

19. `'removed entry cannot be queried'` -- upsert, remove, getByWorkspaceId returns undefined, getVersion returns undefined.

20. `'clear removes all entries'` -- upsert 3 entries, clear(), size() === 0, getByProjectId returns [].

**describe('STORE-06: Field-level timestamps for concurrent update safety')**

21. `'newer timestamp overwrites fields'` -- upsert with name='old' at timestamp 100, then upsert with name='new' at timestamp 200. Entry has name='new'.

22. `'older timestamp does not overwrite newer fields'` -- upsert with name='new' at timestamp 200, then upsert with name='old' at timestamp 100. Entry still has name='new'.

23. `'different field groups can update independently'` -- upsert workspace fields at timestamp 100, then upsert PR fields at timestamp 50. Workspace fields are at timestamp 100 values, PR fields are at timestamp 50 values (PR group was 0 initially, so 50 > 0).

24. `'same-timestamp updates are accepted (>=)'` -- Wait, the comparison should be `>` (strictly newer). Verify: upsert at timestamp 100, then upsert same group at timestamp 100 -- should NOT overwrite (same timestamp is not newer). Verify original values preserved.

**describe('Project index management')**

25. `'handles project index when projectId changes'` -- upsert workspace W1 with projectId A, then upsert W1 with projectId B. getByProjectId('A') should not contain W1, getByProjectId('B') should contain W1.

26. `'project index is cleaned up when last entry removed'` -- upsert 1 entry for project A, remove it. Internal project index should not leak (verify via getByProjectId returning []).
  </action>
  <verify>
Run `pnpm test src/backend/services/workspace-snapshot-store.service.test.ts` -- all tests pass.
  </verify>
  <done>
Test cases 1-26 pass, covering STORE-01 (CRUD), STORE-02 (versioning), STORE-03 (debug metadata), STORE-04 (cleanup), STORE-06 (field-level timestamps), and project index management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for derived state recomputation and event emission</name>
  <files>src/backend/services/workspace-snapshot-store.service.test.ts</files>
  <action>
Add the following test groups to the SAME test file created in Task 1:

**describe('STORE-05 + STORE-06: Derived state recomputation')**

For these tests, configure the store with MORE REALISTIC mock derivation functions that actually respond to input values:

```typescript
// Use a describe block with its own beforeEach that configures smarter mocks
store.configure({
  deriveFlowState: (input) => ({
    phase: input.prUrl ? 'CI_WAIT' : 'NO_PR',
    ciObservation: input.prCiStatus === 'SUCCESS' ? 'CHECKS_PASSED' : 'CHECKS_UNKNOWN',
    isWorking: input.prUrl !== null && input.prCiStatus === 'PENDING',
    shouldAnimateRatchetButton: input.ratchetEnabled && input.prCiStatus === 'PENDING',
  }),
  computeKanbanColumn: (input) => {
    if (input.isWorking) return 'WORKING';
    if (input.prState === 'MERGED') return 'DONE';
    return 'WAITING';
  },
  deriveSidebarStatus: (input) => ({
    activityState: input.isWorking ? 'WORKING' : 'IDLE',
    ciState: input.prUrl ? 'RUNNING' : 'NONE',
  }),
});
```

27. `'derived state is computed on first upsert'` -- upsert with prUrl=null. Verify flowPhase === 'NO_PR', kanbanColumn === 'WAITING' (not working, not merged), sidebarStatus.ciState === 'NONE'.

28. `'derived state recomputes when raw fields change'` -- upsert with prUrl=null (NO_PR), then upsert same workspace with prUrl='https://github.com/...' and prCiStatus=PENDING. Verify flowPhase changed to 'CI_WAIT', sidebarStatus.ciState changed to 'RUNNING'.

29. `'kanbanColumn reflects isWorking from flow state'` -- upsert with prUrl set + prCiStatus=PENDING (mock flow state returns isWorking=true). Verify kanbanColumn === 'WORKING'.

30. `'ratchetButtonAnimated reflects flow state'` -- upsert with ratchetEnabled=true + prCiStatus=PENDING. Verify ratchetButtonAnimated === true.

31. `'derived state uses effective isWorking (session OR flow)'` -- upsert with isWorking=true (from session) and prUrl=null (flow isWorking=false). The effective isWorking for sidebar should be true.

**describe('Event emission')**

32. `'emits snapshot_changed on upsert'` -- register listener with store.on(SNAPSHOT_CHANGED, handler). Upsert. Verify handler called with { workspaceId, projectId, entry }.

33. `'emits snapshot_removed on remove'` -- register listener with store.on(SNAPSHOT_REMOVED, handler). Upsert then remove. Verify handler called with { workspaceId, projectId }.

34. `'does not emit snapshot_removed for non-existent entry'` -- register listener. Remove('nonexistent'). Verify handler NOT called.

35. `'snapshot_changed event has fully consistent entry'` -- register listener that captures the entry. On event, verify derived state fields are already computed (not stale). Specifically: if prUrl was set in upsert, the captured entry's flowPhase should reflect it.

36. `'emits one event per upsert call'` -- register listener with counter. Upsert 3 times. Counter === 3.

**describe('Error handling')**

37. `'throws on upsert without configure()'` -- create a new store WITHOUT calling configure(). Upsert should throw 'not configured'.

38. `'throws on first upsert without projectId'` -- upsert with update that has no projectId field. Should throw descriptive error.

**describe('ARCH-02: No domain imports')**

39. `'service file has zero imports from @/backend/domains/'` -- This is a static check. Read the service file content and assert it does not contain the string `@/backend/domains/`. Implementation: use `fs.readFileSync` to read `workspace-snapshot-store.service.ts` and assert no match. (Or skip this and rely on the verification step grep.)

After all tests are written, run the full test suite to verify no regressions:

Run `pnpm test` (full suite) and `pnpm typecheck` to ensure the test file compiles and all existing tests still pass.
  </action>
  <verify>
Run `pnpm test src/backend/services/workspace-snapshot-store.service.test.ts` -- all tests pass (expect ~35-39 tests).
Run `pnpm test` -- full test suite passes with zero regressions.
Run `pnpm typecheck` -- zero errors.
  </verify>
  <done>
Complete test suite passes with ~35+ test cases covering all 8 requirements. Full project test suite passes with zero regressions. TypeScript compiles clean. The snapshot store is fully specified and verified.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test src/backend/services/workspace-snapshot-store.service.test.ts` -- all tests pass
2. `pnpm test` -- full test suite (1609+ tests) passes with zero regressions
3. `pnpm typecheck` -- zero errors
4. Test file covers: CRUD (STORE-01), versioning (STORE-02), debug metadata (STORE-03), cleanup (STORE-04), derived state (STORE-05), field-level timestamps (STORE-06), ARCH-01, ARCH-02
</verification>

<success_criteria>
- Test file exists at src/backend/services/workspace-snapshot-store.service.test.ts with 35+ passing test cases
- Tests cover all 8 requirements (STORE-01 through STORE-06, ARCH-01, ARCH-02)
- Tests verify concurrent update safety via field-level timestamp comparison
- Tests verify derived state recomputation responds to raw field changes
- Tests verify event emission timing (after all state is consistent)
- Full project test suite passes with zero regressions
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-snapshot-store/11-02-SUMMARY.md`
</output>

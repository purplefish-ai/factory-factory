---
phase: 11-snapshot-store
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backend/services/workspace-snapshot-store.service.ts
  - src/backend/services/index.ts
  - src/backend/orchestration/domain-bridges.orchestrator.ts
autonomous: true

must_haves:
  truths:
    - "Snapshot store can be created, queried by workspaceId, and returns entries with version counter and debug metadata"
    - "When a workspace is archived or deleted, its snapshot entry is removed and cannot be queried"
    - "Snapshot entries include derived state fields that recompute when underlying fields change"
    - "The service lives in src/backend/services/ and has zero imports from @/backend/domains/"
    - "Concurrent updates to the same workspace preserve the newest data via field-level timestamps"
  artifacts:
    - path: "src/backend/services/workspace-snapshot-store.service.ts"
      provides: "WorkspaceSnapshotStore class, types, singleton export"
      min_lines: 200
    - path: "src/backend/services/index.ts"
      provides: "Barrel export of snapshot store"
      contains: "workspace-snapshot-store"
    - path: "src/backend/orchestration/domain-bridges.orchestrator.ts"
      provides: "Derivation function injection via configure()"
      contains: "workspaceSnapshotStore.configure"
  key_links:
    - from: "src/backend/orchestration/domain-bridges.orchestrator.ts"
      to: "src/backend/services/workspace-snapshot-store.service.ts"
      via: "configure() call injecting derivation functions"
      pattern: "workspaceSnapshotStore\\.configure"
    - from: "src/backend/services/workspace-snapshot-store.service.ts"
      to: "EventEmitter"
      via: "extends EventEmitter, emits snapshot_changed and snapshot_removed"
      pattern: "extends EventEmitter"
---

<objective>
Create the core WorkspaceSnapshotStore service -- a versioned, per-workspace in-memory store with field-level timestamp merging, derived state recomputation via injected functions, and EventEmitter-based change notifications.

Purpose: This is the foundational data structure for the v1.1 Project Snapshot Service. All subsequent phases (event collection, reconciliation, WebSocket transport, client integration) build on this store.

Output: A fully functional snapshot store service file, exported from the services barrel, with derivation functions wired via domain-bridges at startup.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-snapshot-store/11-RESEARCH.md
@src/backend/services/index.ts
@src/backend/orchestration/domain-bridges.orchestrator.ts
@src/backend/domains/workspace/lifecycle/activity.service.ts
@src/backend/domains/workspace/state/flow-state.ts
@src/backend/domains/workspace/state/kanban-state.ts
@src/shared/workspace-sidebar-status.ts
@src/backend/domains/workspace/query/workspace-query.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkspaceSnapshotStore service with types, class, and all methods</name>
  <files>src/backend/services/workspace-snapshot-store.service.ts</files>
  <action>
Create `src/backend/services/workspace-snapshot-store.service.ts` with the following structure:

**Types and interfaces (top of file):**

1. `SnapshotFieldGroup` -- string literal union for timestamp group keys: `'workspace'`, `'pr'`, `'session'`, `'ratchet'`, `'runScript'`, `'reconciliation'`. These represent coherent groups of fields that update together from a single event source (per research recommendation: group timestamps by update source, not per-field).

2. `WorkspaceSnapshotEntry` -- the full snapshot entry shape, matching the output of `getProjectSummaryState()` in workspace-query.service.ts (lines 187-215). Fields:
   - Identity: `workspaceId: string`, `projectId: string`
   - Versioning (STORE-02): `version: number` (monotonically increasing per entry)
   - Debug metadata (STORE-03): `computedAt: string` (ISO timestamp), `source: string` (e.g. `'event:workspace_state_change'`, `'reconciliation'`)
   - Raw workspace state: `name: string`, `status: WorkspaceStatus`, `createdAt: string`, `branchName: string | null`, `prUrl: string | null`, `prNumber: number | null`, `prState: PRState`, `prCiStatus: CIStatus`, `prUpdatedAt: string | null`, `ratchetEnabled: boolean`, `ratchetState: RatchetState`, `runScriptStatus: RunScriptStatus`, `hasHadSessions: boolean`
   - In-memory state (from session domain): `isWorking: boolean`, `pendingRequestType: 'plan_approval' | 'user_question' | null`
   - Reconciliation-only state: `gitStats: { total: number; additions: number; deletions: number; hasUncommitted: boolean } | null`, `lastActivityAt: string | null`
   - Derived state (STORE-05): `sidebarStatus: WorkspaceSidebarStatus`, `kanbanColumn: KanbanColumn | null`, `flowPhase: WorkspaceFlowPhase`, `ciObservation: WorkspaceCiObservation`, `ratchetButtonAnimated: boolean`
   - Field-level timestamps: `fieldTimestamps: Record<SnapshotFieldGroup, number>` (Date.now() values for concurrent update safety)

   Import Prisma enums from `@prisma-gen/client`: `CIStatus`, `KanbanColumn`, `PRState`, `RatchetState`, `RunScriptStatus`, `WorkspaceStatus`. Import `WorkspaceSidebarStatus` from `@/shared/workspace-sidebar-status`. For `WorkspaceFlowPhase` and `WorkspaceCiObservation`, define them as string literal types DIRECTLY in this file (do NOT import from `@/backend/domains/workspace` -- ARCH-02 violation). Use the same values as the domain module: `WorkspaceFlowPhase = 'NO_PR' | 'CI_WAIT' | 'RATCHET_VERIFY' | 'RATCHET_FIXING' | 'READY' | 'MERGED'` and `WorkspaceCiObservation = 'NOT_FETCHED' | 'NO_CHECKS' | 'CHECKS_PENDING' | 'CHECKS_FAILED' | 'CHECKS_PASSED' | 'CHECKS_UNKNOWN'`.

3. `SnapshotUpdateInput` -- a Partial-like type for `upsert()` input. Contains optional versions of all raw fields + session fields + reconciliation fields. Does NOT include derived fields (those are recomputed). Does NOT include version/computedAt/source (those are managed by the store). Each field group has an optional `timestamp` for that group. Structure:
   ```
   interface SnapshotUpdateInput {
     projectId?: string;  // Required on first upsert, optional on updates
     // Workspace fields (group: 'workspace')
     name?: string;
     status?: WorkspaceStatus;
     createdAt?: string;
     branchName?: string | null;
     hasHadSessions?: boolean;
     // PR fields (group: 'pr')
     prUrl?: string | null;
     prNumber?: number | null;
     prState?: PRState;
     prCiStatus?: CIStatus;
     prUpdatedAt?: string | null;
     // Session fields (group: 'session')
     isWorking?: boolean;
     pendingRequestType?: 'plan_approval' | 'user_question' | null;
     // Ratchet fields (group: 'ratchet')
     ratchetEnabled?: boolean;
     ratchetState?: RatchetState;
     // Run-script fields (group: 'runScript')
     runScriptStatus?: RunScriptStatus;
     // Reconciliation fields (group: 'reconciliation')
     gitStats?: { total: number; additions: number; deletions: number; hasUncommitted: boolean } | null;
     lastActivityAt?: string | null;
   }
   ```

4. `SnapshotDerivationFns` -- interface for injected derivation functions (ARCH-02 compliance). Three functions matching the signatures of the existing pure functions but expressed as callback types:
   ```
   interface SnapshotDerivationFns {
     deriveFlowState: (input: {
       prUrl: string | null;
       prState: PRState;
       prCiStatus: CIStatus;
       prUpdatedAt: string | null;  // NOTE: string, not Date -- snapshot stores ISO strings
       ratchetEnabled: boolean;
       ratchetState: RatchetState;
     }) => {
       phase: WorkspaceFlowPhase;
       ciObservation: WorkspaceCiObservation;
       isWorking: boolean;
       shouldAnimateRatchetButton: boolean;
     };
     computeKanbanColumn: (input: {
       lifecycle: WorkspaceStatus;
       isWorking: boolean;
       prState: PRState;
       hasHadSessions: boolean;
     }) => KanbanColumn | null;
     deriveSidebarStatus: (input: {
       isWorking: boolean;
       prUrl: string | null;
       prState: PRState | null;
       prCiStatus: CIStatus | null;
       ratchetState: RatchetState | null;
     }) => WorkspaceSidebarStatus;
   }
   ```

5. Event name constants: `SNAPSHOT_CHANGED = 'snapshot_changed'` and `SNAPSHOT_REMOVED = 'snapshot_removed'` as exported const strings.

6. Event payload types:
   ```
   interface SnapshotChangedEvent {
     workspaceId: string;
     projectId: string;
     entry: WorkspaceSnapshotEntry;
   }
   interface SnapshotRemovedEvent {
     workspaceId: string;
     projectId: string;
   }
   ```

**Class implementation:**

`WorkspaceSnapshotStore extends EventEmitter` with:

- Private state: `entries = new Map<string, WorkspaceSnapshotEntry>()`, `projectIndex = new Map<string, Set<string>>()`, `deriveFns: SnapshotDerivationFns | null = null`
- Logger: `const logger = createLogger('workspace-snapshot-store')` at module level

- `configure(fns: SnapshotDerivationFns): void` -- stores derivation functions. Log info on configure.

- Private getter `private get derive(): SnapshotDerivationFns` -- throws descriptive error if not configured (matching KanbanStateService pattern: `'WorkspaceSnapshotStore not configured: call configure() first.'`).

- `upsert(workspaceId: string, update: SnapshotUpdateInput, source: string, timestamp?: number): void`
  1. Use `timestamp ?? Date.now()` for the update timestamp
  2. Get existing entry or create new one. On create, `projectId` is required in update (throw if missing). Initialize all fields to sensible defaults (empty strings, null, false, enums: `PRState.NONE`, `CIStatus.UNKNOWN`, `RatchetState.IDLE`, `RunScriptStatus.IDLE`, `WorkspaceStatus.NEW`). Initialize `fieldTimestamps` with all groups set to 0. Set version to 0 (will be bumped below).
  3. **Field-level timestamp merge:** For each field group present in the update, check if `timestamp > entry.fieldTimestamps[group]`. Only update fields in that group if the timestamp is newer. The mapping of fields to groups:
     - `'workspace'`: name, status, createdAt, branchName, hasHadSessions
     - `'pr'`: prUrl, prNumber, prState, prCiStatus, prUpdatedAt
     - `'session'`: isWorking, pendingRequestType
     - `'ratchet'`: ratchetEnabled, ratchetState
     - `'runScript'`: runScriptStatus
     - `'reconciliation'`: gitStats, lastActivityAt
     Also update projectId if provided (for the case where a workspace moves between projects, though unlikely).
  4. **Recompute derived state** using `this.derive`:
     - Call `deriveFlowState()` with the entry's current raw fields. Extract `phase`, `ciObservation`, `shouldAnimateRatchetButton`. Also compute effective `isWorking` as `entry.isWorking || flowState.isWorking` (session activity OR flow-state working). Use this effective isWorking for kanban computation.
     - Call `computeKanbanColumn()` with lifecycle=entry.status, isWorking=effectiveIsWorking, prState=entry.prState, hasHadSessions=entry.hasHadSessions
     - Call `deriveSidebarStatus()` with isWorking=effectiveIsWorking, prUrl=entry.prUrl, prState=entry.prState, prCiStatus=entry.prCiStatus, ratchetState=entry.ratchetState
     - Update derived fields on entry: `flowPhase`, `ciObservation`, `kanbanColumn`, `sidebarStatus`, `ratchetButtonAnimated`
  5. **Bump version** (increment by 1)
  6. **Update metadata:** `computedAt = new Date().toISOString()`, `source = source`
  7. **Update project index:** Ensure workspaceId is in the Set for entry.projectId. If projectId changed from old value, remove from old Set.
  8. **Store entry** in entries map
  9. **Emit** `SNAPSHOT_CHANGED` event with `{ workspaceId, projectId: entry.projectId, entry }` (emit AFTER all state is consistent -- per research pitfall 5)
  10. Log debug: `'Snapshot updated'` with `{ workspaceId, version: entry.version, source }`

  IMPORTANT for the flow state derivation: The existing `deriveWorkspaceFlowState` function takes `prUpdatedAt: Date | null` but the snapshot stores ISO strings. The `SnapshotDerivationFns.deriveFlowState` accepts `prUpdatedAt: string | null`. The wiring in domain-bridges (Task 2) will handle the conversion.

- `remove(workspaceId: string): boolean`
  1. Get entry from map. If not found, return false.
  2. Delete from entries map.
  3. Remove from project index (delete workspaceId from the Set for entry.projectId; if Set becomes empty, delete the projectId key).
  4. Emit `SNAPSHOT_REMOVED` event with `{ workspaceId, projectId: entry.projectId }`.
  5. Log debug: `'Snapshot removed'` with `{ workspaceId, projectId: entry.projectId }`
  6. Return true.

- `getByWorkspaceId(workspaceId: string): WorkspaceSnapshotEntry | undefined` -- direct map lookup.

- `getByProjectId(projectId: string): WorkspaceSnapshotEntry[]` -- get Set from projectIndex, map to entries, filter out undefined (defensive).

- `getVersion(workspaceId: string): number | undefined` -- return entry?.version.

- `size(): number` -- return entries.size (for testing/debugging).

- `clear(): void` -- clear entries map and projectIndex. Log info. (Useful for testing and server shutdown.)

**Singleton export:** `export const workspaceSnapshotStore = new WorkspaceSnapshotStore();`

Also export the class itself for testing: `export { WorkspaceSnapshotStore }`.

**CRITICAL -- ARCH-02 compliance:** The file must have ZERO imports from `@/backend/domains/`. Verify this explicitly. The only allowed imports are:
- `import { EventEmitter } from 'node:events'`
- `import type { ... } from '@prisma-gen/client'`
- `import type { WorkspaceSidebarStatus } from '@/shared/workspace-sidebar-status'`
- `import { createLogger } from './logger.service'` (relative within services/)

Also export all types needed by consumers: `WorkspaceSnapshotEntry`, `SnapshotUpdateInput`, `SnapshotDerivationFns`, `SnapshotFieldGroup`, `SnapshotChangedEvent`, `SnapshotRemovedEvent`, `SNAPSHOT_CHANGED`, `SNAPSHOT_REMOVED`, `WorkspaceFlowPhase`, `WorkspaceCiObservation`.
  </action>
  <verify>
Run `pnpm typecheck` -- should pass with zero errors.
Run `grep -r "@/backend/domains" src/backend/services/workspace-snapshot-store.service.ts` -- should return nothing (ARCH-02).
Verify file exists and has >200 lines.
  </verify>
  <done>
WorkspaceSnapshotStore class exists with upsert(), remove(), getByWorkspaceId(), getByProjectId(), getVersion(), size(), clear() methods. Types are exported. No domain imports present. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add barrel export and wire derivation functions via domain-bridges</name>
  <files>src/backend/services/index.ts, src/backend/orchestration/domain-bridges.orchestrator.ts</files>
  <action>
**1. Update `src/backend/services/index.ts`:**

Add exports for the snapshot store service. Place alphabetically among existing exports (after scheduler, before server-instance):

```typescript
// Workspace snapshot store service
export {
  type SnapshotChangedEvent,
  type SnapshotDerivationFns,
  type SnapshotFieldGroup,
  type SnapshotRemovedEvent,
  type SnapshotUpdateInput,
  SNAPSHOT_CHANGED,
  SNAPSHOT_REMOVED,
  type WorkspaceCiObservation,
  type WorkspaceFlowPhase,
  type WorkspaceSnapshotEntry,
  workspaceSnapshotStore,
} from './workspace-snapshot-store.service';
```

**2. Update `src/backend/orchestration/domain-bridges.orchestrator.ts`:**

Add import at top (with existing domain imports):
```typescript
import { deriveWorkspaceFlowState } from '@/backend/domains/workspace';
import { deriveWorkspaceSidebarStatus } from '@/shared/workspace-sidebar-status';
import { workspaceSnapshotStore } from '@/backend/services';
```

Note: `computeKanbanColumn` is already importable from `@/backend/domains/workspace` (exported from barrel). `deriveWorkspaceFlowState` is also already exported. Add these to the existing import from workspace domain.

At the END of the `configureDomainBridges()` function (after all existing bridge wiring), add a new section:

```typescript
// === Snapshot store derivation functions ===
workspaceSnapshotStore.configure({
  deriveFlowState: (input) =>
    deriveWorkspaceFlowState({
      ...input,
      prUpdatedAt: input.prUpdatedAt ? new Date(input.prUpdatedAt) : null,
    }),
  computeKanbanColumn: (input) => computeKanbanColumn(input),
  deriveSidebarStatus: (input) => deriveWorkspaceSidebarStatus(input),
});
```

IMPORTANT: The `deriveWorkspaceFlowState` function expects `prUpdatedAt: Date | null` but the snapshot store passes `prUpdatedAt: string | null` (ISO string). The adapter converts `string -> Date` via `new Date(input.prUpdatedAt)`. This is the bridge's job -- keeping the store free of domain imports while adapting types.

For `computeKanbanColumn`, the import already exists via the workspace barrel (check existing imports -- it may need to be added to the destructured import from `@/backend/domains/workspace`).
  </action>
  <verify>
Run `pnpm typecheck` -- should pass with zero errors.
Run `pnpm check:fix` -- should pass (formatting + linting).
Verify the domain-bridges file now has `workspaceSnapshotStore.configure(` somewhere in it.
Verify the services barrel now exports `workspaceSnapshotStore`.
  </verify>
  <done>
Snapshot store is accessible via `import { workspaceSnapshotStore } from '@/backend/services'`. Derivation functions are injected at startup via domain-bridges. The configure() call converts prUpdatedAt from string to Date for flow state derivation. `pnpm typecheck` and `pnpm check:fix` pass clean.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with zero errors
2. `pnpm check:fix` passes (Biome formatting + linting)
3. `grep -r "@/backend/domains" src/backend/services/workspace-snapshot-store.service.ts` returns empty (ARCH-02)
4. The file `src/backend/services/workspace-snapshot-store.service.ts` exists and is >200 lines
5. `import { workspaceSnapshotStore } from '@/backend/services'` resolves correctly
</verification>

<success_criteria>
- WorkspaceSnapshotStore class is implemented with all required methods (upsert, remove, getByWorkspaceId, getByProjectId, getVersion, size, clear)
- Types are properly defined and exported (WorkspaceSnapshotEntry, SnapshotUpdateInput, SnapshotDerivationFns)
- Field-level timestamp merging preserves newest data on concurrent updates
- Derived state (sidebarStatus, kanbanColumn, flowPhase, ciObservation) recomputes on every upsert
- EventEmitter emits snapshot_changed and snapshot_removed events
- Service has zero imports from @/backend/domains/ (ARCH-02)
- Service lives in src/backend/services/ (ARCH-01)
- Derivation functions are injected via configure() in domain-bridges
- TypeScript compiles and Biome linting passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-snapshot-store/11-01-SUMMARY.md`
</output>

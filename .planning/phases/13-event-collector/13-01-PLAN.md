---
phase: 13-event-collector
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backend/orchestration/event-collector.orchestrator.ts
  - src/backend/orchestration/event-collector.orchestrator.test.ts
  - src/backend/server.ts
autonomous: true

must_haves:
  truths:
    - "When any domain emits a state change event, the corresponding workspace snapshot entry is updated within the coalescing window"
    - "Rapid-fire events (multiple events within 100-200ms) for the same workspace produce a single snapshot update, not multiple"
    - "The event collector lives in src/backend/orchestration/ and domains emit events without importing or knowing about the snapshot service"
    - "ARCHIVED workspace events trigger store.remove() for immediate UI feedback"
    - "Server shutdown flushes all pending coalesced updates and clears timers"
  artifacts:
    - path: "src/backend/orchestration/event-collector.orchestrator.ts"
      provides: "EventCoalescer class, configureEventCollector(), stopEventCollector()"
      exports: ["configureEventCollector", "stopEventCollector"]
    - path: "src/backend/orchestration/event-collector.orchestrator.test.ts"
      provides: "Comprehensive test suite for coalescing, event-to-field mapping, and edge cases"
      min_lines: 100
    - path: "src/backend/server.ts"
      provides: "Startup wiring of configureEventCollector() and shutdown cleanup via stopEventCollector()"
  key_links:
    - from: "src/backend/orchestration/event-collector.orchestrator.ts"
      to: "@/backend/domains/workspace"
      via: "EventEmitter .on() subscription"
      pattern: "workspaceStateMachine\\.on\\(WORKSPACE_STATE_CHANGED"
    - from: "src/backend/orchestration/event-collector.orchestrator.ts"
      to: "@/backend/domains/github"
      via: "EventEmitter .on() subscription"
      pattern: "prSnapshotService\\.on\\(PR_SNAPSHOT_UPDATED"
    - from: "src/backend/orchestration/event-collector.orchestrator.ts"
      to: "@/backend/domains/ratchet"
      via: "EventEmitter .on() subscription"
      pattern: "ratchetService\\.on\\(RATCHET_STATE_CHANGED"
    - from: "src/backend/orchestration/event-collector.orchestrator.ts"
      to: "@/backend/domains/run-script"
      via: "EventEmitter .on() subscription"
      pattern: "runScriptStateMachine\\.on\\(RUN_SCRIPT_STATUS_CHANGED"
    - from: "src/backend/orchestration/event-collector.orchestrator.ts"
      to: "@/backend/services"
      via: "workspaceSnapshotStore.upsert() and .getByWorkspaceId()"
      pattern: "store\\.upsert\\("
    - from: "src/backend/server.ts"
      to: "src/backend/orchestration/event-collector.orchestrator.ts"
      via: "direct import (NOT via barrel, to avoid circular deps)"
      pattern: "from '\\./orchestration/event-collector\\.orchestrator'"
---

<objective>
Create the event collector orchestrator that subscribes to all five domain event sources and translates domain events into snapshot store mutations through a per-workspace coalescing buffer.

Purpose: This is the core wiring layer that makes the snapshot store reactive to domain state changes. Without it, the store would only be populated by reconciliation polling (Phase 14). The event collector provides sub-200ms latency from domain mutation to store update.

Output: `event-collector.orchestrator.ts` with EventCoalescer class, configureEventCollector() / stopEventCollector() exports, comprehensive test suite, and server.ts wiring.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-event-collector/13-RESEARCH.md
@src/backend/orchestration/domain-bridges.orchestrator.ts
@src/backend/orchestration/index.ts
@src/backend/services/workspace-snapshot-store.service.ts
@src/backend/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EventCoalescer and configureEventCollector with tests</name>
  <files>
    src/backend/orchestration/event-collector.orchestrator.ts
    src/backend/orchestration/event-collector.orchestrator.test.ts
  </files>
  <action>
Create `src/backend/orchestration/event-collector.orchestrator.ts` with:

**EventCoalescer class** (exported for testing):
- Constructor takes a store interface (`{ upsert: ..., getByWorkspaceId: ..., remove: ... }`) and optional `windowMs` (default 150).
- `enqueue(workspaceId: string, fields: SnapshotUpdateInput, source: string): void` -- accumulates fields into a `Map<string, PendingUpdate>` keyed by workspaceId. Each PendingUpdate has `{ fields: SnapshotUpdateInput, sources: Set<string>, timer: NodeJS.Timeout }`. On enqueue: merge fields via `Object.assign(pending.fields, fields)`, add source to Set, `clearTimeout` existing timer, set new `setTimeout` to call `flush(workspaceId)` after `windowMs`.
- `flush(workspaceId: string): void` (private) -- Deletes pending entry. Guards: if workspace not in store AND pending.fields lacks `projectId`, log debug and skip (reconciliation will seed it). Otherwise call `store.upsert(workspaceId, pending.fields, sources.join('+'))`.
- `flushAll(): void` -- Iterates all pending entries, clearTimeout each, flush each. Then clears the map. Used for shutdown.
- `get pendingCount(): number` -- Returns `this.pending.size` (for testing).

**configureEventCollector() function** (exported):
- Creates an EventCoalescer instance with `workspaceSnapshotStore`.
- Stores it in a module-level `let activeCoalescer: EventCoalescer | null`.
- Subscribes to 6 events from 5 domain singletons:

  1. `workspaceStateMachine.on(WORKSPACE_STATE_CHANGED, ...)`:
     - If `event.toStatus === 'ARCHIVED'`: call `workspaceSnapshotStore.remove(event.workspaceId)` directly (no coalescing, immediate removal for UI).
     - Otherwise: `coalescer.enqueue(event.workspaceId, { status: event.toStatus }, 'event:workspace_state_changed')`.

  2. `prSnapshotService.on(PR_SNAPSHOT_UPDATED, ...)`:
     - `coalescer.enqueue(event.workspaceId, { prNumber: event.prNumber, prState: event.prState as PRState, prCiStatus: event.prCiStatus as CIStatus }, 'event:pr_snapshot_updated')`.
     - Note: Do NOT map `prReviewState` -- it is not a field in SnapshotUpdateInput.

  3. `ratchetService.on(RATCHET_STATE_CHANGED, ...)`:
     - `coalescer.enqueue(event.workspaceId, { ratchetState: event.toState }, 'event:ratchet_state_changed')`.

  4. `runScriptStateMachine.on(RUN_SCRIPT_STATUS_CHANGED, ...)`:
     - `coalescer.enqueue(event.workspaceId, { runScriptStatus: event.toStatus }, 'event:run_script_status_changed')`.

  5. `workspaceActivityService.on('workspace_active', ...)`:
     - `coalescer.enqueue(workspaceId, { isWorking: true }, 'event:workspace_active')`.

  6. `workspaceActivityService.on('workspace_idle', ...)`:
     - `coalescer.enqueue(workspaceId, { isWorking: false }, 'event:workspace_idle')`.

**stopEventCollector() function** (exported):
- If `activeCoalescer` exists, call `activeCoalescer.flushAll()`, set `activeCoalescer = null`.
- Log info on stop.

**Import rules (critical for EVNT-07 + circular dep avoidance):**
- Import domain singletons and event constants from domain barrels: `@/backend/domains/workspace`, `@/backend/domains/github`, `@/backend/domains/ratchet`, `@/backend/domains/run-script`.
- Import store from `@/backend/services`.
- Import types `SnapshotUpdateInput` from `@/backend/services`.
- Import `PRState`, `CIStatus` from `@prisma-gen/client` for type casting.
- Use `createLogger` from `@/backend/services` for logging.
- Do NOT add exports to `orchestration/index.ts` (circular dep risk per existing comment in that file).

**Test file** `event-collector.orchestrator.test.ts`:
Use `vi.useFakeTimers()` / `vi.useRealTimers()` pattern. Mock all domain singletons and the store.

Test cases:
1. **Single event flows to upsert after coalescing window** -- Enqueue one event, advance timer by 150ms, verify single upsert call with correct fields and source string.
2. **Rapid-fire events for same workspace coalesce into single upsert** -- Enqueue 3 events for same workspace within 50ms intervals, advance timer by 150ms past last enqueue, verify exactly 1 upsert with all fields merged and source joined with '+'.
3. **Events for different workspaces produce separate upserts** -- Enqueue events for ws-1 and ws-2, advance timer, verify 2 separate upsert calls.
4. **ARCHIVED workspace event calls store.remove() immediately** -- Emit WORKSPACE_STATE_CHANGED with toStatus='ARCHIVED', verify store.remove() called (no coalescing delay).
5. **Unknown workspace (not in store, no projectId) skips upsert** -- Mock getByWorkspaceId returning undefined, enqueue event without projectId, advance timer, verify upsert NOT called.
6. **Known workspace (in store) updates even without projectId** -- Mock getByWorkspaceId returning an entry, enqueue event, advance timer, verify upsert called.
7. **flushAll() flushes all pending updates immediately** -- Enqueue events for 2 workspaces, call flushAll() before timer fires, verify both upserted.
8. **Event-to-field mapping correctness** -- One test per event type verifying the exact SnapshotUpdateInput fields produced.
9. **PR event does NOT include prReviewState** -- Verify the upsert input has only prNumber, prState, prCiStatus (not prReviewState).
10. **Coalesced source string format** -- Verify sources joined with '+' in correct order.

Mock pattern: Create mock EventEmitter instances for each domain service. Use `vi.fn()` for store methods. Call `configureEventCollector()` with the mocks (this means the function needs to accept dependencies for testing, OR tests directly instantiate EventCoalescer and call enqueue). Prefer testing EventCoalescer directly for unit tests, and testing configureEventCollector event wiring in an integration-style test.
  </action>
  <verify>
Run `pnpm test src/backend/orchestration/event-collector.orchestrator.test.ts` -- all tests pass.
Run `pnpm typecheck` -- no type errors.
Run `pnpm check:fix` -- no lint/format issues.
  </verify>
  <done>
EventCoalescer class coalesces rapid-fire events into single upsert calls. All 6 event subscriptions map to correct SnapshotUpdateInput fields. ARCHIVED events trigger immediate store.remove(). Unknown workspaces are gracefully skipped. All test cases pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire event collector into server startup and shutdown</name>
  <files>
    src/backend/server.ts
  </files>
  <action>
Edit `src/backend/server.ts`:

1. **Add import** at top of file (import directly from the module, NOT from orchestration barrel):
   ```typescript
   import { configureEventCollector, stopEventCollector } from './orchestration/event-collector.orchestrator';
   ```

2. **Call configureEventCollector()** in the server.listen callback, AFTER `configureDomainBridges()` (line ~284). Add it on the line immediately after `configureDomainBridges();`:
   ```typescript
   configureDomainBridges();
   configureEventCollector();
   ```

3. **Call stopEventCollector()** in the `performCleanup` function, BEFORE `ratchetService.stop()` (around line ~256). This ensures pending coalesced events are flushed before domain services shut down:
   ```typescript
   stopEventCollector();
   await ratchetService.stop();
   ```

That's it -- three small, surgical edits to server.ts.
  </action>
  <verify>
Run `pnpm typecheck` -- no type errors in server.ts.
Run `pnpm test` -- full test suite passes (no regressions).
Run `pnpm check:fix` -- no lint/format issues.
  </verify>
  <done>
Event collector is wired into server startup after bridge configuration and into server shutdown before domain services stop. The full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
Requirements coverage:
- **EVNT-06** (Event collector orchestrator in src/backend/orchestration/): `event-collector.orchestrator.ts` subscribes to all domain events and calls store.upsert().
- **EVNT-07** (Bridge pattern -- domains don't know about snapshot): Domains emit events via EventEmitter. The collector subscribes from orchestration layer. No domain imports from snapshot store or orchestration.
- **EVNT-08** (Rapid-fire coalescing within 100-200ms): EventCoalescer uses 150ms debounce window. Tests verify multiple events coalesce into single upsert.

Architecture validation:
- `pnpm typecheck` passes
- `pnpm test` passes (all existing + new tests)
- `pnpm check:fix` passes
- No new cross-domain imports (collector is in orchestration/, imports from domain barrels only)
- No exports added to orchestration/index.ts (avoids circular deps)
</verification>

<success_criteria>
1. `pnpm test src/backend/orchestration/event-collector.orchestrator.test.ts` -- all tests pass
2. `pnpm test` -- full suite passes, no regressions
3. `pnpm typecheck` -- clean
4. `pnpm check:fix` -- clean
5. Event-to-field mapping covers all 6 event subscriptions with correct SnapshotUpdateInput fields
6. Coalescing verified: 3 rapid-fire events for same workspace produce exactly 1 upsert call
7. ARCHIVED handling verified: immediate store.remove(), no coalescing delay
8. Unknown workspace guard: events for unseeded workspaces are skipped gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/13-event-collector/13-01-SUMMARY.md`
</output>

---
phase: 19-acp-runtime-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-lock.yaml
  - src/backend/domains/session/acp/types.ts
  - src/backend/domains/session/acp/acp-process-handle.ts
  - src/backend/domains/session/acp/acp-client-handler.ts
  - src/backend/domains/session/acp/acp-runtime-manager.ts
  - src/backend/domains/session/acp/index.ts
  - src/backend/domains/session/acp/acp-runtime-manager.test.ts
autonomous: true

must_haves:
  truths:
    - "AcpRuntimeManager implements ProviderRuntimeManager interface with getOrCreateClient, getClient, getPendingClient, stopClient, setOnClientCreated, isStopInProgress"
    - "getOrCreateClient spawns a non-detached ACP subprocess, wires ClientSideConnection via ndJsonStream, completes initialize handshake, creates provider session, and returns an AcpProcessHandle"
    - "stopClient sends SIGTERM, waits 5s grace period, escalates to SIGKILL, cleans up all references"
    - "AcpClientHandler.sessionUpdate logs ALL events to session file logger and forwards agent_message_chunk and tool_call events to an onEvent callback"
    - "AcpClientHandler.requestPermission auto-approves with the first allow_once or allow_always option"
    - "Unit tests verify spawn, initialize, stop, and client handler behavior"
  artifacts:
    - path: "src/backend/domains/session/acp/types.ts"
      provides: "AcpClientOptions, AcpSessionState types"
    - path: "src/backend/domains/session/acp/acp-process-handle.ts"
      provides: "AcpProcessHandle class holding connection, child process, providerSessionId, agentCapabilities, isPromptInFlight"
    - path: "src/backend/domains/session/acp/acp-client-handler.ts"
      provides: "AcpClientHandler implementing Client interface with sessionUpdate and requestPermission"
    - path: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      provides: "AcpRuntimeManager implementing ProviderRuntimeManager with spawn, initialize, newSession, prompt, cancel, stop"
      exports: ["AcpRuntimeManager", "acpRuntimeManager"]
    - path: "src/backend/domains/session/acp/index.ts"
      provides: "Barrel file for ACP submodule"
    - path: "src/backend/domains/session/acp/acp-runtime-manager.test.ts"
      provides: "Unit tests for AcpRuntimeManager"
  key_links:
    - from: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      to: "@agentclientprotocol/sdk"
      via: "ClientSideConnection, ndJsonStream, PROTOCOL_VERSION imports"
      pattern: "import.*from '@agentclientprotocol/sdk'"
    - from: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      to: "src/backend/domains/session/acp/acp-process-handle.ts"
      via: "sessions Map storing AcpProcessHandle instances"
      pattern: "new AcpProcessHandle"
    - from: "src/backend/domains/session/acp/acp-client-handler.ts"
      to: "src/backend/domains/session/logging/session-file-logger.service.ts"
      via: "sessionFileLogger.log calls for EVENT-06"
      pattern: "sessionFileLogger\\.log"
    - from: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      to: "src/backend/domains/session/runtime/provider-runtime-manager.ts"
      via: "implements ProviderRuntimeManager interface"
      pattern: "implements ProviderRuntimeManager"
---

<objective>
Build the ACP runtime module: subprocess lifecycle, connection wiring, session create/prompt/cancel/stop, streaming event handling, and unit tests.

Purpose: This is the core ACP infrastructure that all subsequent phases build upon. It proves the subprocess + ClientSideConnection + JSON-RPC pipeline works end-to-end within the session domain's existing architecture.

Output: A complete `src/backend/domains/session/acp/` submodule with AcpRuntimeManager implementing ProviderRuntimeManager, ready to be wired into session.service.ts in Plan 02.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-acp-runtime-foundation/19-RESEARCH.md

@src/backend/domains/session/runtime/provider-runtime-manager.ts
@src/backend/domains/session/runtime/claude-runtime-manager.ts
@src/backend/domains/session/logging/session-file-logger.service.ts
@src/backend/domains/session/session-domain.service.ts
@src/backend/domains/session/providers/session-provider-adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ACP packages and create types + process handle</name>
  <files>
    package.json
    pnpm-lock.yaml
    src/backend/domains/session/acp/types.ts
    src/backend/domains/session/acp/acp-process-handle.ts
  </files>
  <action>
**Step 1: Install ACP packages (pin exact versions, no caret):**
```bash
pnpm add @agentclientprotocol/sdk@0.14.1 @zed-industries/claude-code-acp@0.16.1 @zed-industries/codex-acp@0.9.2 --save-exact
```

If these exact versions are not found on npm, install the latest available versions of each package and note the actual versions installed. The package names are correct; only versions may have changed.

**Step 2: Create `src/backend/domains/session/acp/types.ts`:**

Define the following types:

```typescript
import type { SessionProvider } from '@/backend/domains/session/providers/session-provider-adapter';

export interface AcpClientOptions {
  provider: SessionProvider;  // 'CLAUDE' | 'CODEX'
  workingDir: string;
  model?: string;
  systemPrompt?: string;
  permissionMode?: string;
  sessionId: string;  // FF database session ID for logging
}

export interface AcpSessionState {
  providerSessionId: string;
  agentCapabilities: Record<string, unknown>;
  isPromptInFlight: boolean;
}
```

Follow project conventions: single quotes, 2-space indent, explicit types, `import type` for type-only imports.

**Step 3: Create `src/backend/domains/session/acp/acp-process-handle.ts`:**

This class wraps per-session state: the ClientSideConnection, ChildProcess, provider session ID, agent capabilities, and prompt-in-flight flag.

```typescript
import type { ChildProcess } from 'node:child_process';
import type { ClientSideConnection } from '@agentclientprotocol/sdk';

export class AcpProcessHandle {
  readonly connection: ClientSideConnection;
  readonly child: ChildProcess;
  providerSessionId: string;
  agentCapabilities: Record<string, unknown>;
  isPromptInFlight: boolean;
  readonly createdAt: Date;

  constructor(params: {
    connection: ClientSideConnection;
    child: ChildProcess;
    providerSessionId: string;
    agentCapabilities: Record<string, unknown>;
  }) {
    this.connection = params.connection;
    this.child = params.child;
    this.providerSessionId = params.providerSessionId;
    this.agentCapabilities = params.agentCapabilities;
    this.isPromptInFlight = false;
    this.createdAt = new Date();
  }

  isRunning(): boolean {
    return this.child.exitCode === null && !this.child.killed;
  }

  getPid(): number | undefined {
    return this.child.pid;
  }
}
```
  </action>
  <verify>
Run `pnpm typecheck` to confirm the new packages are installed and the type files compile without errors. Verify the ACP SDK types are accessible: `import { ClientSideConnection } from '@agentclientprotocol/sdk'` should resolve.
  </verify>
  <done>
Three ACP packages installed with exact versions in package.json. types.ts exports AcpClientOptions and AcpSessionState. acp-process-handle.ts exports AcpProcessHandle class with connection, child, providerSessionId, agentCapabilities, isPromptInFlight fields and isRunning/getPid methods. All typecheck passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build AcpClientHandler with event routing and permission auto-approve</name>
  <files>
    src/backend/domains/session/acp/acp-client-handler.ts
  </files>
  <action>
**Create `src/backend/domains/session/acp/acp-client-handler.ts`:**

Implements the ACP SDK `Client` interface. This is the callback object passed to `ClientSideConnection` that receives streaming events and permission requests.

Key behaviors:
- `sessionUpdate(params)`: Log ALL events to sessionFileLogger with direction `FROM_CLAUDE_CLI` and `eventType: 'acp_session_update'` (satisfies EVENT-06). Forward `agent_message_chunk` and `tool_call` and `tool_call_update` events to the `onEvent` callback. Log-only for deferred event types (`agent_thought_chunk`, `plan`, `available_commands_update`, `config_options_update`, `current_mode_update`, `user_message_chunk`). Warn on unknown update types.
- `requestPermission(params)`: Auto-approve by selecting the first `allow_always` or `allow_once` option. If none found, select the first option. Return `{ outcome: { selected: { optionId } } }`.

Use `createLogger('acp-client-handler')` for structured logging. Import `sessionFileLogger` from `@/backend/domains/session/logging/session-file-logger.service`.

The `onEvent` callback type should be: `(sessionId: string, event: unknown) => void`. The constructor takes `sessionId: string`, `onEvent` callback, and `logger` instance.

Reference the research Pattern 6 for exact event handling structure. Do NOT import or reference ClaudeMessage types -- ACP events are their own format. The `onEvent` callback receives raw ACP event data for the session service to translate minimally.

For the `agent_message_chunk` case, forward as:
```typescript
{ type: 'acp_agent_message_chunk', content: update.content }
```

For `tool_call`, forward as:
```typescript
{ type: 'acp_tool_call', toolCallId: update.toolCallId, title: update.title, kind: update.kind, status: update.status }
```

For `tool_call_update`, forward as:
```typescript
{ type: 'acp_tool_call_update', toolCallId: update.toolCallId, status: update.status, content: update.content }
```

These are intentionally prefixed with `acp_` to distinguish from legacy event types. Phase 20 will handle full translation.
  </action>
  <verify>
Run `pnpm typecheck` to confirm AcpClientHandler compiles and implements the Client interface correctly.
  </verify>
  <done>
AcpClientHandler implements Client interface with sessionUpdate (logging + forwarding for agent_message_chunk, tool_call, tool_call_update) and requestPermission (auto-approve with allow_once/allow_always preference). All events logged to session file logger.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build AcpRuntimeManager, barrel file, and unit tests</name>
  <files>
    src/backend/domains/session/acp/acp-runtime-manager.ts
    src/backend/domains/session/acp/index.ts
    src/backend/domains/session/acp/acp-runtime-manager.test.ts
  </files>
  <action>
**Step 1: Create `src/backend/domains/session/acp/acp-runtime-manager.ts`:**

Implements `ProviderRuntimeManager<AcpProcessHandle, AcpClientOptions>` following the same dedup/lock pattern as `ClaudeRuntimeManager`.

Structure:
```
class AcpRuntimeManager implements ProviderRuntimeManager<AcpProcessHandle, AcpClientOptions> {
  private readonly sessions = new Map<string, AcpProcessHandle>();
  private readonly pendingCreation = new Map<string, Promise<AcpProcessHandle>>();
  private readonly stoppingInProgress = new Set<string>();
  private readonly creationLocks = new Map<string, ReturnType<typeof pLimit>>();
  private readonly lockRefCounts = new Map<string, number>();
  private onClientCreatedCallback: RuntimeCreatedCallback<AcpProcessHandle> | null = null;
}
```

Methods:

1. `setOnClientCreated(callback)` -- store callback
2. `isStopInProgress(sessionId)` -- check stoppingInProgress set
3. `getClient(sessionId)` -- return from sessions map if isRunning()
4. `getPendingClient(sessionId)` -- return from pendingCreation map
5. `getOrCreateClient(sessionId, options, handlers, context)` -- pLimit(1) lock per session (same pattern as ClaudeRuntimeManager), dedup check, then call createClient
6. `createClient(sessionId, options, handlers, context)` -- the core method:
   - Resolve binary: `options.provider === 'CODEX' ? 'codex-acp' : 'claude-code-acp'`. Resolve full path by trying `require.resolve('@zed-industries/{binary}/bin/{binary}')` first, falling back to just the binary name (rely on PATH).
   - Spawn subprocess: `spawn(binaryPath, [], { cwd: options.workingDir, stdio: ['pipe', 'pipe', 'pipe'], env: { ...process.env }, detached: false })` -- CRITICAL: detached MUST be false
   - Wire stderr to session file logger: `child.stderr.on('data', chunk => sessionFileLogger.log(options.sessionId, 'FROM_CLAUDE_CLI', { eventType: 'acp_stderr', data: chunk.toString() }))`
   - Convert streams: `Readable.toWeb(child.stdout!) as ReadableStream<Uint8Array>`, `Writable.toWeb(child.stdin!) as WritableStream<Uint8Array>`
   - Create ndJsonStream: `const stream = ndJsonStream(output, input)`
   - Create connection with client handler: `new ClientSideConnection((_agent) => new AcpClientHandler(sessionId, onEvent, logger), stream)` where `onEvent` is a callback that will be injected by the session service (stored via a `setEventHandler` method, or passed through handlers)
   - Initialize: `const initResult = await connection.initialize({ protocolVersion: PROTOCOL_VERSION, clientCapabilities: {}, clientInfo: { name: 'factory-factory', title: 'Factory Factory', version: '1.2.0' } })`
   - Create session: `const sessionResult = await connection.newSession({ cwd: options.workingDir, mcpServers: [] })`
   - Build handle: `new AcpProcessHandle({ connection, child, providerSessionId: sessionResult.sessionId, agentCapabilities: initResult.agentCapabilities ?? {} })`
   - Store in sessions map
   - Wire child exit handler: on 'exit', delete from sessions/pendingCreation, call handlers.onExit if provided (skip if stoppingInProgress)
   - Wire child error handler: call handlers.onError if provided
   - Call onClientCreatedCallback if set
   - Call handlers.onSessionId with providerSessionId
   - Return handle

7. `stopClient(sessionId)` -- following research Pattern 5:
   - Guard against double-stop (stoppingInProgress set)
   - Get handle from sessions map, return if not found
   - Add to stoppingInProgress
   - If handle.isPromptInFlight, try `handle.connection.cancel({ sessionId: handle.providerSessionId })` (swallow errors)
   - Send SIGTERM: `handle.child.kill('SIGTERM')`
   - Race: wait for exit event vs 5000ms timeout
   - If still alive after timeout: `handle.child.kill('SIGKILL')`
   - Finally: remove from stoppingInProgress, delete from sessions map

8. `sendPrompt(sessionId, content)` -- async method (NOT part of ProviderRuntimeManager interface, called by session service):
   - Get handle, throw if not found
   - Set handle.isPromptInFlight = true
   - Call `handle.connection.prompt({ sessionId: handle.providerSessionId, prompt: [{ type: 'text', text: content }] })`
   - On resolve: set isPromptInFlight = false, return result (stopReason)
   - On error: set isPromptInFlight = false, re-throw

9. `cancelPrompt(sessionId)` -- async method:
   - Get handle, return if not found
   - If isPromptInFlight: `await handle.connection.cancel({ sessionId: handle.providerSessionId })`

10. `stopAllClients(timeoutMs = 5000)` -- stop all sessions in parallel with timeout
11. `getAllClients()` -- return sessions.entries() iterator
12. `isSessionRunning(sessionId)` -- check sessions map
13. `isSessionWorking(sessionId)` -- check isPromptInFlight
14. `isAnySessionWorking(sessionIds)` -- check any session's isPromptInFlight

The `onEvent` callback for AcpClientHandler should be wired through RuntimeEventHandlers. Add a new optional field to the handlers object that AcpRuntimeManager accepts. Since ProviderRuntimeManager uses `RuntimeEventHandlers`, extend it with an ACP-specific handler type:

```typescript
export type AcpRuntimeEventHandlers = RuntimeEventHandlers & {
  onAcpEvent?: (sessionId: string, event: unknown) => void;
};
```

Use `createLogger('acp-runtime-manager')` for all logging.

Export both the class and a singleton: `export const acpRuntimeManager = new AcpRuntimeManager();`

**Step 2: Create `src/backend/domains/session/acp/index.ts`:**

Barrel file exporting:
```typescript
export { AcpClientHandler } from './acp-client-handler';
export { AcpProcessHandle } from './acp-process-handle';
export type { AcpRuntimeEventHandlers } from './acp-runtime-manager';
export { AcpRuntimeManager, acpRuntimeManager } from './acp-runtime-manager';
export type { AcpClientOptions, AcpSessionState } from './types';
```

**Step 3: Create `src/backend/domains/session/acp/acp-runtime-manager.test.ts`:**

Unit tests using Vitest. Mock `child_process.spawn`, `@agentclientprotocol/sdk` (ClientSideConnection, ndJsonStream), and `sessionFileLogger`.

Test cases:
1. `getOrCreateClient` spawns subprocess with detached:false, wires streams, initializes, creates session, returns handle
2. `getOrCreateClient` returns existing handle if session already exists and is running
3. `getOrCreateClient` deduplicates concurrent creation for same sessionId
4. `stopClient` sends SIGTERM, waits grace period, cleans up references
5. `stopClient` escalates to SIGKILL after timeout
6. `stopClient` cancels prompt if isPromptInFlight before SIGTERM
7. `stopClient` is idempotent (double-stop is no-op)
8. `sendPrompt` sets isPromptInFlight, calls connection.prompt, clears flag on resolve
9. `cancelPrompt` calls connection.cancel when prompt is in flight
10. AcpClientHandler.sessionUpdate logs all events to sessionFileLogger
11. AcpClientHandler.requestPermission auto-approves with allow option

Mock the ClientSideConnection to return controlled responses from initialize/newSession/prompt/cancel. Mock spawn to return a fake ChildProcess with event emitter behavior (on, kill, exitCode, pid, stdout, stderr, stdin).

Follow project test patterns: co-located in acp/ directory, use `vi.mock()`, `describe`/`it` blocks, `expect` assertions.
  </action>
  <verify>
Run:
1. `pnpm typecheck` -- all types resolve, no errors
2. `pnpm test src/backend/domains/session/acp/` -- all unit tests pass
3. `pnpm check:fix` -- Biome formatting and lint pass
  </verify>
  <done>
AcpRuntimeManager implements ProviderRuntimeManager with full lifecycle: spawn with detached:false, initialize handshake, newSession, sendPrompt, cancelPrompt, stopClient with SIGTERM/SIGKILL escalation. Barrel file exports all public API. 11+ unit tests pass covering spawn, dedup, stop, cancel, event handling, and permission auto-approve.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type safety:** `pnpm typecheck` passes with zero errors
2. **Tests:** `pnpm test src/backend/domains/session/acp/` -- all tests pass
3. **Lint:** `pnpm check:fix` -- no formatting or lint violations
4. **Interface compliance:** AcpRuntimeManager satisfies ProviderRuntimeManager<AcpProcessHandle, AcpClientOptions> -- TypeScript enforces this at compile time
5. **Non-detached spawn:** Verify in test mocks that spawn is called with `detached: false`
6. **Event logging:** Verify sessionFileLogger.log is called for every sessionUpdate event (EVENT-06)
7. **No legacy coupling:** No imports from `@/backend/domains/session/claude/` or ClaudeMessage types
</verification>

<success_criteria>
- `src/backend/domains/session/acp/` directory exists with 6 files (types, process-handle, client-handler, runtime-manager, index, test)
- AcpRuntimeManager implements ProviderRuntimeManager interface (TypeScript verifies)
- All unit tests pass
- No typecheck or lint errors
- Event logging covers all ACP session update types
- Permission auto-approve works for both allow_once and allow_always option kinds
</success_criteria>

<output>
After completion, create `.planning/phases/19-acp-runtime-foundation/19-01-SUMMARY.md`
</output>

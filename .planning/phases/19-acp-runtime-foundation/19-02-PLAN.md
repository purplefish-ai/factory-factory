---
phase: 19-acp-runtime-foundation
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/backend/domains/session/runtime/index.ts
  - src/backend/domains/session/lifecycle/session.service.ts
  - src/backend/domains/session/index.ts
autonomous: false

must_haves:
  truths:
    - "SessionService can start an ACP session by spawning a subprocess, completing the handshake, and emitting runtime state updates"
    - "Sending a prompt via ACP produces streaming agent_message_chunk events that reach the frontend via sessionDomainService.emitDelta"
    - "Cancelling an ACP prompt mid-turn halts the agent and sets isPromptInFlight to false"
    - "Stopping an ACP session terminates the subprocess cleanly with no orphaned processes"
    - "Session domain barrel exports AcpRuntimeManager and related types"
    - "All ACP events are logged to session file logger for debugging"
    - "The existing WebSocket chat message handler (user-input.handler.ts) calls sendSessionMessage which detects ACP clients -- no new API route needed"
    - "The existing WebSocket stop handler and tRPC stopSession route call stopSession which detects ACP clients -- no new cancel route needed"
  artifacts:
    - path: "src/backend/domains/session/runtime/index.ts"
      provides: "AcpRuntimeManager export alongside existing runtime managers"
      contains: "AcpRuntimeManager"
    - path: "src/backend/domains/session/lifecycle/session.service.ts"
      provides: "ACP provider path in getOrCreateSessionClient, sendSessionMessage, stopSession"
    - path: "src/backend/domains/session/index.ts"
      provides: "AcpRuntimeManager and AcpProcessHandle in domain barrel exports"
      contains: "acpRuntimeManager"
  key_links:
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      via: "acpRuntimeManager import and ACP client creation path"
      pattern: "acpRuntimeManager\\."
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/session-domain.service.ts"
      via: "emitDelta for ACP streaming events -- uses the SAME proven pipeline as Claude/Codex (publisher.emitDelta -> chatConnectionService.forwardToSession -> WebSocket)"
      pattern: "sessionDomainService\\.emitDelta"
    - from: "src/backend/domains/session/chat/chat-message-handlers/handlers/user-input.handler.ts"
      to: "src/backend/domains/session/lifecycle/session.service.ts"
      via: "user-input.handler calls sessionService.sendSessionMessage -- ACP sessions detected at runtime via acpRuntimeManager.getClient check (RUNTIME-05)"
      pattern: "sessionService\\.sendSessionMessage"
    - from: "src/backend/domains/session/chat/chat-message-handlers/handlers/stop.handler.ts"
      to: "src/backend/domains/session/lifecycle/session.service.ts"
      via: "stop.handler calls sessionService.stopSession -- ACP sessions detected at runtime via acpRuntimeManager.getClient check (RUNTIME-06)"
      pattern: "sessionService\\.stopSession"
    - from: "src/backend/domains/session/index.ts"
      to: "src/backend/domains/session/acp/index.ts"
      via: "re-exports from ACP submodule"
      pattern: "from './acp'"
---

<objective>
Wire the ACP runtime into the session service, event forwarding pipeline, and domain barrel to complete the end-to-end session lifecycle (start -> prompt -> stream -> cancel -> stop).

Purpose: Without this wiring, the AcpRuntimeManager from Plan 01 exists in isolation. This plan connects it to the session domain's existing infrastructure so that starting a session with a future ACP provider flag actually spawns an ACP subprocess and streams events to the frontend.

Output: A fully wired ACP session path in SessionService alongside the existing Claude and Codex paths. The session domain barrel exports ACP types and the singleton. A human-verified end-to-end test confirms the integration.

Important context for RUNTIME-05 and RUNTIME-06 (send and cancel): The existing WebSocket handlers already call `sessionService.sendSessionMessage` (via user-input.handler.ts) and `sessionService.stopSession` (via stop.handler.ts and session.trpc.ts). The ACP path is detected at RUNTIME inside these methods by checking `acpRuntimeManager.getClient(sessionId)`. No new tRPC routes or WebSocket message handlers are needed -- ACP inherits the existing API surface.

Important context for event forwarding: The `emitDelta` -> WebSocket pipeline is already proven infrastructure. `sessionDomainService.emitDelta()` calls `publisher.emitDelta()` which wraps the event as `{ type: 'session_delta', data: event }` and sends it via `chatConnectionService.forwardToSession()` over the WebSocket. This is the same pipeline used by Claude and Codex sessions today.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-acp-runtime-foundation/19-RESEARCH.md
@.planning/phases/19-acp-runtime-foundation/19-01-SUMMARY.md

@src/backend/domains/session/runtime/index.ts
@src/backend/domains/session/runtime/provider-runtime-manager.ts
@src/backend/domains/session/lifecycle/session.service.ts
@src/backend/domains/session/index.ts
@src/backend/domains/session/session-domain.service.ts
@src/backend/domains/session/providers/session-provider-adapter.ts
@src/backend/domains/session/chat/chat-message-handlers/handlers/user-input.handler.ts
@src/backend/domains/session/chat/chat-message-handlers/handlers/stop.handler.ts
@src/backend/domains/session/store/session-publisher.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire AcpRuntimeManager into session service and event pipeline</name>
  <files>
    src/backend/domains/session/runtime/index.ts
    src/backend/domains/session/lifecycle/session.service.ts
    src/backend/domains/session/index.ts
  </files>
  <action>
**Step 1: Update `src/backend/domains/session/runtime/index.ts`:**

Add ACP exports alongside existing runtime manager exports:

```typescript
export type { AcpRuntimeEventHandlers } from '../acp/acp-runtime-manager';
export { AcpRuntimeManager, acpRuntimeManager } from '../acp';
export type { AcpClientOptions } from '../acp';
export { AcpProcessHandle } from '../acp';
```

Keep all existing exports intact. Add ACP exports at the end.

**Step 2: Update `src/backend/domains/session/lifecycle/session.service.ts`:**

This is the most critical integration point. Add ACP as a third provider path alongside Claude and Codex. The changes are ADDITIVE -- do not modify existing Claude or Codex code paths.

2a. Add imports at top:
```typescript
import { acpRuntimeManager, type AcpRuntimeEventHandlers } from '@/backend/domains/session/acp';
import type { AcpProcessHandle } from '@/backend/domains/session/acp';
import type { AcpClientOptions } from '@/backend/domains/session/acp';
```

2b. In the `SessionService` class, add a private method to wire ACP events into the delta pipeline:

```typescript
private setupAcpEventHandler(sessionId: string): AcpRuntimeEventHandlers {
  return {
    onAcpEvent: (sid: string, event: unknown) => {
      // Minimal translation: forward ACP events to the delta pipeline
      // The event object from AcpClientHandler already has type/content structure
      const typed = event as { type: string };
      switch (typed.type) {
        case 'acp_agent_message_chunk': {
          const chunk = event as { type: string; content: unknown };
          // Forward as agent_message for the chat UI
          sessionDomainService.emitDelta(sid, {
            type: 'agent_message',
            data: {
              type: 'assistant',
              message: { role: 'assistant', content: [chunk.content] },
            },
          });
          break;
        }
        case 'acp_tool_call': {
          const tc = event as { type: string; toolCallId: string; title: string; kind?: string; status?: string };
          sessionDomainService.emitDelta(sid, {
            type: 'agent_message',
            data: {
              type: 'stream_event',
              event: {
                type: 'content_block_start',
                content_block: {
                  type: 'tool_use',
                  id: tc.toolCallId,
                  name: tc.title,
                },
              },
            },
          });
          break;
        }
        case 'acp_tool_call_update': {
          const tcu = event as { type: string; toolCallId: string; status?: string };
          sessionDomainService.emitDelta(sid, {
            type: 'tool_progress',
            toolUseId: tcu.toolCallId,
            status: tcu.status,
          });
          break;
        }
        default:
          // Other ACP events logged but not forwarded in Phase 19
          break;
      }
    },
    onSessionId: async (sid: string, providerSessionId: string) => {
      try {
        await this.repository.updateSession(sid, { claudeSessionId: providerSessionId });
        logger.debug('Updated session with ACP providerSessionId', { sessionId: sid, providerSessionId });
      } catch (error) {
        logger.warn('Failed to update session with ACP providerSessionId', {
          sessionId: sid,
          providerSessionId,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
    onExit: async (sid: string, exitCode: number | null) => {
      try {
        sessionDomainService.markProcessExit(sid, exitCode);
        const session = await this.repository.updateSession(sid, {
          status: SessionStatus.COMPLETED,
          claudeProcessPid: null,
        });
        logger.debug('Updated ACP session status to COMPLETED on exit', { sessionId: sid });

        await this.repository.clearRatchetActiveSession(session.workspaceId, sid);
        if (session.workflow === 'ratchet') {
          await this.repository.deleteSession(sid);
          logger.debug('Deleted transient ratchet ACP session', { sessionId: sid });
        }
      } catch (error) {
        logger.warn('Failed to update ACP session status on exit', {
          sessionId: sid,
          error: error instanceof Error ? error.message : String(error),
        });
      } finally {
        this.clearSessionProvider(sid);
      }
    },
    onError: (sid: string, error: Error) => {
      logger.error('ACP client error', {
        sessionId: sid,
        error: error.message,
        stack: error.stack,
      });
    },
  };
}
```

2c. Add a `createAcpClient` private method:

```typescript
private async createAcpClient(
  sessionId: string,
  options?: {
    model?: string;
    permissionMode?: 'bypassPermissions' | 'plan';
  },
  session?: AgentSessionRecord,
): Promise<AcpProcessHandle> {
  const sessionContext = await this.loadSessionContext(sessionId, session);
  if (!sessionContext) {
    throw new Error(`Session not found: ${sessionId}`);
  }

  await this.repository.markWorkspaceHasHadSessions(sessionContext.workspaceId);

  const handlers = this.setupAcpEventHandler(sessionId);
  const clientOptions: AcpClientOptions = {
    provider: session?.provider ?? 'CLAUDE',
    workingDir: sessionContext.workingDir,
    model: options?.model ?? sessionContext.model,
    systemPrompt: sessionContext.systemPrompt,
    permissionMode: options?.permissionMode ?? 'bypassPermissions',
    sessionId,
  };

  return await acpRuntimeManager.getOrCreateClient(
    sessionId,
    clientOptions,
    handlers,
    { workspaceId: sessionContext.workspaceId, workingDir: sessionContext.workingDir },
  );
}
```

2d. Update `getOrCreateSessionClient` to add an ACP branch. Add `useAcp?: boolean` to the options parameter. In the method body, after the existing client check and before the try block that creates clients, add:

```typescript
// ACP runtime path (Phase 19: opt-in via useAcp flag)
if (options?.useAcp) {
  const handle = await this.createAcpClient(sessionId, options, session);

  await this.repository.updateSession(sessionId, {
    status: SessionStatus.RUNNING,
    claudeProcessPid: handle.getPid() ?? null,
  });

  sessionDomainService.setRuntimeSnapshot(sessionId, {
    phase: handle.isPromptInFlight ? 'running' : 'idle',
    processState: 'alive',
    activity: handle.isPromptInFlight ? 'WORKING' : 'IDLE',
    updatedAt: new Date().toISOString(),
  });

  return handle;
}
```

Also add `useAcp?: boolean` to the `getOrCreateClient` backward-compatible wrapper's options type.

2e. Add ACP send and cancel methods to SessionService:

```typescript
/**
 * Send a message via ACP runtime. Returns the stop reason from the prompt response.
 * The prompt() call blocks until the turn completes; streaming events arrive
 * concurrently via the AcpClientHandler.sessionUpdate callback.
 */
async sendAcpMessage(sessionId: string, content: string): Promise<string> {
  sessionDomainService.setRuntimeSnapshot(sessionId, {
    phase: 'running',
    processState: 'alive',
    activity: 'WORKING',
    updatedAt: new Date().toISOString(),
  });

  try {
    const result = await acpRuntimeManager.sendPrompt(sessionId, content);
    sessionDomainService.setRuntimeSnapshot(sessionId, {
      phase: 'idle',
      processState: 'alive',
      activity: 'IDLE',
      updatedAt: new Date().toISOString(),
    });
    return result.stopReason;
  } catch (error) {
    sessionDomainService.setRuntimeSnapshot(sessionId, {
      phase: 'error',
      processState: 'alive',
      activity: 'IDLE',
      updatedAt: new Date().toISOString(),
    });
    throw error;
  }
}

/**
 * Cancel an ongoing ACP prompt mid-turn.
 */
async cancelAcpPrompt(sessionId: string): Promise<void> {
  await acpRuntimeManager.cancelPrompt(sessionId);
}
```

2f. Update `sendSessionMessage` to handle ACP sessions. Add a check BEFORE the fallback `loadSessionWithAdapter` call at the end:

```typescript
// Check for ACP session (RUNTIME-05: inherits wiring from user-input.handler.ts
// which calls this method for all providers -- no separate ACP route needed)
const acpClient = acpRuntimeManager.getClient(sessionId);
if (acpClient) {
  const normalizedText = typeof content === 'string' ? content : this.toCodexTextContent(content);
  // Fire and forget -- prompt runs in background, events stream via callback
  void this.sendAcpMessage(sessionId, normalizedText).catch((error) => {
    logger.error('ACP prompt failed', {
      sessionId,
      error: error instanceof Error ? error.message : String(error),
    });
  });
  return;
}
```

2g. Update `stopSession` to handle ACP. Add this check near the beginning, after the loading phase and runtime snapshot set to 'stopping', but before the existing adapter-based stop logic:

```typescript
// Check for ACP session first (RUNTIME-06: inherits wiring from stop.handler.ts
// and session.trpc.ts stopSession mutation -- no separate ACP cancel route needed.
// stopSession handles both "cancel current prompt" and "terminate session".)
const acpHandle = acpRuntimeManager.getClient(sessionId);
if (acpHandle || acpRuntimeManager.isStopInProgress(sessionId)) {
  if (!acpRuntimeManager.isStopInProgress(sessionId)) {
    await acpRuntimeManager.stopClient(sessionId);
  }
  await this.updateStoppedSessionState(sessionId);
  sessionDomainService.clearQueuedWork(sessionId, { emitSnapshot: false });
  sessionDomainService.setRuntimeSnapshot(sessionId, {
    phase: 'idle',
    processState: 'stopped',
    activity: 'IDLE',
    updatedAt: new Date().toISOString(),
  });
  const shouldCleanupTransientRatchetSession = options?.cleanupTransientRatchetSession ?? true;
  await this.cleanupTransientRatchetOnStop(session, sessionId, shouldCleanupTransientRatchetSession);
  logger.info('ACP session stopped', { sessionId });
  this.clearSessionProvider(sessionId);
  return;
}
```

2h. Update `stopAllClients` to also stop ACP sessions. After the existing Claude and Codex stopAll blocks, add:
```typescript
try {
  await acpRuntimeManager.stopAllClients();
} catch (error) {
  if (!firstError) {
    firstError = error;
  }
  logger.error('Failed to stop ACP clients during shutdown', {
    error: error instanceof Error ? error.message : String(error),
  });
}
```

2i. Update `isSessionRunning`, `isSessionWorking`, and `isAnySessionWorking` to also check ACP runtime manager. Add ACP checks before existing adapter checks in each method:

- `isSessionRunning`: add `if (acpRuntimeManager.isSessionRunning(sessionId)) return true;`
- `isSessionWorking`: add `if (acpRuntimeManager.isSessionWorking(sessionId)) return true;`
- `isAnySessionWorking`: add `|| sessionIds.some(id => acpRuntimeManager.isSessionWorking(id))` to the return expression

**Step 3: Update `src/backend/domains/session/index.ts`:**

Add ACP exports to the domain barrel with a new section comment:

```typescript
// ACP runtime (Phase 19+)
export type { AcpClientOptions, AcpSessionState } from './acp';
export { AcpClientHandler, AcpProcessHandle, AcpRuntimeManager, acpRuntimeManager } from './acp';
export type { AcpRuntimeEventHandlers } from './acp';
```

**Step 4: Verify existing tests still pass:**

Run `pnpm test` to ensure no regressions. The changes are additive -- existing Claude and Codex paths are untouched. New ACP paths only activate when `useAcp: true` is passed or an ACP client exists. Run `pnpm typecheck` and `pnpm check:fix` to verify type safety and formatting.
  </action>
  <verify>
Run:
1. `pnpm typecheck` -- zero errors
2. `pnpm test` -- all existing tests pass (no regressions)
3. `pnpm check:fix` -- no lint/format violations
4. Verify ACP exports exist: `grep -r 'acpRuntimeManager' src/backend/domains/session/index.ts` returns matches
5. Verify session service has ACP path: `grep -r 'useAcp' src/backend/domains/session/lifecycle/session.service.ts` returns matches
6. Verify RUNTIME-05 wiring: `grep -r 'sendSessionMessage' src/backend/domains/session/chat/chat-message-handlers/handlers/user-input.handler.ts` confirms user-input handler calls sendSessionMessage (which now has ACP detection)
7. Verify RUNTIME-06 wiring: `grep -r 'stopSession' src/backend/domains/session/chat/chat-message-handlers/handlers/stop.handler.ts` confirms stop handler calls stopSession (which now has ACP detection). Also `grep -r 'stopSession' src/backend/trpc/session.trpc.ts` confirms the tRPC route calls stopSession.
  </verify>
  <done>
SessionService has ACP client creation path activated via `useAcp: true` flag. ACP sessions spawn subprocess, initialize, create session, stream events via emitDelta, and stop cleanly. Session domain barrel exports all ACP types and singletons. All existing tests pass with zero regressions. sendSessionMessage and stopSession are already called by WebSocket handlers and tRPC routes -- ACP path is detected at runtime inside these methods.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify ACP integration end-to-end</name>
  <files>
    src/backend/domains/session/acp/acp-runtime-manager.ts
    src/backend/domains/session/lifecycle/session.service.ts
    src/backend/domains/session/index.ts
  </files>
  <action>
This is a human verification checkpoint. Claude has automated all implementation in Task 1. The user should verify the following to confirm the ACP integration is correct:

**Automated checks (run these):**
1. `pnpm typecheck` -- should report zero errors
2. `pnpm test` -- all tests should pass (including new ACP unit tests from Plan 01)
3. `pnpm check:fix` -- should have no violations

**Structural checks:**
4. Check the new ACP directory exists: `ls src/backend/domains/session/acp/` should show 6 files (types.ts, acp-process-handle.ts, acp-client-handler.ts, acp-runtime-manager.ts, index.ts, acp-runtime-manager.test.ts)
5. Check domain barrel has ACP exports: `grep 'acpRuntimeManager' src/backend/domains/session/index.ts`
6. Check session service has ACP path: `grep 'useAcp' src/backend/domains/session/lifecycle/session.service.ts`

**API wiring verification (RUNTIME-05 / RUNTIME-06):**
7. Verify sendSessionMessage is called from existing WebSocket handler: `grep 'sendSessionMessage' src/backend/domains/session/chat/chat-message-handlers/handlers/user-input.handler.ts` -- should show `sessionService.sendSessionMessage` call. This is the SAME call path used for Claude/Codex. The ACP branch inside sendSessionMessage detects ACP sessions via `acpRuntimeManager.getClient(sessionId)`.
8. Verify stopSession is called from existing WebSocket handler: `grep 'stopSession' src/backend/domains/session/chat/chat-message-handlers/handlers/stop.handler.ts` -- should show `sessionService.stopSession` call. Same call path for all providers. The ACP branch inside stopSession detects ACP sessions via `acpRuntimeManager.getClient(sessionId)`.
9. Verify stopSession is also wired via tRPC: `grep 'stopSession' src/backend/trpc/session.trpc.ts` -- should show tRPC mutation calling `sessionService.stopSession`.

**Event pipeline verification:**
10. Verify the emitDelta pipeline reaches WebSocket: The `setupAcpEventHandler` method calls `sessionDomainService.emitDelta()`. This calls `publisher.emitDelta()` (in session-publisher.ts line 72) which wraps as `{ type: 'session_delta', data: event }` and calls `chatConnectionService.forwardToSession()`. This is the SAME proven pipeline used by Claude and Codex sessions today -- no new WebSocket plumbing needed.

**Optional runtime check:**
11. Start dev server (`pnpm dev`) and verify it starts without errors -- ACP code is loaded but won't activate until `useAcp: true` is used
  </action>
  <verify>User confirms all checks pass by typing "approved"</verify>
  <done>User has verified the end-to-end ACP integration is correct, including that the existing WebSocket/tRPC API routes (user-input.handler, stop.handler, session.trpc) call through to sendSessionMessage and stopSession which detect ACP sessions at runtime. The emitDelta -> WebSocket pipeline is confirmed as the same proven infrastructure used by Claude/Codex.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Full ACP lifecycle code path exists:** SessionService can create ACP client -> spawn subprocess -> initialize -> newSession -> sendPrompt (with streaming) -> cancelPrompt -> stopClient
2. **Streaming pipeline connected:** AcpClientHandler.sessionUpdate -> onAcpEvent callback -> sessionDomainService.emitDelta -> publisher.emitDelta -> chatConnectionService.forwardToSession -> WebSocket push to frontend (SAME pipeline as Claude/Codex)
3. **API wiring inherited (RUNTIME-05):** user-input.handler.ts -> sessionService.sendSessionMessage -> acpRuntimeManager.getClient check -> sendAcpMessage. No new route needed.
4. **API wiring inherited (RUNTIME-06):** stop.handler.ts / session.trpc.ts -> sessionService.stopSession -> acpRuntimeManager.getClient check -> acpRuntimeManager.stopClient. No new cancel route needed.
5. **Event logging:** All ACP events logged to session file logger (EVENT-06)
6. **Process cleanup:** SIGTERM -> grace period -> SIGKILL with non-detached spawn
7. **No regressions:** Existing Claude and Codex paths are untouched, all tests pass
8. **Barrel exports:** Session domain barrel includes AcpRuntimeManager, AcpProcessHandle, AcpClientHandler, types
9. **Opt-in activation:** ACP path only activates with `useAcp: true` -- safe for production
</verification>

<success_criteria>
- Session service has `createAcpClient`, `sendAcpMessage`, `cancelAcpPrompt` methods
- `getOrCreateSessionClient` has ACP branch via `useAcp: true` option
- `sendSessionMessage` checks for ACP client before falling through to legacy adapters
- `stopSession` handles ACP sessions with subprocess termination
- Runtime barrel exports AcpRuntimeManager
- Domain barrel exports all ACP public API
- All existing tests pass (zero regressions)
- TypeScript compiles clean
- Biome lint passes
- Existing WebSocket handlers (user-input, stop) and tRPC routes (stopSession) inherit ACP support without modification
</success_criteria>

<output>
After completion, create `.planning/phases/19-acp-runtime-foundation/19-02-SUMMARY.md`
</output>

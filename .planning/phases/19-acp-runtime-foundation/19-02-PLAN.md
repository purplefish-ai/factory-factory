---
phase: 19-acp-runtime-foundation
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/backend/domains/session/runtime/index.ts
  - src/backend/domains/session/lifecycle/session.service.ts
  - src/backend/domains/session/index.ts
autonomous: false

must_haves:
  truths:
    - "SessionService can start an ACP session by spawning a subprocess, completing the handshake, and emitting runtime state updates"
    - "Sending a prompt via ACP produces streaming agent_message_chunk events that reach the frontend via sessionDomainService.emitDelta"
    - "Cancelling an ACP prompt mid-turn halts the agent and sets isPromptInFlight to false"
    - "Stopping an ACP session terminates the subprocess cleanly with no orphaned processes"
    - "Session domain barrel exports AcpRuntimeManager and related types"
    - "All ACP events are logged to session file logger for debugging"
  artifacts:
    - path: "src/backend/domains/session/runtime/index.ts"
      provides: "AcpRuntimeManager export alongside existing runtime managers"
      contains: "AcpRuntimeManager"
    - path: "src/backend/domains/session/lifecycle/session.service.ts"
      provides: "ACP provider path in getOrCreateSessionClient, sendSessionMessage, stopSession"
    - path: "src/backend/domains/session/index.ts"
      provides: "AcpRuntimeManager and AcpProcessHandle in domain barrel exports"
      contains: "acpRuntimeManager"
  key_links:
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      via: "acpRuntimeManager import and ACP client creation path"
      pattern: "acpRuntimeManager\\."
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/session-domain.service.ts"
      via: "emitDelta for ACP streaming events"
      pattern: "sessionDomainService\\.emitDelta"
    - from: "src/backend/domains/session/index.ts"
      to: "src/backend/domains/session/acp/index.ts"
      via: "re-exports from ACP submodule"
      pattern: "from './acp'"
---

<objective>
Wire the ACP runtime into the session service, event forwarding pipeline, and domain barrel to complete the end-to-end session lifecycle (start -> prompt -> stream -> cancel -> stop).

Purpose: Without this wiring, the AcpRuntimeManager from Plan 01 exists in isolation. This plan connects it to the session domain's existing infrastructure so that starting a session with a future ACP provider flag actually spawns an ACP subprocess and streams events to the frontend.

Output: A fully wired ACP session path in SessionService alongside the existing Claude and Codex paths. The session domain barrel exports ACP types and the singleton. A human-verified end-to-end test confirms the integration.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-acp-runtime-foundation/19-RESEARCH.md
@.planning/phases/19-acp-runtime-foundation/19-01-SUMMARY.md

@src/backend/domains/session/runtime/index.ts
@src/backend/domains/session/runtime/provider-runtime-manager.ts
@src/backend/domains/session/lifecycle/session.service.ts
@src/backend/domains/session/index.ts
@src/backend/domains/session/session-domain.service.ts
@src/backend/domains/session/providers/session-provider-adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire AcpRuntimeManager into session service and event pipeline</name>
  <files>
    src/backend/domains/session/runtime/index.ts
    src/backend/domains/session/lifecycle/session.service.ts
    src/backend/domains/session/index.ts
  </files>
  <action>
**Step 1: Update `src/backend/domains/session/runtime/index.ts`:**

Add ACP exports alongside existing runtime manager exports:

```typescript
export type { AcpRuntimeEventHandlers } from '../acp/acp-runtime-manager';
export { AcpRuntimeManager, acpRuntimeManager } from '../acp';
export type { AcpClientOptions } from '../acp';
export { AcpProcessHandle } from '../acp';
```

Keep all existing exports intact. Add ACP exports at the end.

**Step 2: Update `src/backend/domains/session/lifecycle/session.service.ts`:**

This is the most critical integration point. Add ACP as a third provider path alongside Claude and Codex. The changes are ADDITIVE -- do not modify existing Claude or Codex code paths.

2a. Add imports at top:
```typescript
import { acpRuntimeManager, type AcpRuntimeEventHandlers } from '@/backend/domains/session/acp';
import type { AcpProcessHandle } from '@/backend/domains/session/acp';
import type { AcpClientOptions } from '@/backend/domains/session/acp';
```

2b. In the `SessionService` class, add a private method to wire ACP events into the delta pipeline:

```typescript
private setupAcpEventHandler(sessionId: string): AcpRuntimeEventHandlers {
  return {
    onAcpEvent: (sid: string, event: unknown) => {
      // Minimal translation: forward ACP events to the delta pipeline
      // The event object from AcpClientHandler already has type/content structure
      const typed = event as { type: string };
      switch (typed.type) {
        case 'acp_agent_message_chunk': {
          const chunk = event as { type: string; content: unknown };
          // Forward as agent_message for the chat UI
          sessionDomainService.emitDelta(sid, {
            type: 'agent_message',
            data: {
              type: 'assistant',
              message: { role: 'assistant', content: [chunk.content] },
            },
          });
          break;
        }
        case 'acp_tool_call': {
          const tc = event as { type: string; toolCallId: string; title: string; kind?: string; status?: string };
          sessionDomainService.emitDelta(sid, {
            type: 'agent_message',
            data: {
              type: 'stream_event',
              event: {
                type: 'content_block_start',
                content_block: {
                  type: 'tool_use',
                  id: tc.toolCallId,
                  name: tc.title,
                },
              },
            },
          });
          break;
        }
        case 'acp_tool_call_update': {
          const tcu = event as { type: string; toolCallId: string; status?: string };
          sessionDomainService.emitDelta(sid, {
            type: 'tool_progress',
            toolUseId: tcu.toolCallId,
            status: tcu.status,
          });
          break;
        }
        default:
          // Other ACP events logged but not forwarded in Phase 19
          break;
      }
    },
    onSessionId: async (sid: string, providerSessionId: string) => {
      try {
        await this.repository.updateSession(sid, { claudeSessionId: providerSessionId });
        logger.debug('Updated session with ACP providerSessionId', { sessionId: sid, providerSessionId });
      } catch (error) {
        logger.warn('Failed to update session with ACP providerSessionId', {
          sessionId: sid,
          providerSessionId,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
    onExit: async (sid: string, exitCode: number | null) => {
      try {
        sessionDomainService.markProcessExit(sid, exitCode);
        const session = await this.repository.updateSession(sid, {
          status: SessionStatus.COMPLETED,
          claudeProcessPid: null,
        });
        logger.debug('Updated ACP session status to COMPLETED on exit', { sessionId: sid });

        await this.repository.clearRatchetActiveSession(session.workspaceId, sid);
        if (session.workflow === 'ratchet') {
          await this.repository.deleteSession(sid);
          logger.debug('Deleted transient ratchet ACP session', { sessionId: sid });
        }
      } catch (error) {
        logger.warn('Failed to update ACP session status on exit', {
          sessionId: sid,
          error: error instanceof Error ? error.message : String(error),
        });
      } finally {
        this.clearSessionProvider(sid);
      }
    },
    onError: (sid: string, error: Error) => {
      logger.error('ACP client error', {
        sessionId: sid,
        error: error.message,
        stack: error.stack,
      });
    },
  };
}
```

2c. Add a `createAcpClient` private method:

```typescript
private async createAcpClient(
  sessionId: string,
  options?: {
    model?: string;
    permissionMode?: 'bypassPermissions' | 'plan';
  },
  session?: AgentSessionRecord,
): Promise<AcpProcessHandle> {
  const sessionContext = await this.loadSessionContext(sessionId, session);
  if (!sessionContext) {
    throw new Error(`Session not found: ${sessionId}`);
  }

  await this.repository.markWorkspaceHasHadSessions(sessionContext.workspaceId);

  const handlers = this.setupAcpEventHandler(sessionId);
  const clientOptions: AcpClientOptions = {
    provider: session?.provider ?? 'CLAUDE',
    workingDir: sessionContext.workingDir,
    model: options?.model ?? sessionContext.model,
    systemPrompt: sessionContext.systemPrompt,
    permissionMode: options?.permissionMode ?? 'bypassPermissions',
    sessionId,
  };

  return await acpRuntimeManager.getOrCreateClient(
    sessionId,
    clientOptions,
    handlers,
    { workspaceId: sessionContext.workspaceId, workingDir: sessionContext.workingDir },
  );
}
```

2d. Update `getOrCreateSessionClient` to add an ACP branch. Add `useAcp?: boolean` to the options parameter. In the method body, after the existing client check and before the try block that creates clients, add:

```typescript
// ACP runtime path (Phase 19: opt-in via useAcp flag)
if (options?.useAcp) {
  const handle = await this.createAcpClient(sessionId, options, session);

  await this.repository.updateSession(sessionId, {
    status: SessionStatus.RUNNING,
    claudeProcessPid: handle.getPid() ?? null,
  });

  sessionDomainService.setRuntimeSnapshot(sessionId, {
    phase: handle.isPromptInFlight ? 'running' : 'idle',
    processState: 'alive',
    activity: handle.isPromptInFlight ? 'WORKING' : 'IDLE',
    updatedAt: new Date().toISOString(),
  });

  return handle;
}
```

Also add `useAcp?: boolean` to the `getOrCreateClient` backward-compatible wrapper's options type.

2e. Add ACP send and cancel methods to SessionService:

```typescript
/**
 * Send a message via ACP runtime. Returns the stop reason from the prompt response.
 * The prompt() call blocks until the turn completes; streaming events arrive
 * concurrently via the AcpClientHandler.sessionUpdate callback.
 */
async sendAcpMessage(sessionId: string, content: string): Promise<string> {
  sessionDomainService.setRuntimeSnapshot(sessionId, {
    phase: 'running',
    processState: 'alive',
    activity: 'WORKING',
    updatedAt: new Date().toISOString(),
  });

  try {
    const result = await acpRuntimeManager.sendPrompt(sessionId, content);
    sessionDomainService.setRuntimeSnapshot(sessionId, {
      phase: 'idle',
      processState: 'alive',
      activity: 'IDLE',
      updatedAt: new Date().toISOString(),
    });
    return result.stopReason;
  } catch (error) {
    sessionDomainService.setRuntimeSnapshot(sessionId, {
      phase: 'error',
      processState: 'alive',
      activity: 'IDLE',
      updatedAt: new Date().toISOString(),
    });
    throw error;
  }
}

/**
 * Cancel an ongoing ACP prompt mid-turn.
 */
async cancelAcpPrompt(sessionId: string): Promise<void> {
  await acpRuntimeManager.cancelPrompt(sessionId);
}
```

2f. Update `sendSessionMessage` to handle ACP sessions. Add a check BEFORE the fallback `loadSessionWithAdapter` call at the end:

```typescript
// Check for ACP session
const acpClient = acpRuntimeManager.getClient(sessionId);
if (acpClient) {
  const normalizedText = typeof content === 'string' ? content : this.toCodexTextContent(content);
  // Fire and forget -- prompt runs in background, events stream via callback
  void this.sendAcpMessage(sessionId, normalizedText).catch((error) => {
    logger.error('ACP prompt failed', {
      sessionId,
      error: error instanceof Error ? error.message : String(error),
    });
  });
  return;
}
```

2g. Update `stopSession` to handle ACP. Add this check near the beginning, after the loading phase and runtime snapshot set to 'stopping', but before the existing adapter-based stop logic:

```typescript
// Check for ACP session first
const acpHandle = acpRuntimeManager.getClient(sessionId);
if (acpHandle || acpRuntimeManager.isStopInProgress(sessionId)) {
  if (!acpRuntimeManager.isStopInProgress(sessionId)) {
    await acpRuntimeManager.stopClient(sessionId);
  }
  await this.updateStoppedSessionState(sessionId);
  sessionDomainService.clearQueuedWork(sessionId, { emitSnapshot: false });
  sessionDomainService.setRuntimeSnapshot(sessionId, {
    phase: 'idle',
    processState: 'stopped',
    activity: 'IDLE',
    updatedAt: new Date().toISOString(),
  });
  const shouldCleanupTransientRatchetSession = options?.cleanupTransientRatchetSession ?? true;
  await this.cleanupTransientRatchetOnStop(session, sessionId, shouldCleanupTransientRatchetSession);
  logger.info('ACP session stopped', { sessionId });
  this.clearSessionProvider(sessionId);
  return;
}
```

2h. Update `stopAllClients` to also stop ACP sessions. After the existing Claude and Codex stopAll blocks, add:
```typescript
try {
  await acpRuntimeManager.stopAllClients();
} catch (error) {
  if (!firstError) {
    firstError = error;
  }
  logger.error('Failed to stop ACP clients during shutdown', {
    error: error instanceof Error ? error.message : String(error),
  });
}
```

2i. Update `isSessionRunning`, `isSessionWorking`, and `isAnySessionWorking` to also check ACP runtime manager. Add ACP checks before existing adapter checks in each method:

- `isSessionRunning`: add `if (acpRuntimeManager.isSessionRunning(sessionId)) return true;`
- `isSessionWorking`: add `if (acpRuntimeManager.isSessionWorking(sessionId)) return true;`
- `isAnySessionWorking`: add `|| sessionIds.some(id => acpRuntimeManager.isSessionWorking(id))` to the return expression

**Step 3: Update `src/backend/domains/session/index.ts`:**

Add ACP exports to the domain barrel with a new section comment:

```typescript
// ACP runtime (Phase 19+)
export type { AcpClientOptions, AcpSessionState } from './acp';
export { AcpClientHandler, AcpProcessHandle, AcpRuntimeManager, acpRuntimeManager } from './acp';
export type { AcpRuntimeEventHandlers } from './acp';
```

**Step 4: Verify existing tests still pass:**

Run `pnpm test` to ensure no regressions. The changes are additive -- existing Claude and Codex paths are untouched. New ACP paths only activate when `useAcp: true` is passed or an ACP client exists. Run `pnpm typecheck` and `pnpm check:fix` to verify type safety and formatting.
  </action>
  <verify>
Run:
1. `pnpm typecheck` -- zero errors
2. `pnpm test` -- all existing tests pass (no regressions)
3. `pnpm check:fix` -- no lint/format violations
4. Verify ACP exports exist: `grep -r 'acpRuntimeManager' src/backend/domains/session/index.ts` returns matches
5. Verify session service has ACP path: `grep -r 'useAcp' src/backend/domains/session/lifecycle/session.service.ts` returns matches
  </verify>
  <done>
SessionService has ACP client creation path activated via `useAcp: true` flag. ACP sessions spawn subprocess, initialize, create session, stream events via emitDelta, and stop cleanly. Session domain barrel exports all ACP types and singletons. All existing tests pass with zero regressions.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify ACP integration end-to-end</name>
  <files>
    src/backend/domains/session/acp/acp-runtime-manager.ts
    src/backend/domains/session/lifecycle/session.service.ts
    src/backend/domains/session/index.ts
  </files>
  <action>
This is a human verification checkpoint. Claude has automated all implementation in Task 1. The user should verify the following to confirm the ACP integration is correct:

1. Run `pnpm typecheck` -- should report zero errors
2. Run `pnpm test` -- all tests should pass (including new ACP unit tests from Plan 01)
3. Run `pnpm check:fix` -- should have no violations
4. Check the new ACP directory exists: `ls src/backend/domains/session/acp/` should show 6 files (types.ts, acp-process-handle.ts, acp-client-handler.ts, acp-runtime-manager.ts, index.ts, acp-runtime-manager.test.ts)
5. Check domain barrel has ACP exports: `grep 'acpRuntimeManager' src/backend/domains/session/index.ts`
6. Check session service has ACP path: `grep 'useAcp' src/backend/domains/session/lifecycle/session.service.ts`
7. Optionally: Start dev server (`pnpm dev`) and verify it starts without errors -- ACP code is loaded but won't activate until `useAcp: true` is used
  </action>
  <verify>User confirms all checks pass by typing "approved"</verify>
  <done>User has verified the end-to-end ACP integration is correct and all automated checks pass.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Full ACP lifecycle code path exists:** SessionService can create ACP client -> spawn subprocess -> initialize -> newSession -> sendPrompt (with streaming) -> cancelPrompt -> stopClient
2. **Streaming pipeline connected:** AcpClientHandler.sessionUpdate -> onAcpEvent callback -> sessionDomainService.emitDelta -> WebSocket push to frontend
3. **Event logging:** All ACP events logged to session file logger (EVENT-06)
4. **Process cleanup:** SIGTERM -> grace period -> SIGKILL with non-detached spawn
5. **No regressions:** Existing Claude and Codex paths are untouched, all tests pass
6. **Barrel exports:** Session domain barrel includes AcpRuntimeManager, AcpProcessHandle, AcpClientHandler, types
7. **Opt-in activation:** ACP path only activates with `useAcp: true` -- safe for production
</verification>

<success_criteria>
- Session service has `createAcpClient`, `sendAcpMessage`, `cancelAcpPrompt` methods
- `getOrCreateSessionClient` has ACP branch via `useAcp: true` option
- `sendSessionMessage` checks for ACP client before falling through to legacy adapters
- `stopSession` handles ACP sessions with subprocess termination
- Runtime barrel exports AcpRuntimeManager
- Domain barrel exports all ACP public API
- All existing tests pass (zero regressions)
- TypeScript compiles clean
- Biome lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/19-acp-runtime-foundation/19-02-SUMMARY.md`
</output>

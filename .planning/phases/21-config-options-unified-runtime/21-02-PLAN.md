---
phase: 21-config-options-unified-runtime
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/components/chat/reducer/types.ts
  - src/components/chat/reducer/state.ts
  - src/components/chat/reducer/index.ts
  - src/components/chat/reducer/slices/settings.ts
  - src/components/chat/use-chat-websocket.ts
  - src/components/chat/use-chat-state.ts
  - src/components/chat/use-chat-actions.ts
  - src/components/chat/chat-input/components/acp-config-selector.tsx
  - src/components/chat/chat-input/chat-input.tsx
autonomous: true

must_haves:
  truths:
    - "Config option selectors appear in the chat input bar grouped by category when ACP configOptions are populated"
    - "Selecting a config option sends set_config_option WebSocket message with configId and value"
    - "config_options_update WebSocket events update the UI reactively without user action"
    - "Unknown config option categories render as generic dropdowns (no hardcoded category list)"
    - "Non-ACP sessions continue to use existing ChatBarCapabilities UI unchanged"
  artifacts:
    - path: "src/components/chat/chat-input/components/acp-config-selector.tsx"
      provides: "Generic ACP config option dropdown component"
      exports: ["AcpConfigSelector"]
    - path: "src/components/chat/reducer/types.ts"
      provides: "AcpConfigOption types and CONFIG_OPTIONS_UPDATE action"
      contains: "AcpConfigOption"
    - path: "src/components/chat/reducer/state.ts"
      provides: "acpConfigOptions in initial and reset states"
      contains: "acpConfigOptions"
  key_links:
    - from: "src/components/chat/chat-input/chat-input.tsx"
      to: "src/components/chat/chat-input/components/acp-config-selector.tsx"
      via: "import and render when acpConfigOptions present"
      pattern: "AcpConfigSelector"
    - from: "src/components/chat/use-chat-websocket.ts"
      to: "reducer dispatch CONFIG_OPTIONS_UPDATE"
      via: "WebSocket message handler for config_options_update"
      pattern: "CONFIG_OPTIONS_UPDATE"
    - from: "src/components/chat/use-chat-actions.ts"
      to: "ws.send set_config_option"
      via: "setConfigOption action"
      pattern: "set_config_option"
---

<objective>
Frontend config options UI: reducer state, WebSocket handling, and config selector components

Purpose: Render ACP agent-provided config options (model, mode, thought level, custom) as grouped selectors in the chat input bar, handle config_options_update messages reactively, and send set_config_option messages when user selects an option.

Output: AcpConfigSelector component, reducer with acpConfigOptions state, WebSocket message handling, chat input integration.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-config-options-unified-runtime/21-RESEARCH.md
@.planning/phases/21-config-options-unified-runtime/21-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reducer state, actions, and WebSocket message handling for config options</name>
  <files>
    src/components/chat/reducer/types.ts
    src/components/chat/reducer/state.ts
    src/components/chat/reducer/slices/settings.ts
    src/components/chat/reducer/index.ts
    src/components/chat/use-chat-websocket.ts
    src/components/chat/use-chat-state.ts
    src/components/chat/use-chat-actions.ts
  </files>
  <action>
    1. **Reducer types** (`reducer/types.ts`):
       - Add `AcpConfigOption` interface: `{ id: string; name: string; description?: string; type: string; category?: string; currentValue: string; options: Array<{ value: string; name: string; description?: string } | { group: string; options: Array<{ value: string; name: string; description?: string }> }> }`. Use a union for options to handle both flat and grouped arrays (per SDK SessionConfigSelectOptions type).
       - Add `acpConfigOptions: AcpConfigOption[] | null` to `ChatState`.
       - Add `CONFIG_OPTIONS_UPDATE` action to `ChatAction`: `{ type: 'CONFIG_OPTIONS_UPDATE'; payload: { configOptions: AcpConfigOption[] } }`.

    2. **Reducer state** (`reducer/state.ts`):
       - Add `acpConfigOptions: null` to `createInitialChatState`.
       - Add `acpConfigOptions: null` to `createBaseResetState` (and its Pick type).
       - Add `acpConfigOptions: null` to `createSessionSwitchResetState` (and its Pick type, inherits from base).

    3. **Reducer slice** (`reducer/slices/settings.ts`):
       - Add `handleConfigOptionsUpdate` function: takes state and `{ configOptions: AcpConfigOption[] }` payload, returns `{ ...state, acpConfigOptions: payload.configOptions }`.

    4. **Reducer index** (`reducer/index.ts`):
       - Add `config_options_update` to the WebSocket message type handler map: extract configOptions from message, dispatch `CONFIG_OPTIONS_UPDATE` action.
       - Add `CONFIG_OPTIONS_UPDATE` case to the main reducer switch that calls `handleConfigOptionsUpdate`.

    5. **use-chat-websocket.ts**:
       - Expose `acpConfigOptions` from the reducer state in the return value.

    6. **use-chat-state.ts**:
       - Include `acpConfigOptions` in the state exposed to consumers.

    7. **use-chat-actions.ts**:
       - Add `setConfigOption(configId: string, value: string)` action that sends `{ type: 'set_config_option', configId, value }` via WebSocket. Follow the same pattern as `setModel` or `setThinkingBudget` -- simple ws.send with JSON.stringify. Do NOT optimistically update state (wait for authoritative server response per anti-pattern in research).
  </action>
  <verify>
    `pnpm typecheck` passes. `pnpm test` passes. `pnpm check:fix` passes.
  </verify>
  <done>
    Reducer manages acpConfigOptions state. config_options_update WebSocket messages update state. setConfigOption action sends set_config_option messages. State is reset on session switch and clear.
  </done>
</task>

<task type="auto">
  <name>Task 2: AcpConfigSelector component and chat-input integration</name>
  <files>
    src/components/chat/chat-input/components/acp-config-selector.tsx
    src/components/chat/chat-input/chat-input.tsx
  </files>
  <action>
    1. **AcpConfigSelector** (NEW `acp-config-selector.tsx`):
       - Create a generic config option dropdown following the existing `ModelSelector` pattern (shadcn DropdownMenu + DropdownMenuRadioGroup).
       - Props: `configOption: AcpConfigOption`, `onSelect: (configId: string, value: string) => void`, `disabled?: boolean`.
       - Display the current value's name as the trigger label, or fall back to `configOption.name`.
       - Handle both flat and grouped option arrays: check if the first element has a `group` property. For flat arrays, render `DropdownMenuRadioItem` for each option. For grouped arrays, render `DropdownMenuLabel` for each group header followed by its options.
       - Use `ChevronDown` icon matching `ModelSelector` style.
       - Styling: match existing `ModelSelector` -- `variant="ghost" size="sm"` with `h-6 gap-1 px-2 text-xs text-muted-foreground hover:text-foreground`.

    2. **Chat input integration** (`chat-input.tsx`):
       - Import `AcpConfigSelector` and `AcpConfigOption` type.
       - Accept `acpConfigOptions?: AcpConfigOption[] | null` and `onSetConfigOption?: (configId: string, value: string) => void` props. Thread these from the parent components.
       - In the left controls area (where `ModelSelector` renders), when `acpConfigOptions` is non-null and has entries:
         - **Hide the legacy ModelSelector/reasoning/thinking controls** (they're replaced by ACP config options for ACP sessions).
         - Render one `AcpConfigSelector` per config option, separated by dividers matching the existing pattern.
         - Group ordering: render known categories first (model, mode, thought_level) then custom categories. Use the order from the configOptions array (agent-authoritative ordering).
       - When `acpConfigOptions` is null or empty, show legacy controls (existing behavior preserved).
       - Wire `onSetConfigOption` to each `AcpConfigSelector`'s `onSelect` prop.
       - The props need to be threaded from the parent components that pass capabilities today. Check `workspace-detail-chat-content.tsx` and `workspace-detail-container.tsx` -- add `acpConfigOptions` and `onSetConfigOption` props to the chain, reading from `use-chat-websocket` and `use-chat-actions`.
  </action>
  <verify>
    `pnpm typecheck` passes. `pnpm test` passes. `pnpm check:fix` passes. `pnpm build` passes (Vite frontend build).
  </verify>
  <done>
    AcpConfigSelector renders for each agent-provided config option. Chat input shows ACP config selectors when acpConfigOptions exist, hides legacy selectors. Config selection sends set_config_option message. Non-ACP sessions show legacy controls.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck && pnpm test && pnpm check:fix && pnpm build` all pass
- AcpConfigOption type handles flat and grouped option arrays
- CONFIG_OPTIONS_UPDATE action updates acpConfigOptions in state
- config_options_update WebSocket message dispatches CONFIG_OPTIONS_UPDATE action
- setConfigOption action sends set_config_option without optimistic update
- AcpConfigSelector renders dropdown with current value, grouped options
- Chat input conditionally shows ACP selectors vs legacy selectors
- State resets on session switch and clear chat
</verification>

<success_criteria>
- Config option selectors appear in chat input when ACP config options are populated
- Selecting an option sends set_config_option message to backend
- config_options_update messages reactively update the UI
- Unknown categories render as generic dropdowns
- Non-ACP sessions show legacy ChatBarCapabilities controls unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/21-config-options-unified-runtime/21-02-SUMMARY.md`
</output>

---
phase: 21-config-options-unified-runtime
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backend/domains/session/acp/acp-process-handle.ts
  - src/backend/domains/session/acp/acp-event-translator.ts
  - src/backend/domains/session/acp/acp-runtime-manager.ts
  - src/backend/domains/session/acp/types.ts
  - src/backend/domains/session/acp/index.ts
  - src/backend/domains/session/lifecycle/session.service.ts
  - src/shared/websocket/chat-message.schema.ts
  - src/backend/domains/session/chat/chat-message-handlers/handlers/set-config-option.handler.ts
  - src/backend/domains/session/chat/chat-message-handlers/registry.ts
  - src/shared/claude/protocol/websocket.ts
autonomous: true

must_haves:
  truths:
    - "configOptions from session/new response are stored on AcpProcessHandle and emitted to frontend"
    - "config_option_update ACP notifications are translated to config_options_update WebSocket events"
    - "set_config_option WebSocket message triggers connection.setSessionConfigOption and emits authoritative response"
    - "session/load is attempted when agent advertises loadSession capability and a stored providerSessionId exists"
    - "loadSession failure gracefully falls back to newSession"
  artifacts:
    - path: "src/backend/domains/session/acp/acp-process-handle.ts"
      provides: "configOptions field on AcpProcessHandle"
      contains: "configOptions"
    - path: "src/backend/domains/session/acp/acp-event-translator.ts"
      provides: "config_option_update translation"
      contains: "config_option_update"
    - path: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      provides: "setConfigOption and loadSession methods"
      contains: "setConfigOption"
    - path: "src/backend/domains/session/chat/chat-message-handlers/handlers/set-config-option.handler.ts"
      provides: "set_config_option WebSocket handler"
      exports: ["createSetConfigOptionHandler"]
    - path: "src/shared/claude/protocol/websocket.ts"
      provides: "config_options_update WebSocket message type"
      contains: "config_options_update"
  key_links:
    - from: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      to: "ClientSideConnection.setSessionConfigOption()"
      via: "SDK method call"
      pattern: "connection\\.setSessionConfigOption"
    - from: "src/backend/domains/session/chat/chat-message-handlers/handlers/set-config-option.handler.ts"
      to: "sessionService.setSessionConfigOption()"
      via: "handler calling service method"
      pattern: "sessionService\\.setSessionConfigOption"
    - from: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      to: "ClientSideConnection.loadSession()"
      via: "SDK method call in createClient"
      pattern: "connection\\.loadSession"
---

<objective>
Backend config options lifecycle: parse, store, translate, set, and session resume

Purpose: Implement the backend plumbing so that ACP configOptions (model, mode, thought level) flow from the agent to the frontend and back, and session resume works via loadSession when supported.

Output: AcpProcessHandle stores configOptions, AcpEventTranslator handles config_option_update, AcpRuntimeManager has setConfigOption/loadSession, new set_config_option WS handler, config_options_update WS message type.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-config-options-unified-runtime/21-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ACP config options storage, translation, and runtime manager methods</name>
  <files>
    src/backend/domains/session/acp/acp-process-handle.ts
    src/backend/domains/session/acp/acp-event-translator.ts
    src/backend/domains/session/acp/acp-runtime-manager.ts
    src/backend/domains/session/acp/types.ts
    src/backend/domains/session/acp/index.ts
    src/shared/claude/protocol/websocket.ts
  </files>
  <action>
    1. **AcpProcessHandle** (`acp-process-handle.ts`): Add `configOptions: SessionConfigOption[]` field (import type from `@agentclientprotocol/sdk`). Initialize to `[]` in constructor. This stores the agent-authoritative config state.

    2. **AcpEventTranslator** (`acp-event-translator.ts`): Replace the `config_option_update` deferred case (currently returns `[]`) with actual translation. Extract the `configOptions` array from the update and return a `config_options_update` SessionDeltaEvent. Also handle `current_mode_update` similarly if it carries config-relevant data (check SDK type -- if it only has mode name, translate to a lightweight delta or keep deferred). Use the Extract type pattern from existing cases.

    3. **WebSocket types** (`src/shared/claude/protocol/websocket.ts`): Add `config_options_update` entry to `WebSocketMessagePayloadByType` with shape `{ configOptions: Array<{ id: string; name: string; description?: string; type: string; category?: string; currentValue: string; options: unknown[] }> }`. Use a loose options type to avoid importing ACP SDK types into the shared module. Add to `WEBSOCKET_MESSAGE_TYPE_MAP`.

    4. **AcpRuntimeManager** (`acp-runtime-manager.ts`):
       - In `createClient`, after `connection.newSession()`, store `sessionResult.configOptions ?? []` on the handle: `handle.configOptions = sessionResult.configOptions ?? []`.
       - Add capability-gated session resume: Before `newSession()`, check `agentCapabilities.loadSession === true` AND if a stored `providerSessionId` exists (pass via options). If both true, try `connection.loadSession({ sessionId: storedProviderSessionId, cwd, mcpServers: [] })`. On success, use the loadSession response. On failure (any error), log a warning and fall back to `newSession()`. Store `configOptions` from either response.
       - Add `async setConfigOption(sessionId: string, configId: string, value: string): Promise<unknown[]>` method that calls `handle.connection.setSessionConfigOption({ sessionId: handle.providerSessionId, configId, value })`, stores the returned `configOptions` on the handle, and returns them.

    5. **Types** (`types.ts`): Add optional `resumeProviderSessionId?: string` to `AcpClientOptions` for passing stored provider session ID for session resume.

    6. **Barrel** (`index.ts`): Ensure any new public types/methods are exported.
  </action>
  <verify>
    `pnpm typecheck` passes. `pnpm test` passes. `pnpm check:fix` passes.
  </verify>
  <done>
    AcpProcessHandle has configOptions field, AcpEventTranslator translates config_option_update to config_options_update delta, AcpRuntimeManager has setConfigOption and loadSession-capable createClient, WebSocket types include config_options_update.
  </done>
</task>

<task type="auto">
  <name>Task 2: set_config_option handler, session service wiring, and config options emission</name>
  <files>
    src/shared/websocket/chat-message.schema.ts
    src/backend/domains/session/chat/chat-message-handlers/handlers/set-config-option.handler.ts
    src/backend/domains/session/chat/chat-message-handlers/registry.ts
    src/backend/domains/session/lifecycle/session.service.ts
  </files>
  <action>
    1. **Chat message schema** (`chat-message.schema.ts`): Add `set_config_option` to the `ChatMessageSchema` discriminated union: `z.object({ type: z.literal('set_config_option'), configId: z.string().min(1), value: z.string().min(1) })`. Add the `SetConfigOptionMessage` type export.

    2. **set-config-option handler** (NEW `handlers/set-config-option.handler.ts`): Create following the `set-model.handler.ts` pattern. Handler calls `sessionService.setSessionConfigOption(sessionId, message.configId, message.value)`. On success, the service method emits the config_options_update via emitDelta (authoritative response, not optimistic). On failure, call `sendWebSocketError`. Import from existing handler utils.

    3. **Handler registry** (`registry.ts`): Import and register `createSetConfigOptionHandler()` for the `set_config_option` key.

    4. **SessionService** (`session.service.ts`):
       - Add `async setSessionConfigOption(sessionId: string, configId: string, value: string): Promise<void>` method. Gets ACP handle via `acpRuntimeManager.getClient(sessionId)`. If no handle, throw. Call `acpRuntimeManager.setConfigOption(sessionId, configId, value)`. Emit the returned configOptions as a `config_options_update` delta event via `sessionDomainService.emitDelta(sessionId, { type: 'config_options_update', configOptions })`.
       - In `setupAcpEventHandler`, the `onAcpEvent` handler already translates `acp_session_update` events via `AcpEventTranslator`. The translator now returns `config_options_update` deltas for `config_option_update` events, which flow through `handleAcpDelta` and `emitDelta` automatically. No additional wiring needed for push notifications.
       - In `createAcpClient` / `getOrCreateAcpSessionClient`: After ACP client creation, emit the initial `configOptions` from the handle as a `config_options_update` delta event so the frontend receives config options on session start. Do this after the handle is fully wired: `sessionDomainService.emitDelta(sessionId, { type: 'config_options_update', configOptions: handle.configOptions })`.
       - Pass `resumeProviderSessionId` to `AcpClientOptions` when creating ACP client: read from `session.claudeSessionId` (where providerSessionId is stored by onSessionId handler).
       - Replace the early returns in `setSessionModel` and `setSessionThinkingBudget` (the Phase 21 deferral points) with calls to `setSessionConfigOption` that find the appropriate configId from the handle's configOptions by category. For `setSessionModel`: find configOption with `category === 'model'`, call `setSessionConfigOption(sessionId, configOption.id, model)`. For `setSessionThinkingBudget`: find configOption with `category === 'thought_level'`, call with the appropriate value. If no matching config option found, return silently (agent doesn't support this config).
  </action>
  <verify>
    `pnpm typecheck` passes. `pnpm test` passes. `pnpm check:fix` passes. `pnpm deps:check` passes.
  </verify>
  <done>
    set_config_option WS message is validated, handled, and routes through session service to ACP agent. Config options are emitted on session start and on agent push. setSessionModel/setSessionThinkingBudget for ACP sessions delegate to config options.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck && pnpm test && pnpm check:fix && pnpm deps:check` all pass
- WebSocket types include `config_options_update` with configOptions payload
- `set_config_option` message schema validates configId and value
- Handler registry includes `set_config_option` mapping
- AcpRuntimeManager.createClient stores configOptions from session/new or session/load response
- AcpRuntimeManager.setConfigOption calls SDK and returns updated options
- AcpEventTranslator translates config_option_update events
- SessionService emits config_options_update on session start and on set_config_option response
</verification>

<success_criteria>
- configOptions array flows from agent through AcpProcessHandle to WebSocket
- set_config_option round-trip works: frontend sends -> handler -> session service -> ACP SDK -> response emitted
- config_option_update push notifications translate to config_options_update deltas
- Session resume via loadSession is attempted when capability + stored session ID exist
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/21-config-options-unified-runtime/21-01-SUMMARY.md`
</output>

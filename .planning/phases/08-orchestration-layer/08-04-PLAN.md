---
phase: 08-orchestration-layer
plan: 04
type: execute
wave: 3
depends_on: ["08-03"]
files_modified:
  - src/backend/domains/session/chat/chat-event-forwarder.service.ts
  - src/backend/domains/session/chat/chat-message-handlers.service.ts
  - src/backend/domains/session/bridges.ts
  - src/backend/domains/session/index.ts
  - src/backend/domains/run-script/startup-script.service.ts
  - src/backend/domains/run-script/bridges.ts
  - src/backend/domains/run-script/index.ts
  - src/backend/orchestration/domain-bridges.orchestrator.ts
  - src/backend/orchestration/index.ts
autonomous: true

must_haves:
  truths:
    - "Session domain files no longer import from workspace domain (via shims or direct)"
    - "Run-script domain files no longer import from workspace domain (via shims or direct)"
    - "All domain bridge wiring is handled by orchestration layer at startup"
    - "No domain imports from another domain -- all cross-domain flows go through orchestration or bridges"
    - "pnpm typecheck passes and all tests pass"
  artifacts:
    - path: "src/backend/orchestration/domain-bridges.orchestrator.ts"
      provides: "Wires workspace, github, session, and run-script domain bridges at startup"
      exports: ["configureDomainBridges"]
    - path: "src/backend/domains/session/bridges.ts"
      provides: "Session domain bridge interfaces"
    - path: "src/backend/domains/run-script/bridges.ts"
      provides: "Run-script domain bridge interfaces"
  key_links:
    - from: "src/backend/orchestration/domain-bridges.orchestrator.ts"
      to: "all 6 domain barrels"
      via: "imports singletons to build bridges"
      pattern: "from '@/backend/domains/"
---

<objective>
Remove the last cross-domain imports from session and run-script domains, and wire all remaining bridges via a single orchestration startup function.

Purpose: After Plans 01-03, worktree-lifecycle, ratchet, workspace-query, kanban-state, pr-review-fixer, and pr-snapshot are all clean. This final plan addresses the remaining cross-domain violations: (1) session domain's chat-event-forwarder importing workspace-activity, (2) chat-message-handlers importing workspace-init-policy, (3) run-script's startup-script importing workspace-state-machine, and (4) wires all the bridges from Plans 02/03 via a consolidated orchestration startup function.

Output: Zero cross-domain imports across ALL domain files. Single orchestration startup function that wires all bridges.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-orchestration-layer/08-RESEARCH.md
@src/backend/domains/session/chat/chat-event-forwarder.service.ts
@src/backend/domains/session/chat/chat-message-handlers.service.ts
@src/backend/domains/run-script/startup-script.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove cross-domain imports from session and run-script domains</name>
  <files>
    src/backend/domains/session/chat/chat-event-forwarder.service.ts
    src/backend/domains/session/chat/chat-message-handlers.service.ts
    src/backend/domains/session/bridges.ts
    src/backend/domains/session/index.ts
    src/backend/domains/run-script/startup-script.service.ts
    src/backend/domains/run-script/bridges.ts
    src/backend/domains/run-script/index.ts
  </files>
  <action>
**A. Session domain:**

1. **Create `src/backend/domains/session/bridges.ts`**:
```typescript
/** Workspace activity callback for session domain */
export interface SessionWorkspaceBridge {
  markSessionRunning(workspaceId: string, sessionId: string): void;
  markSessionIdle(workspaceId: string, sessionId: string): void;
  on(event: 'request_notification', handler: (data: {
    workspaceId: string;
    workspaceName: string;
    sessionCount: number;
    finishedAt: Date;
  }) => void): void;
  recordSessionActivity?(workspaceId: string): void;
}

/** Workspace init policy callback for session domain */
export interface SessionInitPolicyBridge {
  getWorkspaceInitPolicy(workspaceId: string): Promise<WorkspaceInitPolicyResult>;
}
```

Define `WorkspaceInitPolicyResult` locally based on what `getWorkspaceInitPolicy` returns (read the function to determine the shape).

2. **Refactor `chat-event-forwarder.service.ts`**:
   - Remove `import { workspaceActivityService } from '@/backend/services/workspace-activity.service'`
   - Add bridge field: `private workspaceBridge: SessionWorkspaceBridge | null = null`
   - Add `configure(bridges: { workspace: SessionWorkspaceBridge }): void`
   - Replace `workspaceActivityService.markSessionRunning(...)` with `this.workspace.markSessionRunning(...)`
   - Replace `workspaceActivityService.markSessionIdle(...)` with `this.workspace.markSessionIdle(...)`
   - Replace `workspaceActivityService.on('request_notification', ...)` in `setupWorkspaceNotifications()` with `this.workspace.on('request_notification', ...)`
   - Private getter: `private get workspace(): SessionWorkspaceBridge` that throws if not configured

3. **Refactor `chat-message-handlers.service.ts`**:
   - Remove `import { getWorkspaceInitPolicy } from '@/backend/services/workspace-init-policy.service'`
   - Read the full file to find where `getWorkspaceInitPolicy` is called
   - Add bridge field: `private initPolicyBridge: SessionInitPolicyBridge | null = null`
   - Add to the existing configure pattern (or add `configure()` if this service doesn't have one yet)
   - Replace `getWorkspaceInitPolicy(...)` with `this.initPolicy.getWorkspaceInitPolicy(...)`

   Also check: `chat-message-handlers.service.ts` imports `sessionService` from `@/backend/services/session.service` and `sessionDataService` from `@/backend/services/session-data.service`. These are INTRA-domain imports that happen to go through the shim path. Fix them to use relative paths:
   - `import { sessionService } from '../lifecycle/session.service'` (or wherever session.service lives in the domain)
   - `import { sessionDataService } from '../data/session-data.service'`

4. **Export bridge types from session barrel**:
   ```typescript
   export type { SessionWorkspaceBridge, SessionInitPolicyBridge } from './bridges';
   ```

**B. Run-script domain:**

5. **Create `src/backend/domains/run-script/bridges.ts`**:
```typescript
/** Workspace state machine callbacks needed by run-script domain */
export interface RunScriptWorkspaceBridge {
  markReady(workspaceId: string): Promise<unknown>;
  markFailed(workspaceId: string, errorMessage: string): Promise<unknown>;
}
```

6. **Refactor `startup-script.service.ts`**:
   - Remove `import { workspaceStateMachine } from '@/backend/services/workspace-state-machine.service'`
   - Add bridge field and `configure()` method
   - Replace `workspaceStateMachine.markReady(...)` and `workspaceStateMachine.markFailed(...)` calls

7. **Export bridge types from run-script barrel**:
   ```typescript
   export type { RunScriptWorkspaceBridge } from './bridges';
   ```

**C. Fix intra-domain shim imports** in session domain (Pitfall 6 from research):
   Check if any session domain files import from `@/backend/services/session.service` (the shim) instead of relative paths. Common offenders noted in research:
   - `session/chat/chat-message-handlers.service.ts` -- fix to relative
   - `session/chat/chat-event-forwarder.service.ts` -- already uses relative `sessionDomainService` from `../session-domain.service`

   For any session files importing through shims, convert to intra-domain relative imports.
  </action>
  <verify>
Run `pnpm typecheck`. Run `pnpm test`. Verify:
- `grep -r "from '@/backend/services/workspace-activity" src/backend/domains/session/` returns no matches
- `grep -r "from '@/backend/services/workspace-init-policy" src/backend/domains/session/` returns no matches
- `grep -r "from '@/backend/services/workspace-state-machine" src/backend/domains/run-script/` returns no matches
- `grep -r "from '@/backend/services/session\\.service" src/backend/domains/session/chat/` returns no matches (intra-domain shims cleaned)
  </verify>
  <done>
Session and run-script domains have zero cross-domain imports. Intra-domain shim imports in session/chat/ are converted to relative paths.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create consolidated domain bridge wiring and verify full cross-domain isolation</name>
  <files>
    src/backend/orchestration/domain-bridges.orchestrator.ts
    src/backend/orchestration/index.ts
  </files>
  <action>
1. **Create `src/backend/orchestration/domain-bridges.orchestrator.ts`**:

This is the single startup function that wires ALL domain bridges (workspace, github, session, run-script). It consolidates the ratchet bridge wiring from Plan 03 into one call.

```typescript
/**
 * Domain Bridge Wiring
 *
 * Single entry point that configures all cross-domain bridges at application startup.
 * Must be called BEFORE any domain service is used.
 *
 * Import graph: orchestration -> all 6 domain barrels
 * Domain services never import each other; they receive capabilities via bridges.
 */
import { sessionService, sessionDomainService, chatEventForwarderService, chatMessageHandlerService } from '@/backend/domains/session';
import { githubCLIService, prSnapshotService, prReviewFixerService } from '@/backend/domains/github';
import { workspaceActivityService, workspaceStateMachine, workspaceQueryService, kanbanStateService, getWorkspaceInitPolicy } from '@/backend/domains/workspace';
import { ratchetService, fixerSessionService, ciFixerService, ciMonitorService } from '@/backend/domains/ratchet';
import { startupScriptService } from '@/backend/domains/run-script';
// terminalService has no cross-domain imports, no bridge needed

export function configureDomainBridges(): void {
  // === Ratchet domain bridges ===
  // (consolidated from ratchet-bridges.orchestrator.ts)
  const ratchetSessionBridge = { ... }; // Build from sessionService, sessionDomainService
  const ratchetGithubBridge = { ... }; // Build from githubCLIService
  ratchetService.configure({ session: ratchetSessionBridge, github: ratchetGithubBridge });
  fixerSessionService.configure({ session: ratchetSessionBridge });
  ciFixerService.configure({ session: ratchetSessionBridge });
  ciMonitorService.configure({ session: ratchetSessionBridge, github: ratchetGithubBridge });

  // === Workspace domain bridges ===
  kanbanStateService.configure({ session: { isAnySessionWorking: (ids) => sessionService.isAnySessionWorking(ids) } });
  workspaceQueryService.configure({
    session: {
      isAnySessionWorking: (ids) => sessionService.isAnySessionWorking(ids),
      getAllPendingRequests: () => chatEventForwarderService.getAllPendingRequests(),
    },
    github: {
      checkHealth: () => githubCLIService.checkHealth(),
      listReviewRequests: () => githubCLIService.listReviewRequests(),
    },
    prSnapshot: {
      refreshWorkspace: (id, url) => prSnapshotService.refreshWorkspace(id, url),
    },
  });

  // === GitHub domain bridges ===
  prReviewFixerService.configure({
    session: {
      isSessionWorking: (id) => sessionService.isSessionWorking(id),
      getClient: (id) => sessionService.getClient(id),
    },
    fixer: {
      acquireAndDispatch: (input) => fixerSessionService.acquireAndDispatch(input),
      getActiveSession: (wsId, wf) => fixerSessionService.getActiveSession(wsId, wf),
    },
  });
  prSnapshotService.configure({
    kanban: {
      updateCachedKanbanColumn: (id) => kanbanStateService.updateCachedKanbanColumn(id),
    },
  });

  // === Session domain bridges ===
  chatEventForwarderService.configure({
    workspace: {
      markSessionRunning: (wsId, sId) => workspaceActivityService.markSessionRunning(wsId, sId),
      markSessionIdle: (wsId, sId) => workspaceActivityService.markSessionIdle(wsId, sId),
      on: (event, handler) => workspaceActivityService.on(event, handler),
    },
  });
  chatMessageHandlerService.configure({
    initPolicy: {
      getWorkspaceInitPolicy: (wsId) => getWorkspaceInitPolicy(wsId),
    },
  });

  // === Run-script domain bridges ===
  startupScriptService.configure({
    workspace: {
      markReady: (id) => workspaceStateMachine.markReady(id),
      markFailed: (id, msg) => workspaceStateMachine.markFailed(id, msg),
    },
  });
}
```

The actual bridge interfaces and configure() signatures come from the types defined in Plans 02-04's bridges.ts files. Adjust the code to match.

2. **If `ratchet-bridges.orchestrator.ts` was created in Plan 03**, either:
   - (Preferred) Merge its logic into `domain-bridges.orchestrator.ts` and delete the separate file, OR
   - Keep it separate and have `configureDomainBridges()` call `configureRatchetBridges()` internally

3. **Update `src/backend/orchestration/index.ts`**:
   - Export `configureDomainBridges` from the barrel
   - Remove `configureRatchetBridges` export if merged

4. **Wire into app startup**: Find where the application initializes services (check `src/backend/app-context.ts` or server startup). Add:
   ```typescript
   import { configureDomainBridges } from '@/backend/orchestration';
   // Call before any domain service usage
   configureDomainBridges();
   ```
   If `configureRatchetBridges()` was already added in Plan 03, replace it with `configureDomainBridges()`.

5. **Full verification scan**: After all bridges are wired, do a comprehensive grep to confirm zero cross-domain imports:
   ```bash
   # Each domain should NOT import from other domain's shim paths
   grep -r "from '@/backend/services/" src/backend/domains/ | grep -v "logger\|config\|constants\|factory-config\|git-ops\|rate-limit\|slash-command\|port\|health\|notification\|file-lock\|data-backup\|scheduler\|server-instance" | grep -v ".test.ts" | grep -v ".spec.ts"
   ```
   Any remaining hits are cross-domain violations that need fixing in this plan.

NOTE: Some session domain files import from `@/backend/services/session-file-logger.service` -- this is an INTRA-domain shim (session-file-logger belongs to session domain). Convert to relative imports if found. Similarly `@/backend/services/session-data.service` and `@/backend/services/session.service` used within the session domain should be relative.
  </action>
  <verify>
Run `pnpm typecheck`. Run `pnpm test`. Comprehensive cross-domain import verification:
```bash
# Verify no domain imports from another domain via shims (excluding infrastructure services)
grep -rn "from '@/backend/services/" src/backend/domains/ --include="*.ts" | grep -v ".test.ts" | grep -v ".spec.ts" | grep -v "logger\|config\\.service\|constants\|factory-config\|git-ops\|rate-limit\|slash-command\|port\|health\|notification\|file-lock\|data-backup\|scheduler\|server-instance"
```
This should return zero matches or only intra-domain shim imports that are acceptable until Phase 9.

Also verify: `npx dependency-cruiser src/backend/domains/ --validate` passes (the no-cross-domain-imports rule).
  </verify>
  <done>
All 6 domain modules have zero cross-domain imports. The orchestration layer provides bridge wiring via configureDomainBridges(). All domain services receive cross-domain capabilities through typed bridge interfaces. All tests pass. Typecheck clean.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm test` passes
- `pnpm check:fix` passes (Biome formatting)
- No domain file imports from another domain's shim (comprehensive grep)
- dependency-cruiser validates clean
- Orchestration layer imports only from domain barrel files
- configureDomainBridges() is called at app startup
</verification>

<success_criteria>
ORCH-01: Cross-domain flows use explicit orchestration layer (workspace-init, workspace-archive orchestrators) or typed bridge interfaces (ratchet, workspace, github, session, run-script bridges). ORCH-02: Workspace creation flow traceable through workspace-init.orchestrator.ts. ORCH-03: Ratchet flow traceable through bridge injection in ratchet services. No direct cross-domain imports. All tests pass. Typecheck clean.
</success_criteria>

<output>
After completion, create `.planning/phases/08-orchestration-layer/08-04-SUMMARY.md`
</output>

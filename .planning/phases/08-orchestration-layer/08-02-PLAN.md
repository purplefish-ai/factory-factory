---
phase: 08-orchestration-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backend/domains/ratchet/ratchet.service.ts
  - src/backend/domains/ratchet/ci-fixer.service.ts
  - src/backend/domains/ratchet/ci-monitor.service.ts
  - src/backend/domains/ratchet/fixer-session.service.ts
autonomous: true

must_haves:
  truths:
    - "Ratchet domain services no longer import from session or github domains (via shims or direct)"
    - "Ratchet domain services accept cross-domain capabilities via bridge interfaces"
    - "All existing ratchet tests pass with bridge-injected dependencies"
  artifacts:
    - path: "src/backend/domains/ratchet/ratchet.service.ts"
      provides: "RatchetService with configurable session and github bridges"
      contains: "configure"
    - path: "src/backend/domains/ratchet/fixer-session.service.ts"
      provides: "FixerSessionService with session bridge"
      contains: "configure"
  key_links:
    - from: "src/backend/domains/ratchet/ratchet.service.ts"
      to: "session bridge"
      via: "configure() method accepting SessionBridge interface"
      pattern: "SessionBridge"
    - from: "src/backend/domains/ratchet/ratchet.service.ts"
      to: "github bridge"
      via: "configure() method accepting GitHubBridge interface"
      pattern: "GitHubBridge"
---

<objective>
Remove cross-domain imports from ratchet domain services by introducing bridge interfaces.

Purpose: The ratchet domain has the heaviest cross-domain coupling: ratchet.service.ts imports from session + github + session-domain, ci-fixer/ci-monitor import from session + github, and fixer-session imports from session. Instead of creating orchestrators for each call (the ratchet polling loop IS the domain logic), inject bridges that provide cross-domain capabilities. The orchestration layer (Plan 03) will wire these bridges at startup.

Output: Ratchet domain services with zero cross-domain imports, using typed bridge interfaces instead.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-orchestration-layer/08-RESEARCH.md
@src/backend/domains/ratchet/ratchet.service.ts
@src/backend/domains/ratchet/ci-fixer.service.ts
@src/backend/domains/ratchet/ci-monitor.service.ts
@src/backend/domains/ratchet/fixer-session.service.ts
@src/backend/domains/ratchet/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bridge interfaces to ratchet domain and refactor ratchet.service.ts + fixer-session.service.ts</name>
  <files>
    src/backend/domains/ratchet/bridges.ts
    src/backend/domains/ratchet/ratchet.service.ts
    src/backend/domains/ratchet/fixer-session.service.ts
    src/backend/domains/ratchet/index.ts
  </files>
  <action>
1. **Create `src/backend/domains/ratchet/bridges.ts`** with typed bridge interfaces that define exactly what the ratchet domain needs from other domains:

```typescript
/**
 * Bridge interfaces for ratchet domain cross-domain dependencies.
 * These are injected by the orchestration layer at startup.
 * The ratchet domain never imports from other domains directly.
 */

/** Session capabilities needed by ratchet domain */
export interface RatchetSessionBridge {
  isSessionRunning(sessionId: string): boolean;
  isSessionWorking(sessionId: string): boolean;
  isAnySessionWorking(sessionIds: string[]): boolean;
  stopClaudeSession(sessionId: string): Promise<void>;
  startClaudeSession(sessionId: string, opts: { initialPrompt?: string }): Promise<void>;
  getClient(sessionId: string): { isRunning(): boolean; sendMessage(msg: string): Promise<void> } | null;
  injectCommittedUserMessage(sessionId: string, message: string): void;
}

/** GitHub capabilities needed by ratchet domain */
export interface RatchetGitHubBridge {
  extractPRInfo(prUrl: string): { owner: string; repo: string; number?: number } | null;
  getPRFullDetails(repo: string, prNumber: number): Promise<PRFullDetailsResult>;
  getReviewComments(repo: string, prNumber: number): Promise<ReviewComment[]>;
  computeCIStatus(statusChecks: StatusCheckInput[] | null): CIStatusResult;
  getAuthenticatedUsername(): Promise<string | null>;
}
```

Define the specific types needed for the return values (PRFullDetailsResult, ReviewComment, StatusCheckInput, CIStatusResult) based on what ratchet.service.ts actually uses from the github service. Keep the types minimal -- only what ratchet actually accesses.

Look at `fetchPRState` in ratchet.service.ts to determine exact shapes:
- `getPRFullDetails` returns: `{ state, number, reviewDecision, reviews: Array<{submittedAt, author: {login}}>, comments: Array<{updatedAt, author: {login}}>, statusCheckRollup: Array<{name, status, conclusion, detailsUrl}> | null }`
- `getReviewComments` returns: `Array<{updatedAt, author: {login}}>`
- `computeCIStatus` takes: `Array<{name?, status?, conclusion?, detailsUrl?}> | null` and returns a `CIStatus` enum value
- `extractPRInfo` returns `{ owner, repo, number? } | null`
- `getAuthenticatedUsername` returns `Promise<string | null>`

Define these inline in bridges.ts as lightweight interfaces (no dependency on the github domain types).

2. **Refactor `ratchet.service.ts`**:
   - Remove imports: `githubCLIService` from `@/backend/services/github-cli.service`, `sessionService` from `@/backend/services/session.service`, `sessionDomainService` from `@/backend/services/session-domain.service`
   - Add `private sessionBridge: RatchetSessionBridge | null = null` and `private githubBridge: RatchetGitHubBridge | null = null` instance fields
   - Add `configure(bridges: { session: RatchetSessionBridge; github: RatchetGitHubBridge }): void` method that sets both bridges
   - Add private getter methods `private get session(): RatchetSessionBridge` and `private get github(): RatchetGitHubBridge` that throw if not configured (fail-fast)
   - Replace all `sessionService.X(...)` calls with `this.session.X(...)`
   - Replace all `githubCLIService.X(...)` calls with `this.github.X(...)`
   - Replace `sessionDomainService.injectCommittedUserMessage(...)` with `this.session.injectCommittedUserMessage(...)`
   - In `triggerFixer`, the `beforeStart` callback uses `sessionDomainService.injectCommittedUserMessage` -- update to `this.session.injectCommittedUserMessage`
   - Keep intra-domain import: `import { fixerSessionService } from './fixer-session.service'` (same domain)
   - Keep infrastructure imports: `createLogger`, `RateLimitBackoff`, constants, resource_accessors

3. **Refactor `fixer-session.service.ts`**:
   - Remove import: `sessionService` from `@/backend/services/session.service`
   - Add `private sessionBridge: RatchetSessionBridge | null = null` field
   - Add `configure(bridges: { session: RatchetSessionBridge }): void` method
   - Add private getter `private get session(): RatchetSessionBridge`
   - Replace `sessionService.isSessionWorking(...)` with `this.session.isSessionWorking(...)`
   - Replace `sessionService.startClaudeSession(...)` with `this.session.startClaudeSession(...)`
   - Replace `sessionService.getClient(...)` with `this.session.getClient(...)`
   - Note: `SessionManager` import from `@/backend/claude/session` is used for `SessionManager.FIXER_SESSION_LIMIT`. This is a constant. Move this limit into fixer-session.service.ts as a local constant (e.g., `const FIXER_SESSION_LIMIT = 5`) or look up the actual value. Actually, check the SessionManager source to find the value and inline it.

4. **Update ratchet barrel** (`index.ts`):
   - Add exports for bridge types:
     ```typescript
     export type { RatchetSessionBridge, RatchetGitHubBridge } from './bridges';
     ```
   These types are needed by the orchestration layer (Plan 03) to wire the bridges.
  </action>
  <verify>
Run `pnpm typecheck` to verify the refactored services compile. Run `pnpm test -- --grep ratchet` or just `pnpm test` to verify ratchet tests still pass. Note: some tests may mock the old service imports -- they will need updating (see Task 2 notes). If tests fail due to mock paths, update mocks in this task.
  </verify>
  <done>
ratchet.service.ts and fixer-session.service.ts have zero cross-domain imports. Both use typed bridge interfaces injected via configure() methods. Bridge types are exported from the ratchet domain barrel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor ci-fixer.service.ts and ci-monitor.service.ts to use bridges</name>
  <files>
    src/backend/domains/ratchet/ci-fixer.service.ts
    src/backend/domains/ratchet/ci-monitor.service.ts
    src/backend/domains/ratchet/bridges.ts
  </files>
  <action>
1. **Refactor `ci-fixer.service.ts`**:
   - Remove import: `sessionService` from `@/backend/services/session.service`
   - Add `private sessionBridge: RatchetSessionBridge | null = null` field
   - Add `configure(bridges: { session: RatchetSessionBridge }): void` method
   - Add private getter `private get session(): RatchetSessionBridge`
   - Replace `sessionService.isSessionWorking(...)` with `this.session.isSessionWorking(...)`
   - Replace `sessionService.getClient(...)` with `this.session.getClient(...)`
   - Keep intra-domain import: `fixerSessionService` from `./fixer-session.service`

2. **Refactor `ci-monitor.service.ts`**:
   - Remove imports: `sessionService` from `@/backend/services/session.service`, `githubCLIService` from `@/backend/services/github-cli.service`
   - Read the full file to understand what methods it uses from sessionService and githubCLIService
   - Add `private sessionBridge: RatchetSessionBridge | null = null` and `private githubBridge: RatchetGitHubBridge | null = null` fields
   - Add `configure(bridges: { session: RatchetSessionBridge; github: RatchetGitHubBridge }): void` method
   - Replace all `sessionService.X(...)` calls with `this.session.X(...)`
   - Replace all `githubCLIService.X(...)` calls with `this.github.X(...)`
   - Keep intra-domain import: `ciFixerService` from `./ci-fixer.service`

   If ci-monitor uses any session/github methods not yet in the bridge interfaces (RatchetSessionBridge, RatchetGitHubBridge), add them to `bridges.ts`. Read the full ci-monitor file first to audit all calls.

3. **Update bridge interface if needed**: After reading ci-monitor.service.ts fully, if it uses additional session or github capabilities not in the bridge types, add them.

4. **Update tests**: If any ratchet test files mock `@/backend/services/session.service` or `@/backend/services/github-cli.service`, update them. The bridge pattern makes testing easier: instead of `vi.mock('@/backend/services/session.service')`, pass mock bridge objects directly through `service.configure({ session: mockSessionBridge })`.

   Find ratchet test files:
   ```bash
   find src/backend/domains/ratchet -name '*.test.ts' -o -name '*.spec.ts'
   ```
   Update each test to use bridge injection instead of module mocking.
  </action>
  <verify>
Run `pnpm typecheck` -- all ratchet domain files compile. Run `pnpm test` -- all ratchet tests pass. Verify no cross-domain imports remain: `grep -r "from '@/backend/services/session" src/backend/domains/ratchet/` and `grep -r "from '@/backend/services/github" src/backend/domains/ratchet/` both return no matches.
  </verify>
  <done>
All 5 ratchet domain service files (ratchet, ci-fixer, ci-monitor, fixer-session, reconciliation) have zero cross-domain imports to session or github. All use bridge interfaces. All ratchet tests pass with bridge injection.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm test` passes
- `grep -r "from '@/backend/services/session" src/backend/domains/ratchet/` returns no matches
- `grep -r "from '@/backend/services/github" src/backend/domains/ratchet/` returns no matches
- `grep -r "from '@/backend/services/session-domain" src/backend/domains/ratchet/` returns no matches
- `grep -r "from '@/backend/services/fixer-session" src/backend/domains/ratchet/` returns no matches (intra-domain uses relative now)
- All ratchet domain services have `configure()` methods for bridge injection
</verification>

<success_criteria>
All 5 ratchet domain service files have zero cross-domain imports. Bridge interfaces are defined and exported from the ratchet barrel. Tests pass with bridge injection.
</success_criteria>

<output>
After completion, create `.planning/phases/08-orchestration-layer/08-02-SUMMARY.md`
</output>

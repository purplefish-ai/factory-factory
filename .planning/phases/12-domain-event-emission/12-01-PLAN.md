---
phase: 12-domain-event-emission
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backend/domains/workspace/lifecycle/state-machine.service.ts
  - src/backend/domains/workspace/lifecycle/state-machine.service.test.ts
  - src/backend/domains/workspace/index.ts
  - src/backend/domains/run-script/run-script-state-machine.service.ts
  - src/backend/domains/run-script/run-script-state-machine.service.test.ts
  - src/backend/domains/run-script/index.ts
autonomous: true

must_haves:
  truths:
    - "Workspace state machine transitions (READY, ARCHIVED, FAILED, etc.) emit events with workspace ID, fromStatus, and toStatus"
    - "Non-standard workspace code paths (startProvisioning FAILED->PROVISIONING, resetToNew FAILED->NEW) also emit events"
    - "Run-script status transitions emit events with workspace ID, fromStatus, and toStatus"
    - "No event is emitted when a CAS fails or transition is invalid"
    - "Events are emitted AFTER the mutation completes, not before"
  artifacts:
    - path: "src/backend/domains/workspace/lifecycle/state-machine.service.ts"
      provides: "WorkspaceStateMachineService extends EventEmitter, emits workspace_state_changed"
      contains: "WORKSPACE_STATE_CHANGED"
    - path: "src/backend/domains/run-script/run-script-state-machine.service.ts"
      provides: "RunScriptStateMachineService extends EventEmitter, emits run_script_status_changed"
      contains: "RUN_SCRIPT_STATUS_CHANGED"
    - path: "src/backend/domains/workspace/index.ts"
      provides: "Barrel exports WORKSPACE_STATE_CHANGED and WorkspaceStateChangedEvent"
      contains: "WORKSPACE_STATE_CHANGED"
    - path: "src/backend/domains/run-script/index.ts"
      provides: "Barrel exports RUN_SCRIPT_STATUS_CHANGED and RunScriptStatusChangedEvent"
      contains: "RUN_SCRIPT_STATUS_CHANGED"
  key_links:
    - from: "src/backend/domains/workspace/lifecycle/state-machine.service.ts"
      to: "node:events"
      via: "extends EventEmitter"
      pattern: "class WorkspaceStateMachineService extends EventEmitter"
    - from: "src/backend/domains/run-script/run-script-state-machine.service.ts"
      to: "node:events"
      via: "extends EventEmitter"
      pattern: "class RunScriptStateMachineService extends EventEmitter"
---

<objective>
Add EventEmitter-based event emission to workspace state machine (EVNT-01) and run-script state machine (EVNT-04).

Purpose: These two state machine services perform status transitions via CAS operations. Adding typed event emission after successful mutations enables downstream consumers (Phase 13 Event Collector) to observe state changes without polling.

Output: Both services extend EventEmitter and emit typed events after every successful state mutation. Event constants and payload types are exported from domain barrels. Tests verify emission on success, silence on failure.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-domain-event-emission/12-RESEARCH.md
@src/backend/domains/workspace/lifecycle/state-machine.service.ts
@src/backend/domains/workspace/lifecycle/state-machine.service.test.ts
@src/backend/domains/workspace/lifecycle/activity.service.ts
@src/backend/domains/workspace/index.ts
@src/backend/domains/run-script/run-script-state-machine.service.ts
@src/backend/domains/run-script/run-script-state-machine.service.test.ts
@src/backend/domains/run-script/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event emission to workspace and run-script state machines</name>
  <files>
    src/backend/domains/workspace/lifecycle/state-machine.service.ts
    src/backend/domains/workspace/index.ts
    src/backend/domains/run-script/run-script-state-machine.service.ts
    src/backend/domains/run-script/index.ts
  </files>
  <action>
**Workspace state machine (state-machine.service.ts):**

1. Add `import { EventEmitter } from 'node:events';` at top.

2. Define event constant and payload type before the class:
```typescript
export const WORKSPACE_STATE_CHANGED = 'workspace_state_changed' as const;

export interface WorkspaceStateChangedEvent {
  workspaceId: string;
  fromStatus: WorkspaceStatus;
  toStatus: WorkspaceStatus;
}
```

3. Change `class WorkspaceStateMachineService` to `class WorkspaceStateMachineService extends EventEmitter`.

4. Add constructor: `constructor() { super(); }`

5. In `transition()` method: add `this.emit(WORKSPACE_STATE_CHANGED, { workspaceId, fromStatus: currentStatus, toStatus: targetStatus } satisfies WorkspaceStateChangedEvent);` AFTER the successful CAS (after the `findRawByIdOrThrow` re-read on line 145), BEFORE the logger.debug call.

6. In `startProvisioning()` method, FAILED -> PROVISIONING path (the `if (currentStatus === 'FAILED')` block around line 183): add emit AFTER the `findRawById` re-read (line 199), before the `logger.debug` call:
```typescript
this.emit(WORKSPACE_STATE_CHANGED, {
  workspaceId,
  fromStatus: 'FAILED' as WorkspaceStatus,
  toStatus: 'PROVISIONING' as WorkspaceStatus,
} satisfies WorkspaceStateChangedEvent);
```
Note: The NEW -> PROVISIONING path (line 179) delegates to `this.transition()` which already emits.

7. In `resetToNew()` method: add emit AFTER the `findRawById` re-read (line 276), before the `logger.debug` call:
```typescript
this.emit(WORKSPACE_STATE_CHANGED, {
  workspaceId,
  fromStatus: 'FAILED' as WorkspaceStatus,
  toStatus: 'NEW' as WorkspaceStatus,
} satisfies WorkspaceStateChangedEvent);
```

**Workspace barrel (workspace/index.ts):**

Add to the state-machine.service exports:
```typescript
export {
  WORKSPACE_STATE_CHANGED,
  type WorkspaceStateChangedEvent,
  // ... existing exports
} from './lifecycle/state-machine.service';
```

**Run-script state machine (run-script-state-machine.service.ts):**

1. Add `import { EventEmitter } from 'node:events';` at top.

2. Define event constant and payload type before the class:
```typescript
export const RUN_SCRIPT_STATUS_CHANGED = 'run_script_status_changed' as const;

export interface RunScriptStatusChangedEvent {
  workspaceId: string;
  fromStatus: RunScriptStatus;
  toStatus: RunScriptStatus;
}
```

3. Change `class RunScriptStateMachineService` to `class RunScriptStateMachineService extends EventEmitter`.

4. Add constructor: `constructor() { super(); }`

5. In `transition()` method: add emit AFTER the `findRawByIdOrThrow` re-read (line 162), BEFORE the `return updated;`:
```typescript
this.emit(RUN_SCRIPT_STATUS_CHANGED, {
  workspaceId,
  fromStatus: currentStatus,
  toStatus: targetStatus,
} satisfies RunScriptStatusChangedEvent);
```
Note: All other methods (start, markRunning, beginStopping, etc.) delegate to `transition()`, so they are automatically covered.

**Run-script barrel (run-script/index.ts):**

Add to the run-script-state-machine.service exports:
```typescript
export {
  RUN_SCRIPT_STATUS_CHANGED,
  type RunScriptStatusChangedEvent,
  // ... existing exports
} from './run-script-state-machine.service';
```
  </action>
  <verify>
Run `pnpm typecheck` to verify no type errors. Run `pnpm test -- src/backend/domains/workspace/lifecycle/state-machine.service.test.ts src/backend/domains/run-script/run-script-state-machine.service.test.ts` to verify existing tests still pass (EventEmitter extension should not break them).
  </verify>
  <done>
Both services extend EventEmitter. WORKSPACE_STATE_CHANGED emits in transition(), startProvisioning() FAILED path, and resetToNew(). RUN_SCRIPT_STATUS_CHANGED emits in transition(). Event constants and types exported from barrels. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add event emission tests for workspace and run-script state machines</name>
  <files>
    src/backend/domains/workspace/lifecycle/state-machine.service.test.ts
    src/backend/domains/run-script/run-script-state-machine.service.test.ts
  </files>
  <action>
**Workspace state machine tests (state-machine.service.test.ts):**

Add a new `describe('event emission')` block with these tests. Import `WORKSPACE_STATE_CHANGED` and `WorkspaceStateChangedEvent` from the service. Use `afterEach(() => workspaceStateMachine.removeAllListeners())` within the describe block to prevent listener leaks.

1. `emits workspace_state_changed after successful transition` -- Set up PROVISIONING workspace, mock successful CAS (updateMany returns count:1), mock findUniqueOrThrow returning READY workspace. Listen for event, call `transition('ws-1', 'READY')`. Assert event received with `{ workspaceId: 'ws-1', fromStatus: 'PROVISIONING', toStatus: 'READY' }`.

2. `does NOT emit on CAS failure` -- Set up PROVISIONING workspace, mock CAS returning count:0. Listen for event, call transition expecting throw. Assert zero events.

3. `does NOT emit on invalid transition` -- Set up NEW workspace, call `transition('ws-1', 'READY')` expecting throw. Assert zero events.

4. `emits event on startProvisioning FAILED->PROVISIONING retry` -- Set up FAILED workspace with initRetryCount:0, mock `startProvisioningRetryIfAllowed` returning count:1, mock findUnique returning PROVISIONING workspace. Listen for event, call `startProvisioning('ws-1')`. Assert event with `{ fromStatus: 'FAILED', toStatus: 'PROVISIONING' }`.

5. `does NOT emit on startProvisioning when max retries exceeded` -- Set up FAILED workspace, mock `startProvisioningRetryIfAllowed` returning count:0. Listen for event, call `startProvisioning('ws-1')`. Assert zero events and result is null.

6. `emits event on resetToNew` -- Set up FAILED workspace, mock `resetToNewIfAllowed` returning count:1, mock findUnique returning NEW workspace. Listen for event, call `resetToNew('ws-1')`. Assert event with `{ fromStatus: 'FAILED', toStatus: 'NEW' }`.

7. `does NOT emit on resetToNew when max retries exceeded` -- Set up FAILED workspace, mock `resetToNewIfAllowed` returning count:0. Assert zero events and result is null.

Note: The workspace accessor mocks are already set up in the test file (mockFindUnique, mockUpdateMany, etc.). You need to check what accessor methods the test file already mocks. If `startProvisioningRetryIfAllowed` and `resetToNewIfAllowed` are not yet mocked, add them to the Prisma mock setup. These methods are on `workspaceAccessor`, which delegates to `prisma.workspace.updateMany` -- check the accessor to understand how to mock them.

**Run-script state machine tests (run-script-state-machine.service.test.ts):**

Add a new `describe('event emission')` block. Import `RUN_SCRIPT_STATUS_CHANGED` and `RunScriptStatusChangedEvent`. Use `afterEach(() => runScriptStateMachine.removeAllListeners())`.

1. `emits run_script_status_changed after successful transition` -- Set up IDLE workspace, mock CAS returning count:1, mock findUniqueOrThrow returning STARTING workspace. Assert event with `{ workspaceId, fromStatus: 'IDLE', toStatus: 'STARTING' }`.

2. `does NOT emit on CAS failure` -- Set up workspace, mock CAS returning count:0, mock findUnique for re-read. Assert zero events and throws.

3. `does NOT emit on invalid transition` -- Set up IDLE workspace, call `transition('ws-1', 'RUNNING')`. Assert zero events and throws.

4. `emits event for each transition in a multi-step flow` -- Chain IDLE->STARTING, STARTING->RUNNING transitions. Assert 2 events with correct from/to pairs.
  </action>
  <verify>
Run `pnpm test -- src/backend/domains/workspace/lifecycle/state-machine.service.test.ts src/backend/domains/run-script/run-script-state-machine.service.test.ts` -- all tests pass including new event emission tests.
  </verify>
  <done>
Workspace state machine has 7 event emission tests covering: successful transition, CAS failure (no emit), invalid transition (no emit), startProvisioning FAILED path, startProvisioning max retries (no emit), resetToNew, resetToNew max retries (no emit). Run-script state machine has 4 event emission tests covering: successful transition, CAS failure, invalid transition, multi-step flow.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with no errors
2. `pnpm test -- src/backend/domains/workspace/lifecycle/state-machine.service.test.ts` -- all tests pass
3. `pnpm test -- src/backend/domains/run-script/run-script-state-machine.service.test.ts` -- all tests pass
4. `pnpm check:fix` passes (Biome formatting/linting)
5. Grep check: `grep -r "snapshot-store\|SnapshotStore" src/backend/domains/workspace/lifecycle/state-machine.service.ts src/backend/domains/run-script/run-script-state-machine.service.ts` returns nothing (no snapshot imports in domains)
</verification>

<success_criteria>
- WorkspaceStateMachineService extends EventEmitter and emits WORKSPACE_STATE_CHANGED on all 3 mutation paths (transition, startProvisioning FAILED path, resetToNew)
- RunScriptStateMachineService extends EventEmitter and emits RUN_SCRIPT_STATUS_CHANGED on transition()
- Events are emitted AFTER successful CAS mutation, never on failure
- Event constants and payload types exported from domain barrels
- 11 new tests pass verifying emission and non-emission behavior
- Zero snapshot-related imports in domain files
</success_criteria>

<output>
After completion, create `.planning/phases/12-domain-event-emission/12-01-SUMMARY.md`
</output>

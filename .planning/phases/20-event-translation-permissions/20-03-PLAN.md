---
phase: 20-event-translation-permissions
plan: 03
type: execute
wave: 3
depends_on: ["20-02"]
files_modified:
  - src/components/chat/permission-prompt.tsx
  - src/components/chat/reducer/slices/requests.ts
  - src/components/chat/reducer/index.ts
  - src/components/chat/reducer/types.ts
  - src/components/chat/use-chat-actions.ts
  - src/components/chat/acp-plan-view.tsx
  - src/components/chat/agent-live-dock.tsx
autonomous: false

must_haves:
  truths:
    - "When acpOptions is present on a permission request, 4 distinct option buttons render (allow once, allow always, deny once, deny always)"
    - "Clicking an ACP option button sends a permission_response with the selected optionId"
    - "When acpOptions is absent, the existing binary Allow/Deny UI renders unchanged"
    - "ACP plan task_notifications with type acp_plan render as a structured task list with status indicators"
    - "Plan entries show status (pending/in_progress/completed) and priority (high/medium/low) visually"
  artifacts:
    - path: "src/components/chat/permission-prompt.tsx"
      provides: "AcpPermissionPrompt component rendering multi-option buttons from acpOptions"
    - path: "src/components/chat/acp-plan-view.tsx"
      provides: "AcpPlanView component rendering structured task list from ACP plan entries"
      exports: ["AcpPlanView"]
    - path: "src/components/chat/reducer/slices/requests.ts"
      provides: "Updated request reducer preserving acpOptions on permission requests"
    - path: "src/components/chat/use-chat-actions.ts"
      provides: "Updated handleApprovePermission to send optionId for ACP permissions"
  key_links:
    - from: "src/components/chat/permission-prompt.tsx"
      to: "src/components/chat/use-chat-actions.ts"
      via: "onApprove callback with optionId parameter for ACP"
      pattern: "optionId"
    - from: "src/components/chat/use-chat-actions.ts"
      to: "src/shared/websocket/chat-message.schema.ts"
      via: "sends permission_response with optionId field"
      pattern: "permission_response.*optionId"
    - from: "src/components/chat/acp-plan-view.tsx"
      to: "src/components/chat/reducer/types.ts"
      via: "reads acpPlan state from ChatState"
      pattern: "acpPlan"
---

<objective>
Build the frontend components for ACP multi-option permissions and structured plan view, completing the end-to-end UI for Phase 20.

Purpose: This plan delivers the user-visible features: permission requests with 4 distinct option buttons (allow once, allow always, deny once, deny always) and a structured task list for ACP plan updates. After this plan, all Phase 20 success criteria are met.

Output: Updated permission prompt with ACP options, new ACP plan view component, updated reducer and actions.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-event-translation-permissions/20-RESEARCH.md
@.planning/phases/20-event-translation-permissions/20-01-SUMMARY.md
@.planning/phases/20-event-translation-permissions/20-02-SUMMARY.md
@src/components/chat/permission-prompt.tsx
@src/components/chat/reducer/types.ts
@src/components/chat/reducer/slices/requests.ts
@src/components/chat/reducer/index.ts
@src/components/chat/use-chat-actions.ts
@src/shared/claude/protocol/interaction.ts
@src/shared/claude/protocol/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ACP multi-option permission UI and optionId response flow</name>
  <files>
    src/components/chat/permission-prompt.tsx
    src/components/chat/use-chat-actions.ts
    src/components/chat/reducer/slices/requests.ts
    src/components/chat/reducer/types.ts
    src/components/chat/reducer/index.ts
  </files>
  <action>
**1. Update `onApprove` callback signature to support optionId:**

In `permission-prompt.tsx`, the current `PermissionPromptProps` has:
```typescript
onApprove: (requestId: string, allow: boolean) => void;
```

Change to:
```typescript
onApprove: (requestId: string, allow: boolean, optionId?: string) => void;
```

This is backward-compatible -- existing callers (PlanApprovalPrompt, PermissionPromptExpanded) pass only 2 args.

**2. Add AcpPermissionPrompt component in `permission-prompt.tsx`:**

Create a new component `AcpPermissionPrompt` that renders when `permission.acpOptions` is present. Place it in the same file, above the main `PermissionPrompt` export.

```tsx
function AcpPermissionPrompt({ permission, onApprove }: PermissionPromptProps) {
  const firstButtonRef = useRef<HTMLButtonElement>(null);
  const permissionRequestId = permission?.requestId;

  useEffect(() => {
    if (!permissionRequestId) return;
    const timeoutId = setTimeout(() => firstButtonRef.current?.focus(), 100);
    return () => clearTimeout(timeoutId);
  }, [permissionRequestId]);

  if (!permission || !permission.acpOptions) return null;

  const { requestId, toolName, toolInput, acpOptions } = permission;
  const inputPreview = getInputPreview(toolInput);

  // Group options: allow options first, then reject options
  const allowOptions = acpOptions.filter(o => o.kind.startsWith('allow'));
  const rejectOptions = acpOptions.filter(o => o.kind.startsWith('reject'));

  const handleOptionClick = (optionId: string, kind: string) => {
    const isAllow = kind.startsWith('allow');
    onApprove(requestId, isAllow, optionId);
  };

  // Icon and color based on option kind
  const getOptionStyle = (kind: string) => {
    switch (kind) {
      case 'allow_once': return { variant: 'outline' as const, icon: ShieldCheck };
      case 'allow_always': return { variant: 'default' as const, icon: ShieldCheck };
      case 'reject_once': return { variant: 'outline' as const, icon: ShieldX };
      case 'reject_always': return { variant: 'destructive' as const, icon: ShieldX };
      default: return { variant: 'outline' as const, icon: ShieldCheck };
    }
  };

  return (
    <PromptCard
      icon={<Terminal className="h-5 w-5 text-muted-foreground" aria-hidden="true" />}
      label={`Permission request for ${toolName}`}
      actions={
        <div className="flex flex-wrap gap-2">
          {[...allowOptions, ...rejectOptions].map((option, index) => {
            const style = getOptionStyle(option.kind);
            const Icon = style.icon;
            return (
              <Button
                key={option.optionId}
                ref={index === 0 ? firstButtonRef : undefined}
                variant={style.variant}
                size="sm"
                onClick={() => handleOptionClick(option.optionId, option.kind)}
                className="gap-1.5"
              >
                <Icon className="h-3.5 w-3.5" aria-hidden="true" />
                {option.name}
              </Button>
            );
          })}
        </div>
      }
    >
      <div className="text-sm font-medium">Permission: {toolName}</div>
      <div className="text-xs text-muted-foreground mt-1 font-mono truncate" title={inputPreview}>
        {inputPreview}
      </div>
    </PromptCard>
  );
}
```

**3. Route to AcpPermissionPrompt in main PermissionPrompt:**

Update the main `PermissionPrompt` export function to check for `acpOptions`:

```tsx
export function PermissionPrompt({ permission, onApprove }: PermissionPromptProps) {
  // ... existing ref and effect code ...

  if (!permission) return null;

  // ACP multi-option permissions
  if (permission.acpOptions && permission.acpOptions.length > 0) {
    return <AcpPermissionPrompt permission={permission} onApprove={onApprove} />;
  }

  // ExitPlanMode specialized view
  if (permission.toolName === 'ExitPlanMode') {
    return <PlanApprovalPrompt permission={permission} onApprove={onApprove} />;
  }

  // ... rest of existing binary Allow/Deny rendering ...
}
```

**4. Update `use-chat-actions.ts` to send optionId:**

Find the `handleApprovePermission` callback (or similarly named). It currently builds:
```typescript
const msg: PermissionResponseMessage = { type: 'permission_response', requestId, allow };
```

Update the callback signature and message building:
```typescript
const handleApprovePermission = useCallback(
  (requestId: string, allow: boolean, optionId?: string) => {
    // ... existing validation ...
    const msg: PermissionResponseMessage = {
      type: 'permission_response',
      requestId,
      allow,
      ...(optionId && { optionId }),
    };
    send(msg);
    dispatch({ type: 'PERMISSION_RESPONSE', payload: { allow } });
  },
  [/* existing deps */]
);
```

**5. Update `reducer/types.ts` to pass optionId through PERMISSION_RESPONSE if needed:**

The `PERMISSION_RESPONSE` action payload currently only has `{ allow: boolean }`. This is fine as-is since `optionId` is only needed for the WebSocket send (handled in use-chat-actions), not for reducer state. No change needed to the action type.

**6. Verify the `reduceRequestSlice` in `reducer/slices/requests.ts`:**

The existing `WS_PERMISSION_REQUEST` case sets `pendingRequest: { type: 'permission', request: action.payload }`. Since `PermissionRequest` (from `@/lib/chat-protocol`) now includes `acpOptions` (from the shared type changes in Plan 02), the `acpOptions` will automatically flow through to state. No reducer changes needed -- the type system carries it.

Verify that the `handlePermissionRequestMessage` in `reducer/index.ts` passes through `acpOptions`. Currently it extracts fields manually:
```typescript
function handlePermissionRequestMessage(data: WebSocketMessage): ChatAction | null {
  if (data.requestId && data.toolName) {
    return {
      type: 'WS_PERMISSION_REQUEST',
      payload: {
        requestId: data.requestId,
        toolName: data.toolName,
        toolInput: data.toolInput ?? {},
        timestamp: new Date().toISOString(),
        planContent: data.planContent ?? null,
      },
    };
  }
  return null;
}
```

Add `acpOptions`:
```typescript
acpOptions: data.acpOptions ?? undefined,
```

This ensures the ACP option data reaches the permission prompt component.
  </action>
  <verify>
Run `pnpm typecheck` -- no type errors.
Run `pnpm check:fix` -- lint clean.
Visually: The binary Allow/Deny UI still works for Claude/Codex sessions (no acpOptions). The ACP multi-option UI renders when acpOptions is present.
  </verify>
  <done>
ACP permission requests render 4 option buttons (allow once, allow always, deny once, deny always). Clicking an option sends the optionId back via WebSocket. Legacy binary Allow/Deny UI unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: ACP plan view component and plan state management</name>
  <files>
    src/components/chat/acp-plan-view.tsx
    src/components/chat/reducer/types.ts
    src/components/chat/reducer/index.ts
    src/components/chat/agent-live-dock.tsx
  </files>
  <action>
**1. Add ACP plan state to ChatState in `reducer/types.ts`:**

Add a new field to `ChatState`:
```typescript
/** ACP agent plan -- latest plan state from ACP plan session updates */
acpPlan: AcpPlanState | null;
```

Define the plan state type (in the same file, above ChatState):
```typescript
/** Individual entry in an ACP plan */
export interface AcpPlanEntry {
  content: string;
  status: 'pending' | 'in_progress' | 'completed';
  priority: 'high' | 'medium' | 'low';
}

/** ACP plan state -- latest full plan from agent */
export interface AcpPlanState {
  entries: AcpPlanEntry[];
  updatedAt: string;
}
```

Add a new action type:
```typescript
| { type: 'ACP_PLAN_UPDATE'; payload: { entries: AcpPlanEntry[] } }
```

Add `acpPlan: null` to the initial state in the reducer.

**2. Handle ACP plan updates in `reducer/index.ts`:**

The ACP plan comes as a `task_notification` with a JSON message containing `{ type: 'acp_plan', entries: [...] }`. Update `handleTaskNotificationMessage` to detect and dispatch ACP plan updates:

```typescript
function handleTaskNotificationMessage(data: WebSocketMessage): ChatAction | null {
  if (data.message) {
    // Check if this is an ACP plan update
    try {
      const parsed = JSON.parse(data.message);
      if (parsed && parsed.type === 'acp_plan' && Array.isArray(parsed.entries)) {
        return {
          type: 'ACP_PLAN_UPDATE',
          payload: { entries: parsed.entries },
        };
      }
    } catch {
      // Not JSON, treat as regular task notification
    }

    return {
      type: 'SDK_TASK_NOTIFICATION',
      payload: { message: data.message },
    };
  }
  return null;
}
```

Add `ACP_PLAN_UPDATE` handling in the main reducer:
```typescript
case 'ACP_PLAN_UPDATE':
  return {
    ...state,
    acpPlan: {
      entries: action.payload.entries,
      updatedAt: new Date().toISOString(),
    },
  };
```

Also clear `acpPlan` on `CLEAR_CHAT` and `RESET_FOR_SESSION_SWITCH`.

**3. Create `AcpPlanView` component in `src/components/chat/acp-plan-view.tsx`:**

A collapsible task list component that renders ACP plan entries with status indicators. Simple, inline in the chat area (similar to how thinking is shown in AgentLiveDock).

```tsx
import { CheckCircle2, Circle, Loader2 } from 'lucide-react';
import { useState } from 'react';
import { cn } from '@/lib/utils';
import type { AcpPlanEntry } from './reducer/types';

interface AcpPlanViewProps {
  entries: AcpPlanEntry[];
  className?: string;
}

function StatusIcon({ status }: { status: AcpPlanEntry['status'] }) {
  switch (status) {
    case 'completed':
      return <CheckCircle2 className="h-4 w-4 text-green-500 shrink-0" />;
    case 'in_progress':
      return <Loader2 className="h-4 w-4 text-blue-500 animate-spin shrink-0" />;
    case 'pending':
    default:
      return <Circle className="h-4 w-4 text-muted-foreground shrink-0" />;
  }
}

function PriorityBadge({ priority }: { priority: AcpPlanEntry['priority'] }) {
  const colors = {
    high: 'bg-red-500/10 text-red-600',
    medium: 'bg-yellow-500/10 text-yellow-600',
    low: 'bg-muted text-muted-foreground',
  };
  return (
    <span className={cn('text-[10px] px-1.5 py-0.5 rounded-sm font-medium', colors[priority])}>
      {priority}
    </span>
  );
}

export function AcpPlanView({ entries, className }: AcpPlanViewProps) {
  const [collapsed, setCollapsed] = useState(false);
  const completedCount = entries.filter(e => e.status === 'completed').length;
  const totalCount = entries.length;

  return (
    <div className={cn('border rounded-md bg-muted/30', className)}>
      <button
        type="button"
        onClick={() => setCollapsed(!collapsed)}
        className="flex items-center justify-between w-full px-3 py-2 text-sm font-medium hover:bg-muted/50 transition-colors"
      >
        <span>Plan ({completedCount}/{totalCount} completed)</span>
        <span className="text-xs text-muted-foreground">{collapsed ? 'Show' : 'Hide'}</span>
      </button>
      {!collapsed && (
        <div className="px-3 pb-3 space-y-1.5">
          {entries.map((entry, index) => (
            <div key={`${entry.content}-${index}`} className="flex items-start gap-2">
              <StatusIcon status={entry.status} />
              <div className="flex-1 min-w-0">
                <span className={cn(
                  'text-sm',
                  entry.status === 'completed' && 'text-muted-foreground line-through'
                )}>
                  {entry.content}
                </span>
              </div>
              <PriorityBadge priority={entry.priority} />
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

**4. Wire AcpPlanView into AgentLiveDock (or the chat panel):**

In `src/components/chat/agent-live-dock.tsx`, add an `acpPlan` prop and render `AcpPlanView` when plan state exists. Place it below the thinking section and above the tool details.

Add to `AgentLiveDockProps`:
```typescript
acpPlan: AcpPlanState | null;
```

Import `AcpPlanView`:
```typescript
import { AcpPlanView } from './acp-plan-view';
```

Import `AcpPlanState`:
```typescript
import type { AcpPlanState } from './reducer/types';
```

Render in the dock (after thinking, before tool details):
```tsx
{acpPlan && acpPlan.entries.length > 0 && (
  <div className="space-y-1">
    <div className="text-[10px] font-medium text-muted-foreground">Agent plan</div>
    <AcpPlanView entries={acpPlan.entries} />
  </div>
)}
```

Find where AgentLiveDock is used and pass `acpPlan={state.acpPlan}` from the chat state. This is likely in `chat-panel.tsx` or similar parent component that has access to the reducer state. Search for `<AgentLiveDock` usage and add the prop.
  </action>
  <verify>
Run `pnpm typecheck` -- no type errors.
Run `pnpm check:fix` -- lint clean.
  </verify>
  <done>
ACP plan updates render as a structured collapsible task list with status icons (pending/in_progress/completed) and priority badges (high/medium/low) in the agent live dock. Plan state resets on session switch.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Phase 20 frontend features end-to-end</name>
  <files></files>
  <action>
Human verification of all Phase 20 frontend features built in Tasks 1-2 and backend wiring from Plans 01-02.

Complete Phase 20 frontend includes:
1. ACP multi-option permission UI (4 buttons: allow once, allow always, deny once, deny always)
2. ACP plan view component (structured task list with status/priority indicators)
3. Slash commands forwarding (via available_commands_update to slash_commands delta)
4. Thinking content forwarding (via agent_thought_chunk to thinking content_block)
5. Full tool call lifecycle (pending/in_progress/completed/failed with kind and locations)

Verification steps:
1. Start the dev server: `pnpm dev`
2. Create a test ACP session with `useAcp: true` and `permissionMode: 'plan'` (not bypassPermissions)
3. Send a prompt that triggers tool usage (e.g., "Read the README.md file")
4. **Permission UI**: Verify that when the agent requests permission, you see 4 distinct option buttons (not binary Allow/Deny). Click one -- the agent should proceed.
5. **Tool calls**: Verify tool calls appear in the chat UI with status lifecycle indicators
6. **Thinking**: If the agent uses extended thinking, verify thoughts appear in a collapsible section in the live dock
7. **Plans**: If the agent creates a plan, verify it renders as a structured task list with checkmarks and status indicators
8. **Slash commands**: Type `/` in the chat input and verify commands appear in the palette
9. **Legacy sessions**: Start a regular Claude session (not ACP) and verify the existing binary Allow/Deny permission UI still works correctly
  </action>
  <verify>Type "approved" or describe issues</verify>
  <done>All Phase 20 features verified working end-to-end: ACP permission options, plan view, thinking, tool lifecycle, slash commands, and legacy session compatibility.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` -- no type errors
2. `pnpm check:fix` -- lint clean
3. `pnpm test` -- all tests pass
4. ACP permission UI renders 4 options when acpOptions present
5. Legacy permission UI renders binary Allow/Deny when acpOptions absent
6. ACP plan view renders structured task list from plan events
7. Slash commands appear in palette from available_commands_update
</verification>

<success_criteria>
- Phase 20 Success Criteria 1: Tool calls from agent appear with status lifecycle, title, kind, content -- verified visually
- Phase 20 Success Criteria 2: Agent thinking renders in collapsible sections -- verified visually
- Phase 20 Success Criteria 3: Plan updates render as structured task view with per-task status -- verified visually
- Phase 20 Success Criteria 4: Permission requests present 4 option buttons, selected option flows back as optionId -- verified visually and functionally
- Phase 20 Success Criteria 5: Slash commands appear in command palette -- verified visually
- All existing Claude/Codex session functionality unchanged (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/20-event-translation-permissions/20-03-SUMMARY.md`
</output>

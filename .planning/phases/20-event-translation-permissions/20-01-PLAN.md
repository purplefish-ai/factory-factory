---
phase: 20-event-translation-permissions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backend/domains/session/acp/acp-event-translator.ts
  - src/backend/domains/session/acp/acp-event-translator.test.ts
  - src/backend/domains/session/acp/acp-permission-bridge.ts
  - src/backend/domains/session/acp/acp-permission-bridge.test.ts
autonomous: true

must_haves:
  truths:
    - "ACP SessionUpdate variants translate to correct FF SessionDeltaEvent types"
    - "agent_thought_chunk produces thinking content_block separate from message content"
    - "tool_call and tool_call_update produce content_block_start and tool_progress with status/kind/locations"
    - "plan updates produce a structured plan event with entries, status, and priority"
    - "available_commands_update produces slash_commands event with CommandInfo array"
    - "Permission bridge suspends on waitForUserResponse and resolves when resolvePermission is called"
    - "Permission bridge cancelAll resolves all pending with cancelled outcome"
    - "Malformed or missing ACP data fields do not throw -- translator returns empty array and logs warning"
  artifacts:
    - path: "src/backend/domains/session/acp/acp-event-translator.ts"
      provides: "Stateless AcpEventTranslator class mapping SessionUpdate -> SessionDeltaEvent[]"
      exports: ["AcpEventTranslator"]
    - path: "src/backend/domains/session/acp/acp-event-translator.test.ts"
      provides: "Unit tests for all SessionUpdate variant translations"
      min_lines: 100
    - path: "src/backend/domains/session/acp/acp-permission-bridge.ts"
      provides: "Promise-based AcpPermissionBridge for suspending requestPermission until user responds"
      exports: ["AcpPermissionBridge"]
    - path: "src/backend/domains/session/acp/acp-permission-bridge.test.ts"
      provides: "Unit tests for permission bridge lifecycle"
      min_lines: 50
  key_links:
    - from: "src/backend/domains/session/acp/acp-event-translator.ts"
      to: "@agentclientprotocol/sdk"
      via: "import SessionUpdate, ToolCall, Plan, ContentChunk types"
      pattern: "import.*from '@agentclientprotocol/sdk'"
    - from: "src/backend/domains/session/acp/acp-event-translator.ts"
      to: "src/shared/claude/protocol/websocket.ts"
      via: "returns SessionDeltaEvent[]"
      pattern: "SessionDeltaEvent"
    - from: "src/backend/domains/session/acp/acp-permission-bridge.ts"
      to: "@agentclientprotocol/sdk"
      via: "import RequestPermissionRequest, RequestPermissionResponse types"
      pattern: "import.*from '@agentclientprotocol/sdk'"
---

<objective>
Build the AcpEventTranslator and AcpPermissionBridge as isolated, testable backend classes that translate ACP SDK events into FF delta events and manage async permission flows.

Purpose: These two classes are the core translation layer for Phase 20. The translator maps all ACP SessionUpdate variants (tool_call, agent_thought_chunk, plan, available_commands_update, etc.) to existing FF SessionDeltaEvent types. The permission bridge replaces auto-approve with a Promise-based suspension that waits for user response.

Output: Two new files with unit tests, ready to be wired into session.service.ts and AcpClientHandler in Plan 02.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-event-translation-permissions/20-RESEARCH.md
@.planning/phases/19-acp-runtime-foundation/19-01-SUMMARY.md
@.planning/phases/19-acp-runtime-foundation/19-02-SUMMARY.md
@src/backend/domains/session/codex/codex-event-translator.ts
@src/shared/claude/protocol/websocket.ts
@src/shared/claude/protocol/models.ts
@src/shared/claude/protocol/interaction.ts
@src/backend/domains/session/acp/acp-client-handler.ts
@src/backend/domains/session/acp/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build AcpEventTranslator with full SessionUpdate variant mapping</name>
  <files>
    src/backend/domains/session/acp/acp-event-translator.ts
    src/backend/domains/session/acp/acp-event-translator.test.ts
  </files>
  <action>
Create `AcpEventTranslator` class in `src/backend/domains/session/acp/acp-event-translator.ts` modeled on the existing `CodexEventTranslator` pattern. The class is stateless and has one public method:

```typescript
translateSessionUpdate(update: SessionUpdate): SessionDeltaEvent[]
```

Use a switch on `update.sessionUpdate` discriminant (the ACP SDK provides a discriminated union). Map each variant:

**Error handling (apply to ALL variants):** Use optional chaining and nullish coalescing throughout. If a required field is missing or malformed (e.g., `update.content` is undefined, `update.toolCallId` is missing), log a warning via `this.logger.warn(...)` with the variant type and available data, then return an empty array. Never throw from `translateSessionUpdate`. For array fields (`update.entries`, `update.availableCommands`, `update.locations`), default to empty array `?? []` if nullish. This defensive approach ensures one malformed event does not break the translation pipeline for subsequent events.

**agent_message_chunk**: Check `update.content?.type === 'text'` and extract `update.content.text`. If `update.content` is undefined or not text type, log warning and return `[]`. Emit as `agent_message` with `data: { type: 'assistant', message: { role: 'assistant', content: [{ type: 'text', text }] } }`. For non-text content types (image, audio, resource_link, resource), log a warning and skip (per research: "Handle text robustly. Log other types."). Do NOT pass the raw ContentBlock as ClaudeContentItem -- extract the text string explicitly to avoid `[object Object]` in chat (Pitfall 5 from research).

**agent_thought_chunk**: Check `update.content?.type === 'text'` and extract text. If content is missing or non-text, log warning and return `[]`. Emit as `agent_message` with `data: { type: 'stream_event', event: { type: 'content_block_start', index: 0, content_block: { type: 'thinking', thinking: text } } }`. This maps to the existing thinking content block rendering path that the frontend already handles via `latestThinking` state.

**tool_call**: Guard with `if (!update.toolCallId || !update.title)` -- log warning and return `[]` if missing. Emit as `agent_message` with `data: { type: 'stream_event', event: { type: 'content_block_start', index: 0, content_block: { type: 'tool_use', id: update.toolCallId, name: update.title, input: update.rawInput ?? {} } } }`. Also include status, kind, and locations data. For locations, emit a separate `tool_progress` event with `tool_use_id: update.toolCallId, tool_name: update.title` and add `acpLocations` and `acpKind` and `acpStatus` fields to carry the extra ACP data. Use `update.locations ?? []` for the locations array. (The tool_progress type uses WebSocketMessageCommon which allows extra fields.)

**tool_call_update**: Guard with `if (!update.toolCallId)` -- log warning and return `[]`. Emit `tool_progress` with `tool_use_id: update.toolCallId, tool_name: update.title ?? undefined`. Include `acpStatus: update.status ?? undefined`, `acpKind: update.kind ?? undefined`, `acpLocations: update.locations ?? []`, and `acpContent: update.content ?? undefined` as additional fields. When `update.status === 'completed'` or `update.status === 'failed'`, also include `elapsed_time_seconds: 0` to signal completion to existing tool progress tracking.

**plan**: Emit as `task_notification` with `message` set to a structured JSON string: `JSON.stringify({ type: 'acp_plan', entries: update.entries ?? [] })` where entries is the array of `{ content, status, priority }` PlanEntry objects. Use `update.entries ?? []` to handle missing entries. The `task_notification` type already exists in the WebSocket protocol. The frontend Plan 03 will parse this JSON to render structured plan view.

**available_commands_update**: Emit as `slash_commands` with `slashCommands: (update.availableCommands ?? []).map(cmd => ({ name: cmd.name, description: cmd.description, argumentHint: cmd.input?.hint }))`. This maps ACP AvailableCommand directly to FF CommandInfo. Use optional chaining on `cmd.input?.hint`.

**usage_update**: Emit as `agent_message` with `data: { type: 'result', result: { usage: update } }` to feed token stats.

**config_option_update, current_mode_update, session_info_update, user_message_chunk**: Return empty array (log-only, deferred to Phase 21). These are not Phase 20 requirements.

**default**: Return empty array with a logged warning for unknown types.

Import `SessionUpdate` type from `@agentclientprotocol/sdk`. Import `SessionDeltaEvent` from `@/shared/claude`. Import `CommandInfo` from `@/shared/claude/protocol/models`.

For the test file, write unit tests covering:
- agent_message_chunk with text content -> correct agent_message delta
- agent_message_chunk with non-text content -> empty array (logged)
- agent_message_chunk with undefined content -> empty array (logged, no throw)
- agent_thought_chunk with text -> thinking content_block
- agent_thought_chunk with missing content -> empty array (no throw)
- tool_call -> content_block_start + tool_progress
- tool_call with missing toolCallId -> empty array (no throw)
- tool_call_update with status transitions -> tool_progress events
- tool_call_update with null fields -> tool_progress with defaults (no throw)
- plan with entries -> task_notification with structured JSON
- plan with undefined entries -> task_notification with empty entries array
- available_commands_update -> slash_commands
- available_commands_update with empty commands -> slash_commands with empty array
- usage_update -> result event
- deferred types -> empty array
- unknown type -> empty array

Use Vitest. Mock the logger if needed. Test that return values match expected SessionDeltaEvent shapes.
  </action>
  <verify>
Run `pnpm test src/backend/domains/session/acp/acp-event-translator.test.ts` -- all tests pass.
Run `pnpm typecheck` -- no type errors.
  </verify>
  <done>
AcpEventTranslator correctly translates all 11 SessionUpdate variants to appropriate SessionDeltaEvent arrays. Malformed data is handled defensively with warnings and empty returns. All unit tests pass. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build AcpPermissionBridge with Promise-based suspension</name>
  <files>
    src/backend/domains/session/acp/acp-permission-bridge.ts
    src/backend/domains/session/acp/acp-permission-bridge.test.ts
  </files>
  <action>
Create `AcpPermissionBridge` class in `src/backend/domains/session/acp/acp-permission-bridge.ts`. This class manages a Map of pending permission Promises keyed by requestId (string).

Public API:

```typescript
import type { RequestPermissionRequest, RequestPermissionResponse } from '@agentclientprotocol/sdk';

export class AcpPermissionBridge {
  private pending: Map<string, {
    resolve: (response: RequestPermissionResponse) => void;
    params: RequestPermissionRequest;
  }>;

  /**
   * Called by AcpClientHandler.requestPermission().
   * Creates a Promise that suspends until the user responds.
   * Returns the requestId for tracking.
   */
  waitForUserResponse(requestId: string, params: RequestPermissionRequest): Promise<RequestPermissionResponse>;

  /**
   * Called by permission-response.handler.ts when user selects an option.
   * Resolves the suspended Promise with the selected optionId.
   * Returns false if no pending request found for this requestId.
   */
  resolvePermission(requestId: string, optionId: string): boolean;

  /**
   * Called when session is cancelled/stopped.
   * Resolves all pending Promises with cancelled outcome.
   */
  cancelAll(): void;

  /**
   * Check if there is a pending permission request.
   */
  hasPending(requestId: string): boolean;

  /**
   * Get the params for a pending request (for re-emit on session restore).
   */
  getPendingParams(requestId: string): RequestPermissionRequest | undefined;

  /**
   * Get count of pending requests (for diagnostics).
   */
  get pendingCount(): number;
}
```

Implementation details:
- `waitForUserResponse`: Creates a new Promise, stores `{ resolve, params }` in the Map, returns the Promise. The Promise will resolve when `resolvePermission` or `cancelAll` is called.
- `resolvePermission`: Looks up the requestId in the Map, calls `resolve({ outcome: { outcome: 'selected', optionId } })`, deletes the entry, returns true. If not found, returns false.
- `cancelAll`: Iterates all entries, calls `resolve({ outcome: { outcome: 'cancelled' } })` on each, then clears the Map.
- `hasPending`: Returns `this.pending.has(requestId)`.
- `getPendingParams`: Returns `this.pending.get(requestId)?.params`.

For the test file, write unit tests covering:
- waitForUserResponse creates a pending entry
- resolvePermission resolves the Promise with correct optionId
- resolvePermission returns false for unknown requestId
- cancelAll resolves all pending with cancelled outcome
- cancelAll clears the pending map
- Multiple concurrent permissions (different requestIds)
- hasPending returns correct boolean
- pendingCount tracks entries correctly

Use Vitest. Tests should use async/await to verify Promise resolution behavior.
  </action>
  <verify>
Run `pnpm test src/backend/domains/session/acp/acp-permission-bridge.test.ts` -- all tests pass.
Run `pnpm typecheck` -- no type errors.
  </verify>
  <done>
AcpPermissionBridge correctly manages Promise-based permission suspension with waitForUserResponse, resolvePermission, and cancelAll. All unit tests pass. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test src/backend/domains/session/acp/` -- all tests pass (existing + new)
2. `pnpm typecheck` -- no type errors
3. `pnpm check:fix` -- lint clean
4. Both new files exist and export their classes
</verification>

<success_criteria>
- AcpEventTranslator handles all 11 SessionUpdate variants with correct delta event mapping
- AcpEventTranslator handles malformed/missing data defensively (no throws, log warnings, return empty arrays)
- AcpPermissionBridge manages async permission lifecycle (wait, resolve, cancel)
- All unit tests pass
- TypeScript compiles without errors
- Lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/20-event-translation-permissions/20-01-SUMMARY.md`
</output>

---
phase: 20-event-translation-permissions
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/backend/domains/session/acp/acp-client-handler.ts
  - src/backend/domains/session/acp/index.ts
  - src/backend/domains/session/acp/acp-runtime-manager.ts
  - src/backend/domains/session/lifecycle/session.service.ts
  - src/shared/claude/protocol/websocket.ts
  - src/shared/claude/protocol/interaction.ts
  - src/shared/websocket/chat-message.schema.ts
  - src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts
autonomous: true

must_haves:
  truths:
    - "ACP session updates flow through AcpEventTranslator to emitDelta instead of inline switch"
    - "AcpClientHandler.requestPermission suspends via AcpPermissionBridge instead of auto-approving"
    - "Permission requests from ACP sessions include acpOptions array in the WebSocket payload"
    - "Permission responses from ACP sessions carry optionId back to resolve the bridge Promise"
    - "Session stop/cancel calls bridge.cancelAll() to resolve pending permissions with cancelled outcome"
    - "WebSocket permission_response schema accepts optional optionId field"
    - "Session file logging in AcpClientHandler.sessionUpdate is preserved for ALL events before forwarding"
  artifacts:
    - path: "src/backend/domains/session/acp/acp-client-handler.ts"
      provides: "Updated AcpClientHandler using AcpPermissionBridge for requestPermission"
      exports: ["AcpClientHandler", "AcpEventCallback"]
    - path: "src/backend/domains/session/lifecycle/session.service.ts"
      provides: "setupAcpEventHandler using AcpEventTranslator, ACP permission routing in respondToPermissionRequest"
    - path: "src/shared/claude/protocol/websocket.ts"
      provides: "permission_request type extended with acpOptions field"
    - path: "src/shared/websocket/chat-message.schema.ts"
      provides: "permission_response schema with optional optionId field"
    - path: "src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts"
      provides: "ACP permission routing via bridge.resolvePermission when optionId present"
  key_links:
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/acp/acp-event-translator.ts"
      via: "import and use in setupAcpEventHandler"
      pattern: "AcpEventTranslator"
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/acp/acp-permission-bridge.ts"
      via: "per-session bridge instance for permission management"
      pattern: "AcpPermissionBridge"
    - from: "src/backend/domains/session/acp/acp-client-handler.ts"
      to: "src/backend/domains/session/acp/acp-permission-bridge.ts"
      via: "constructor injection, requestPermission delegates to bridge"
      pattern: "this\\.permissionBridge\\.waitForUserResponse"
    - from: "src/backend/domains/session/acp/acp-runtime-manager.ts"
      to: "src/backend/domains/session/acp/acp-permission-bridge.ts"
      via: "AcpRuntimeEventHandlers.permissionBridge passed through to AcpClientHandler constructor"
      pattern: "permissionBridge"
    - from: "src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts"
      to: "src/backend/domains/session/lifecycle/session.service.ts"
      via: "calls respondToPermissionRequest with optionId for ACP"
      pattern: "optionId"
---

<objective>
Wire the AcpEventTranslator and AcpPermissionBridge from Plan 01 into the session service, update AcpClientHandler to use the bridge, extend WebSocket types for ACP permission options, and update the permission response handler for ACP optionId routing.

Purpose: This plan connects the isolated translator and bridge classes to the live event pipeline. After this plan, ACP sessions will emit rich delta events (thinking, plans, slash commands, full tool lifecycle) and permission requests will suspend until the user responds via WebSocket.

Output: End-to-end backend flow where ACP events translate to delta events and permission requests round-trip through the WebSocket protocol with optionId.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-event-translation-permissions/20-RESEARCH.md
@.planning/phases/20-event-translation-permissions/20-01-SUMMARY.md
@src/backend/domains/session/lifecycle/session.service.ts
@src/backend/domains/session/acp/acp-client-handler.ts
@src/backend/domains/session/acp/acp-runtime-manager.ts
@src/backend/domains/session/acp/index.ts
@src/shared/claude/protocol/websocket.ts
@src/shared/claude/protocol/interaction.ts
@src/shared/websocket/chat-message.schema.ts
@src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts
@src/components/chat/reducer/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend shared types for ACP permission options and plan events</name>
  <files>
    src/shared/claude/protocol/websocket.ts
    src/shared/claude/protocol/interaction.ts
    src/shared/websocket/chat-message.schema.ts
  </files>
  <action>
**1. Extend `permission_request` payload in `src/shared/claude/protocol/websocket.ts`:**

In the `WebSocketMessagePayloadByType` interface, update the `permission_request` entry to add an optional `acpOptions` field:

```typescript
permission_request: {
  requestId?: string;
  toolName?: string;
  toolUseId?: string;
  toolInput?: Record<string, unknown>;
  planContent?: string | null;
  /** ACP permission options -- when present, frontend renders multi-option buttons instead of binary Allow/Deny */
  acpOptions?: Array<{
    optionId: string;
    name: string;
    kind: 'allow_once' | 'allow_always' | 'reject_once' | 'reject_always';
  }>;
};
```

This is additive -- existing Claude/Codex permission flows that omit `acpOptions` continue to work unchanged.

**2. Extend `PermissionRequest` in `src/shared/claude/protocol/interaction.ts`:**

Add the same `acpOptions` field to the `PermissionRequest` interface:

```typescript
export interface PermissionRequest {
  requestId: string;
  toolName: string;
  toolInput: Record<string, unknown>;
  timestamp: string;
  planContent?: string | null;
  /** ACP permission options for multi-option UI. When present, frontend renders option buttons. */
  acpOptions?: Array<{
    optionId: string;
    name: string;
    kind: 'allow_once' | 'allow_always' | 'reject_once' | 'reject_always';
  }>;
}
```

**3. Extend `permission_response` schema in `src/shared/websocket/chat-message.schema.ts`:**

Update the `permission_response` variant in `ChatMessageSchema` to accept an optional `optionId`:

```typescript
z.object({
  type: z.literal('permission_response'),
  requestId: z.string().min(1),
  allow: z.boolean(),
  /** ACP permission option ID -- when present, takes precedence over boolean allow */
  optionId: z.string().optional(),
}),
```

Also update the `PermissionResponseMessage` type extraction at the bottom of the file -- it should automatically pick up the new field from the schema inference.

Verify that these are purely additive changes -- no existing field types change, no existing fields removed. The `acpOptions` and `optionId` fields are optional, so all existing code continues to work.
  </action>
  <verify>
Run `pnpm typecheck` -- no type errors. All existing code that uses PermissionRequest, permission_request, and permission_response still compiles.
  </verify>
  <done>
WebSocket protocol types extended with acpOptions on permission_request and optionId on permission_response. All changes are additive and backward-compatible.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire translator and bridge into session service, runtime manager, and permission handler</name>
  <files>
    src/backend/domains/session/acp/acp-client-handler.ts
    src/backend/domains/session/acp/acp-runtime-manager.ts
    src/backend/domains/session/acp/index.ts
    src/backend/domains/session/lifecycle/session.service.ts
    src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts
  </files>
  <action>
**1. Update AcpClientHandler to accept and use AcpPermissionBridge (`acp-client-handler.ts`):**

- Add `AcpPermissionBridge` as a constructor parameter (injection pattern):
  ```typescript
  constructor(
    sessionId: string,
    onEvent: AcpEventCallback,
    logger: ReturnType<typeof createLogger>,
    permissionBridge?: AcpPermissionBridge  // Optional for backward compat with tests
  )
  ```
- Store as `private readonly permissionBridge: AcpPermissionBridge | null`.

- **CRITICAL: Preserve session file logging in `sessionUpdate()`.** The existing `sessionFileLogger.log()` call at the top of `sessionUpdate()` MUST remain as-is for EVENT-06 compliance. The update is to replace the inline switch BELOW the log call with a single forwarding call. The updated method:
  ```typescript
  async sessionUpdate(params: SessionNotification): Promise<void> {
    const update = params.update;

    // PRESERVE: Log ALL events to session file logger (EVENT-06)
    // This logging MUST happen FIRST, before any forwarding or translation.
    sessionFileLogger.log(this.sessionId, 'FROM_CLAUDE_CLI', {
      eventType: 'acp_session_update',
      sessionUpdate: update.sessionUpdate,
      data: update,
    });

    // Forward the raw update to session service for translation via AcpEventTranslator
    // This replaces the Phase 19 inline switch that only handled 3 event types
    this.onEvent(this.sessionId, { type: 'acp_session_update', update });
  }
  ```

- In `requestPermission()`: When bridge is available, generate a unique requestId (use `crypto.randomUUID()`), emit a permission request event via `this.onEvent`, then await the bridge:
  ```typescript
  async requestPermission(params: RequestPermissionRequest): Promise<RequestPermissionResponse> {
    // PRESERVE: Log permission request to session file logger
    sessionFileLogger.log(this.sessionId, 'FROM_CLAUDE_CLI', {
      eventType: 'acp_permission_request',
      toolCallId: params.toolCall.toolCallId,
      options: params.options.map((o) => ({ optionId: o.optionId, kind: o.kind, name: o.name })),
    });

    if (!this.permissionBridge) {
      // Fallback to auto-approve (Phase 19 behavior)
      const allowOption = params.options.find(o => o.kind === 'allow_always' || o.kind === 'allow_once');
      return { outcome: { outcome: 'selected', optionId: allowOption?.optionId ?? params.options[0]?.optionId ?? 'unknown' } };
    }

    const requestId = crypto.randomUUID();
    // Emit permission request event for WebSocket push
    this.onEvent(this.sessionId, {
      type: 'acp_permission_request',
      requestId,
      params,
    });
    // Suspend until user responds
    return this.permissionBridge.waitForUserResponse(requestId, params);
  }
  ```

**2. Update `AcpRuntimeEventHandlers` type and `AcpRuntimeManager.createClient` (`acp-runtime-manager.ts`):**

This is the critical bridge-passing mechanism. The `AcpPermissionBridge` is created in `session.service.ts` and must reach the `AcpClientHandler` constructor inside `AcpRuntimeManager.createClient`.

- Extend the `AcpRuntimeEventHandlers` type to include an optional `permissionBridge`:
  ```typescript
  export type AcpRuntimeEventHandlers = RuntimeEventHandlers & {
    onAcpEvent?: (sessionId: string, event: unknown) => void;
    /** Permission bridge to inject into AcpClientHandler for suspending requestPermission */
    permissionBridge?: AcpPermissionBridge;
  };
  ```
  Import `AcpPermissionBridge` from `./acp-permission-bridge`.

- Update the `ClientSideConnection` constructor call in `createClient` to pass the bridge:
  ```typescript
  const connection = new ClientSideConnection(
    (_agent) => new AcpClientHandler(sessionId, onEvent, logger, handlers.permissionBridge),
    stream
  );
  ```
  This passes the bridge from the handlers object (set by session.service.ts) through to the AcpClientHandler constructor.

**3. Update barrel exports (`acp/index.ts`):**

Add exports for AcpEventTranslator and AcpPermissionBridge:
```typescript
export { AcpEventTranslator } from './acp-event-translator';
export { AcpPermissionBridge } from './acp-permission-bridge';
```

**4. Rewrite `setupAcpEventHandler` in `session.service.ts`:**

- Import `AcpEventTranslator` and `AcpPermissionBridge` from the acp barrel.
- Create an `AcpEventTranslator` instance (stateless, can be shared or per-session).
- Create an `AcpPermissionBridge` instance per session (stores per-session pending promises).
- Store the bridge in a `Map<string, AcpPermissionBridge>` on the SessionService class so it can be accessed by the permission response handler.

Replace the existing `onAcpEvent` handler:

```typescript
private readonly acpEventTranslator = new AcpEventTranslator();
private readonly acpPermissionBridges = new Map<string, AcpPermissionBridge>();

private setupAcpEventHandler(sessionId: string): AcpRuntimeEventHandlers {
  const bridge = new AcpPermissionBridge();
  this.acpPermissionBridges.set(sessionId, bridge);

  return {
    permissionBridge: bridge,  // Passed through AcpRuntimeManager to AcpClientHandler constructor
    onAcpEvent: (sid: string, event: unknown) => {
      const typed = event as { type: string };

      if (typed.type === 'acp_session_update') {
        const { update } = event as { type: string; update: import('@agentclientprotocol/sdk').SessionUpdate };
        const deltas = this.acpEventTranslator.translateSessionUpdate(update);
        for (const delta of deltas) {
          sessionDomainService.emitDelta(sid, delta);
        }
        return;
      }

      if (typed.type === 'acp_permission_request') {
        const { requestId, params } = event as {
          type: string;
          requestId: string;
          params: import('@agentclientprotocol/sdk').RequestPermissionRequest;
        };
        // Emit permission_request delta with ACP options
        sessionDomainService.emitDelta(sid, {
          type: 'permission_request',
          requestId,
          toolName: params.toolCall.title ?? 'ACP Tool',
          toolUseId: params.toolCall.toolCallId,
          toolInput: (params.toolCall.rawInput as Record<string, unknown>) ?? {},
          acpOptions: params.options.map(o => ({
            optionId: o.optionId,
            name: o.name,
            kind: o.kind,
          })),
        });
        // Also store as pending interactive request for session restore
        sessionDomainService.setPendingInteractiveRequest(sid, {
          requestId,
          toolName: params.toolCall.title ?? 'ACP Tool',
          toolUseId: params.toolCall.toolCallId,
          input: (params.toolCall.rawInput as Record<string, unknown>) ?? {},
          planContent: null,
          timestamp: new Date().toISOString(),
        });
        return;
      }
    },
    onSessionId: async (sid, providerSessionId) => { /* keep existing */ },
    onExit: async (sid, exitCode) => {
      // Add bridge cleanup
      const b = this.acpPermissionBridges.get(sid);
      if (b) {
        b.cancelAll();
        this.acpPermissionBridges.delete(sid);
      }
      // ... keep existing exit logic ...
    },
    onError: (sid, error) => { /* keep existing */ },
  };
}
```

- Add a public method for ACP permission resolution:
  ```typescript
  respondToAcpPermission(sessionId: string, requestId: string, optionId: string): boolean {
    const bridge = this.acpPermissionBridges.get(sessionId);
    if (!bridge) return false;
    return bridge.resolvePermission(requestId, optionId);
  }
  ```

- In `stopSession` and any session cleanup paths, call `bridge.cancelAll()` before deleting the bridge entry.

**5. Update `permission-response.handler.ts` to route ACP permissions:**

The handler currently calls `sessionService.respondToPermissionRequest(sessionId, requestId, allow)`. Update it to also handle `optionId`:

```typescript
export function createPermissionResponseHandler(): ChatMessageHandler<PermissionResponseMessage> {
  return ({ ws, sessionId, message }) => {
    const { requestId, allow, optionId } = message;

    try {
      if (optionId) {
        // ACP permission response -- route through bridge
        const resolved = sessionService.respondToAcpPermission(sessionId, requestId, optionId);
        if (!resolved) {
          // Fallback to legacy handler if bridge doesn't have this request
          sessionService.respondToPermissionRequest(sessionId, requestId, allow);
        }
      } else {
        // Legacy Claude/Codex permission response
        sessionService.respondToPermissionRequest(sessionId, requestId, allow);
      }
      // ... keep existing logging ...
    } catch (error) {
      // ... keep existing error handling ...
    } finally {
      clearPendingInteractiveRequest(sessionId, requestId);
    }
  };
}
```

Note: `message.optionId` is now available because we extended the Zod schema in Task 1.
  </action>
  <verify>
Run `pnpm typecheck` -- no type errors across entire codebase.
Run `pnpm test` -- all existing tests pass (no regressions).
Run `pnpm check:fix` -- lint clean.
Run `pnpm deps:check` -- no dependency-cruiser violations (AcpPermissionBridge imported within same domain).
Verify that `sessionFileLogger.log()` is still the FIRST call in AcpClientHandler.sessionUpdate (grep for the call).
Verify that AcpRuntimeEventHandlers type includes `permissionBridge` field (grep acp-runtime-manager.ts).
Verify that AcpClientHandler constructor accepts 4th parameter `permissionBridge` (grep acp-client-handler.ts).
  </verify>
  <done>
ACP event translation flows through AcpEventTranslator. Permission requests suspend via AcpPermissionBridge injected through AcpRuntimeEventHandlers -> AcpRuntimeManager -> AcpClientHandler constructor. Session file logging preserved as first action in sessionUpdate for all events. Session cleanup cancels pending permissions. All existing Claude/Codex flows unchanged.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` -- no type errors across entire codebase
2. `pnpm test` -- all tests pass (existing + Plan 01 tests still pass)
3. `pnpm check:fix` -- lint clean
4. `pnpm deps:check` -- no dependency-cruiser violations
5. Verify AcpClientHandler no longer has inline switch for event mapping
6. Verify AcpClientHandler.sessionUpdate still calls sessionFileLogger.log FIRST before forwarding
7. Verify permission_response Zod schema accepts optionId
8. Verify AcpRuntimeManager passes permissionBridge from handlers to AcpClientHandler constructor
</verification>

<success_criteria>
- ACP events flow: AcpClientHandler -> onAcpEvent -> AcpEventTranslator -> emitDelta -> WebSocket
- Bridge injection: session.service.ts creates bridge -> passes via AcpRuntimeEventHandlers.permissionBridge -> AcpRuntimeManager reads from handlers -> passes to AcpClientHandler constructor
- Permission flow: AcpClientHandler.requestPermission -> bridge.waitForUserResponse -> (WebSocket push) -> user responds -> handler calls respondToAcpPermission -> bridge.resolvePermission -> Promise resolves -> response to ACP agent
- Session file logging preserved: sessionFileLogger.log called first in sessionUpdate for ALL events before forwarding
- All shared types are backward-compatible (acpOptions and optionId are optional)
- All existing tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-event-translation-permissions/20-02-SUMMARY.md`
</output>

---
phase: 20-event-translation-permissions
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/backend/domains/session/acp/acp-client-handler.ts
  - src/backend/domains/session/acp/index.ts
  - src/backend/domains/session/lifecycle/session.service.ts
  - src/shared/claude/protocol/websocket.ts
  - src/shared/claude/protocol/interaction.ts
  - src/shared/websocket/chat-message.schema.ts
  - src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts
autonomous: true

must_haves:
  truths:
    - "ACP session updates flow through AcpEventTranslator to emitDelta instead of inline switch"
    - "AcpClientHandler.requestPermission suspends via AcpPermissionBridge instead of auto-approving"
    - "Permission requests from ACP sessions include acpOptions array in the WebSocket payload"
    - "Permission responses from ACP sessions carry optionId back to resolve the bridge Promise"
    - "Session stop/cancel calls bridge.cancelAll() to resolve pending permissions with cancelled outcome"
    - "WebSocket permission_response schema accepts optional optionId field"
  artifacts:
    - path: "src/backend/domains/session/acp/acp-client-handler.ts"
      provides: "Updated AcpClientHandler using AcpPermissionBridge for requestPermission"
      exports: ["AcpClientHandler", "AcpEventCallback"]
    - path: "src/backend/domains/session/lifecycle/session.service.ts"
      provides: "setupAcpEventHandler using AcpEventTranslator, ACP permission routing in respondToPermissionRequest"
    - path: "src/shared/claude/protocol/websocket.ts"
      provides: "permission_request type extended with acpOptions field"
    - path: "src/shared/websocket/chat-message.schema.ts"
      provides: "permission_response schema with optional optionId field"
    - path: "src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts"
      provides: "ACP permission routing via bridge.resolvePermission when optionId present"
  key_links:
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/acp/acp-event-translator.ts"
      via: "import and use in setupAcpEventHandler"
      pattern: "AcpEventTranslator"
    - from: "src/backend/domains/session/lifecycle/session.service.ts"
      to: "src/backend/domains/session/acp/acp-permission-bridge.ts"
      via: "per-session bridge instance for permission management"
      pattern: "AcpPermissionBridge"
    - from: "src/backend/domains/session/acp/acp-client-handler.ts"
      to: "src/backend/domains/session/acp/acp-permission-bridge.ts"
      via: "constructor injection, requestPermission delegates to bridge"
      pattern: "this\\.permissionBridge\\.waitForUserResponse"
    - from: "src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts"
      to: "src/backend/domains/session/lifecycle/session.service.ts"
      via: "calls respondToPermissionRequest with optionId for ACP"
      pattern: "optionId"
---

<objective>
Wire the AcpEventTranslator and AcpPermissionBridge from Plan 01 into the session service, update AcpClientHandler to use the bridge, extend WebSocket types for ACP permission options, and update the permission response handler for ACP optionId routing.

Purpose: This plan connects the isolated translator and bridge classes to the live event pipeline. After this plan, ACP sessions will emit rich delta events (thinking, plans, slash commands, full tool lifecycle) and permission requests will suspend until the user responds via WebSocket.

Output: End-to-end backend flow where ACP events translate to delta events and permission requests round-trip through the WebSocket protocol with optionId.
</objective>

<execution_context>
@/Users/martin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-event-translation-permissions/20-RESEARCH.md
@.planning/phases/20-event-translation-permissions/20-01-SUMMARY.md
@src/backend/domains/session/lifecycle/session.service.ts
@src/backend/domains/session/acp/acp-client-handler.ts
@src/backend/domains/session/acp/acp-runtime-manager.ts
@src/backend/domains/session/acp/index.ts
@src/shared/claude/protocol/websocket.ts
@src/shared/claude/protocol/interaction.ts
@src/shared/websocket/chat-message.schema.ts
@src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts
@src/components/chat/reducer/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend shared types for ACP permission options and plan events</name>
  <files>
    src/shared/claude/protocol/websocket.ts
    src/shared/claude/protocol/interaction.ts
    src/shared/websocket/chat-message.schema.ts
  </files>
  <action>
**1. Extend `permission_request` payload in `src/shared/claude/protocol/websocket.ts`:**

In the `WebSocketMessagePayloadByType` interface, update the `permission_request` entry to add an optional `acpOptions` field:

```typescript
permission_request: {
  requestId?: string;
  toolName?: string;
  toolUseId?: string;
  toolInput?: Record<string, unknown>;
  planContent?: string | null;
  /** ACP permission options -- when present, frontend renders multi-option buttons instead of binary Allow/Deny */
  acpOptions?: Array<{
    optionId: string;
    name: string;
    kind: 'allow_once' | 'allow_always' | 'reject_once' | 'reject_always';
  }>;
};
```

This is additive -- existing Claude/Codex permission flows that omit `acpOptions` continue to work unchanged.

**2. Extend `PermissionRequest` in `src/shared/claude/protocol/interaction.ts`:**

Add the same `acpOptions` field to the `PermissionRequest` interface:

```typescript
export interface PermissionRequest {
  requestId: string;
  toolName: string;
  toolInput: Record<string, unknown>;
  timestamp: string;
  planContent?: string | null;
  /** ACP permission options for multi-option UI. When present, frontend renders option buttons. */
  acpOptions?: Array<{
    optionId: string;
    name: string;
    kind: 'allow_once' | 'allow_always' | 'reject_once' | 'reject_always';
  }>;
}
```

**3. Extend `permission_response` schema in `src/shared/websocket/chat-message.schema.ts`:**

Update the `permission_response` variant in `ChatMessageSchema` to accept an optional `optionId`:

```typescript
z.object({
  type: z.literal('permission_response'),
  requestId: z.string().min(1),
  allow: z.boolean(),
  /** ACP permission option ID -- when present, takes precedence over boolean allow */
  optionId: z.string().optional(),
}),
```

Also update the `PermissionResponseMessage` type extraction at the bottom of the file -- it should automatically pick up the new field from the schema inference.

Verify that these are purely additive changes -- no existing field types change, no existing fields removed. The `acpOptions` and `optionId` fields are optional, so all existing code continues to work.
  </action>
  <verify>
Run `pnpm typecheck` -- no type errors. All existing code that uses PermissionRequest, permission_request, and permission_response still compiles.
  </verify>
  <done>
WebSocket protocol types extended with acpOptions on permission_request and optionId on permission_response. All changes are additive and backward-compatible.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire translator and bridge into session service and permission handler</name>
  <files>
    src/backend/domains/session/acp/acp-client-handler.ts
    src/backend/domains/session/acp/index.ts
    src/backend/domains/session/lifecycle/session.service.ts
    src/backend/domains/session/chat/chat-message-handlers/handlers/permission-response.handler.ts
  </files>
  <action>
**1. Update AcpClientHandler to accept and use AcpPermissionBridge (`acp-client-handler.ts`):**

- Add `AcpPermissionBridge` as a constructor parameter (injection pattern):
  ```typescript
  constructor(
    sessionId: string,
    onEvent: AcpEventCallback,
    logger: ReturnType<typeof createLogger>,
    permissionBridge?: AcpPermissionBridge  // Optional for backward compat with tests
  )
  ```
- Store as `private readonly permissionBridge: AcpPermissionBridge | null`.

- In `sessionUpdate()`: Instead of the inline switch that maps events, delegate to a new callback pattern. Forward ALL events (including previously deferred ones) via `this.onEvent`. The event payload should include the raw `update` object from the SDK so that the session service can use AcpEventTranslator:
  ```typescript
  async sessionUpdate(params: SessionNotification): Promise<void> {
    const update = params.update;
    // Log ALL events to session file logger (EVENT-06)
    sessionFileLogger.log(this.sessionId, 'FROM_CLAUDE_CLI', {
      eventType: 'acp_session_update',
      sessionUpdate: update.sessionUpdate,
      data: update,
    });
    // Forward the raw update to session service for translation
    this.onEvent(this.sessionId, { type: 'acp_session_update', update });
  }
  ```

- In `requestPermission()`: When bridge is available, generate a unique requestId (use `crypto.randomUUID()`), emit a permission request event via `this.onEvent`, then await the bridge:
  ```typescript
  async requestPermission(params: RequestPermissionRequest): Promise<RequestPermissionResponse> {
    // Log to session file logger
    sessionFileLogger.log(this.sessionId, 'FROM_CLAUDE_CLI', { ... });

    if (!this.permissionBridge) {
      // Fallback to auto-approve (Phase 19 behavior)
      const allowOption = params.options.find(o => o.kind === 'allow_always' || o.kind === 'allow_once');
      return { outcome: { outcome: 'selected', optionId: allowOption?.optionId ?? params.options[0]?.optionId ?? 'unknown' } };
    }

    const requestId = crypto.randomUUID();
    // Emit permission request event for WebSocket push
    this.onEvent(this.sessionId, {
      type: 'acp_permission_request',
      requestId,
      params,
    });
    // Suspend until user responds
    return this.permissionBridge.waitForUserResponse(requestId, params);
  }
  ```

**2. Update barrel exports (`acp/index.ts`):**

Add exports for AcpEventTranslator and AcpPermissionBridge:
```typescript
export { AcpEventTranslator } from './acp-event-translator';
export { AcpPermissionBridge } from './acp-permission-bridge';
```

**3. Rewrite `setupAcpEventHandler` in `session.service.ts`:**

- Import `AcpEventTranslator` and `AcpPermissionBridge` from the acp barrel.
- Create an `AcpEventTranslator` instance (stateless, can be shared or per-session).
- Create an `AcpPermissionBridge` instance per session (stores per-session pending promises).
- Store the bridge in a `Map<string, AcpPermissionBridge>` on the SessionService class so it can be accessed by the permission response handler.

Replace the existing `onAcpEvent` handler:

```typescript
private readonly acpEventTranslator = new AcpEventTranslator();
private readonly acpPermissionBridges = new Map<string, AcpPermissionBridge>();

private setupAcpEventHandler(sessionId: string): AcpRuntimeEventHandlers {
  const bridge = new AcpPermissionBridge();
  this.acpPermissionBridges.set(sessionId, bridge);

  return {
    onAcpEvent: (sid: string, event: unknown) => {
      const typed = event as { type: string };

      if (typed.type === 'acp_session_update') {
        const { update } = event as { type: string; update: import('@agentclientprotocol/sdk').SessionUpdate };
        const deltas = this.acpEventTranslator.translateSessionUpdate(update);
        for (const delta of deltas) {
          sessionDomainService.emitDelta(sid, delta);
        }
        return;
      }

      if (typed.type === 'acp_permission_request') {
        const { requestId, params } = event as {
          type: string;
          requestId: string;
          params: import('@agentclientprotocol/sdk').RequestPermissionRequest;
        };
        // Emit permission_request delta with ACP options
        sessionDomainService.emitDelta(sid, {
          type: 'permission_request',
          requestId,
          toolName: params.toolCall.title ?? 'ACP Tool',
          toolUseId: params.toolCall.toolCallId,
          toolInput: (params.toolCall.rawInput as Record<string, unknown>) ?? {},
          acpOptions: params.options.map(o => ({
            optionId: o.optionId,
            name: o.name,
            kind: o.kind,
          })),
        });
        // Also store as pending interactive request for session restore
        sessionDomainService.setPendingInteractiveRequest(sid, {
          requestId,
          toolName: params.toolCall.title ?? 'ACP Tool',
          toolUseId: params.toolCall.toolCallId,
          input: (params.toolCall.rawInput as Record<string, unknown>) ?? {},
          planContent: null,
          timestamp: new Date().toISOString(),
        });
        return;
      }
    },
    onSessionId: async (sid, providerSessionId) => { /* keep existing */ },
    onExit: async (sid, exitCode) => {
      // Add bridge cleanup
      const b = this.acpPermissionBridges.get(sid);
      if (b) {
        b.cancelAll();
        this.acpPermissionBridges.delete(sid);
      }
      // ... keep existing exit logic ...
    },
    onError: (sid, error) => { /* keep existing */ },
  };
}
```

- Pass the bridge to AcpClientHandler in `createAcpClient`. The AcpRuntimeManager.getOrCreateClient receives handlers -- the bridge needs to be passed to the AcpClientHandler constructor. Look at how `acpRuntimeManager.getOrCreateClient` creates the AcpClientHandler. The bridge should be passed as an additional option or the `onEvent` callback in handlers already bridges through. Since AcpClientHandler is constructed inside AcpRuntimeManager, update the `AcpRuntimeEventHandlers` type to include an optional `permissionBridge` field, and pass it through to the AcpClientHandler constructor in `AcpRuntimeManager.getOrCreateClient`. Alternatively, if that requires too many changes to the runtime manager, add the bridge as part of the `AcpClientOptions` since that's already passed to getOrCreateClient. Use whichever approach requires fewer changes.

- Add a public method for ACP permission resolution:
  ```typescript
  respondToAcpPermission(sessionId: string, requestId: string, optionId: string): boolean {
    const bridge = this.acpPermissionBridges.get(sessionId);
    if (!bridge) return false;
    return bridge.resolvePermission(requestId, optionId);
  }
  ```

- In `stopSession` and any session cleanup paths, call `bridge.cancelAll()` before deleting the bridge entry.

**4. Update `permission-response.handler.ts` to route ACP permissions:**

The handler currently calls `sessionService.respondToPermissionRequest(sessionId, requestId, allow)`. Update it to also handle `optionId`:

```typescript
export function createPermissionResponseHandler(): ChatMessageHandler<PermissionResponseMessage> {
  return ({ ws, sessionId, message }) => {
    const { requestId, allow, optionId } = message;

    try {
      if (optionId) {
        // ACP permission response -- route through bridge
        const resolved = sessionService.respondToAcpPermission(sessionId, requestId, optionId);
        if (!resolved) {
          // Fallback to legacy handler if bridge doesn't have this request
          sessionService.respondToPermissionRequest(sessionId, requestId, allow);
        }
      } else {
        // Legacy Claude/Codex permission response
        sessionService.respondToPermissionRequest(sessionId, requestId, allow);
      }
      // ... keep existing logging ...
    } catch (error) {
      // ... keep existing error handling ...
    } finally {
      clearPendingInteractiveRequest(sessionId, requestId);
    }
  };
}
```

Note: `message.optionId` is now available because we extended the Zod schema in Task 1.
  </action>
  <verify>
Run `pnpm typecheck` -- no type errors.
Run `pnpm test` -- all existing tests pass (no regressions).
Run `pnpm check:fix` -- lint clean.
  </verify>
  <done>
ACP event translation flows through AcpEventTranslator. Permission requests suspend via AcpPermissionBridge and resolve when user responds with optionId. Session cleanup cancels pending permissions. All existing Claude/Codex flows unchanged.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` -- no type errors across entire codebase
2. `pnpm test` -- all tests pass (existing + Plan 01 tests still pass)
3. `pnpm check:fix` -- lint clean
4. `pnpm deps:check` -- no dependency-cruiser violations
5. Verify AcpClientHandler no longer has inline switch for event mapping
6. Verify permission_response Zod schema accepts optionId
</verification>

<success_criteria>
- ACP events flow: AcpClientHandler -> onAcpEvent -> AcpEventTranslator -> emitDelta -> WebSocket
- Permission flow: AcpClientHandler.requestPermission -> bridge.waitForUserResponse -> (WebSocket push) -> user responds -> handler calls respondToAcpPermission -> bridge.resolvePermission -> Promise resolves -> response to ACP agent
- All shared types are backward-compatible (acpOptions and optionId are optional)
- All existing tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-event-translation-permissions/20-02-SUMMARY.md`
</output>

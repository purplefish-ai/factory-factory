# Coding Conventions

**Analysis Date:** 2026-02-01

## Naming Patterns

**Files:**
- Services: `*.service.ts` (e.g., `logger.service.ts`, `terminal.service.ts`)
- Routers/Controllers: `*.router.ts`, `*.trpc.ts` (e.g., `health.router.ts`, `workspace.trpc.ts`)
- Clients: `*.client.ts` (e.g., `git.client.ts`)
- Resource accessors: `*.accessor.ts` (e.g., `project.accessor.ts`, `workspace.accessor.ts`)
- Test files: `*.test.ts` or `*.test.tsx` (co-located with source)
- Middleware: `*.middleware.ts` (e.g., `cors.middleware.ts`, `security.middleware.ts`)
- Type definitions: `*.d.ts` for ambient declarations
- UI Components: `*.tsx` (e.g., `error-boundary.tsx`)

**Functions:**
- camelCase for all function names
- Exported functions use descriptive verb phrases: `isAutoGeneratedBranchName()`, `getProjectPath()`, `parseGitStatusOutput()`
- Helper/utility functions with underscore prefix only in special cases (shell helper: `gitCommand`, `gitCommandC`)
- Async functions: no special prefix, return type indicates async

**Variables:**
- camelCase for constants in function scope
- UPPER_SNAKE_CASE for true constants (e.g., `DEFAULT_GIT_CONCURRENCY`, `REVIEW_CACHE_TTL_MS`, `HTTP_STATUS`)
- Prefix `mock` for vi.fn() test mocks (e.g., `mockFindById`, `mockGetTerminal`)
- Prefix `set` for state setters in React (e.g., `setHasError`)

**Types:**
- PascalCase for all types and interfaces
- Suffixes: `Props` for React component props, `State` for component state, `Options` for configuration objects
- Examples: `ErrorBoundaryProps`, `ErrorBoundaryState`, `CreateWorktreeOptions`, `GitClientConfig`
- Export types with `type` keyword for tree-shaking

**Classes:**
- PascalCase (e.g., `Logger`, `GitClient`, `SessionManager`)
- Private fields use `private` keyword (e.g., `private config: LoggerConfig`)
- Methods use camelCase

**Directories:**
- Lowercase with hyphens for multi-word names
- Examples: `resource_accessors`, `claude-session.accessor.ts`, but standard like `services`, `lib`, `utils`
- Organize by layer: `backend/services`, `backend/trpc`, `backend/resource_accessors`, `backend/routers`

## Code Style

**Formatting:**
- Tool: Biome 2.3.13
- Indent: 2 spaces
- Line width: 100 characters
- Semicolons: always enabled
- Trailing commas: ES5 style (trailing commas in objects/arrays where valid in ES5)

**Linting:**
- Tool: Biome with strict rules enabled
- Config: `biome.json` at root
- Key enforced rules:
  - `noUnusedVariables: error` - All declared variables must be used
  - `noUnusedImports: error` - All imports must be used
  - `noUnusedFunctionParameters: error` - Function parameters must be used
  - `useExhaustiveDependencies: error` - React hooks must have complete dependency arrays
  - `useHookAtTopLevel: error` - Hooks must be called at top level
  - `useConst: error` - Use `const` over `let` when variable is not reassigned
  - `useImportType: error` - Use `import type` for type-only imports
  - `noNonNullAssertion: error` - Never use non-null assertion operator
  - `noExplicitAny: error` - Never use `any` type
  - `noDoubleEquals: error` - Use `===` and `!==` only
  - `noConsole: error` - Except in logger.service.ts, debug.ts, cli/**, scripts/**, electron/**
  - `useAwait: error` - Never forget `await` on promises
  - `useOptionalChain: error` - Use optional chaining where applicable

**Special overrides in `biome.json`:**
- `noConsole: off` in: `src/backend/services/logger.service.ts`, `src/lib/debug.ts`, `src/cli/**`, `scripts/**`, `electron/**`
- CSS: `noInvalidPositionAtImportRule: off` for @import ordering
- CSS: `noImportantStyles: off` for CSS !important usage in overrides

## Import Organization

**Order:**
1. Node.js built-in modules (with `node:` prefix): `import * as fs from 'node:fs/promises'`
2. Third-party packages: `import { z } from 'zod'`, `import express from 'express'`
3. Prisma generated types: `import type { Project } from '@prisma-gen/client'`
4. Internal application code: `import { logger } from '../services/logger.service'`
5. Relative imports from same layer or parent: `import { gitCommand } from '../lib/shell'`

**Rules:**
- All imports automatically organized by Biome (assist.actions.source.organizeImports: on)
- Type-only imports: use `import type` syntax (enforced by `useImportType` rule)
- Node.js imports must use `node:` protocol prefix (enforced by `useNodejsImportProtocol` rule)
- No default imports for functions (use named imports)

**Path Aliases:**
- `@/*` → `src/`
- `@prisma-gen/*` → `prisma/generated/`
- Used in tsconfig.json, vitest.config.ts
- Example: `import { createLogger } from '@/backend/services/logger.service'`

## Error Handling

**Patterns:**
- Never use try-catch for control flow; only for exception handling
- Always catch `Error` instances with type guard: `error instanceof Error ? error.message : String(error)`
- Errors logged with context object: `logger.debug('message', { errorKey: error.message })`
- Async operations use Promise rejection, not throwing in callbacks
- Expected failures (e.g., branch doesn't exist) should return null/empty rather than throw
- Async functions that fail should catch and log at appropriate level (debug for non-critical, error for critical)

**Examples from codebase:**
```typescript
// In workspace.trpc.ts - Expected failure returns null
try {
  gitStatsResults[workspace.id] = await getWorkspaceGitStats(workspace.worktreePath, defaultBranch);
} catch (error) {
  logger.debug('Failed to get git stats for workspace', {
    workspaceId: workspace.id,
    error: error instanceof Error ? error.message : String(error),
  });
  gitStatsResults[workspace.id] = null;
}
```

**Logging:**
- Structured logging with context objects, never string concatenation
- Log levels: error (critical failures), warn (degraded function), info (important events), debug (development details)
- Logger created once per module: `const logger = createLogger('component-name')`
- Child loggers: `logger.child('subcomponent')` for nested contexts

## Comments

**When to Comment:**
- Complex algorithms: explain the "why" not the "what" (code shows what, comment explains why)
- Non-obvious business logic: why this check exists
- Workarounds for bugs/limitations: reference issue if available
- Performance critical sections: explain optimization
- Gotchas: edge cases that aren't obvious from code

**JSDoc/TSDoc:**
- Document exported functions and public class methods
- Document complex types and interfaces
- Format: `/** Description here */` on line before declaration
- Include parameter descriptions for non-obvious params
- Include return type description if complex

**Example from codebase:**
```typescript
/**
 * Check if a branch name matches the auto-generated pattern.
 * Auto-generated branches have format: {prefix}/{6-hex-chars} or just {6-hex-chars}
 * The prefix can contain multiple segments (e.g., "user-name/feature/abc123").
 */
export function isAutoGeneratedBranchName(branchName: string): boolean {
```

## Function Design

**Size:**
- Prefer functions under 50 lines for readability
- Break complex operations into smaller named functions
- Each function should have single responsibility

**Parameters:**
- Prefer named parameters in objects over multiple positional args when function has 3+ parameters
- Always use type annotations
- Optional parameters should have defaults or be clearly marked optional

**Return Values:**
- Explicit return type annotations required
- Consistent return patterns: return null for "not found", empty array for "no results"
- Promise-returning functions clearly typed as `Promise<T>`
- No implicit returns (TSConfig: noImplicitReturns: true)

## Module Design

**Exports:**
- Named exports preferred over default exports
- Re-export for backward compatibility acceptable (see workspace.trpc.ts pattern)
- Export types with `type` keyword: `export type GitFileStatus = ...`
- Export interfaces and enums directly

**Barrel Files:**
- Used in `src/backend/services/index.ts` for service aggregation
- Pattern: export multiple services from single file for convenience importing
- Example: `import { configService, createLogger } from '../../services/index'`

**Service Singleton Pattern:**
- Services exported as singletons where applicable
- Example: `export const configService = new ConfigService()`
- Accessed via import, not instantiated in consuming code

## TypeScript Strictness

**Required Configurations:**
- `strict: true` - All strict checks enabled
- `noImplicitAny: true` - Explicit types required
- `strictNullChecks: true` - Null/undefined must be explicit in types
- `noUnusedLocals: true` - All locals must be used
- `noUnusedParameters: true` - All parameters must be used
- `noImplicitReturns: true` - All code paths must return
- `forceConsistentCasingInFileNames: true` - Consistent casing enforced

**Consequences:**
- Never use `any` type
- Always explicitly handle null/undefined with type guards
- All function code paths must explicitly return a value
- Cannot declare variables or parameters without using them

---

*Convention analysis: 2026-02-01*

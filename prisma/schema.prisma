// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "./generated"
}

datasource db {
  provider = "postgresql"
}

// Enums
enum TaskState {
  // Parent task states (for tasks with children)
  PLANNING       // Task is being planned/broken down
  PLANNED        // Subtasks created, ready for execution

  // Leaf task states (for implementable tasks)
  PENDING        // Task waiting to be picked up
  ASSIGNED       // Task assigned to an agent
  IN_PROGRESS    // Task being worked on
  REVIEW         // Task waiting for review

  // Terminal states (any task)
  COMPLETED      // Task completed successfully
  BLOCKED        // Task is blocked (dependencies or external)
  FAILED         // Task failed
  CANCELLED      // Task was cancelled
}

enum AgentType {
  SUPERVISOR     // High-level orchestrator
  ORCHESTRATOR   // Epic-level manager
  WORKER         // Task executor
}

enum AgentState {
  IDLE           // Agent is idle
  BUSY           // Agent is working
  WAITING        // Agent is waiting for something
  FAILED         // Agent encountered an error
}

// Models
model Project {
  id                String      @id @default(cuid())
  name              String
  slug              String      @unique
  repoPath          String
  worktreeBasePath  String
  defaultBranch     String      @default("main")
  githubOwner       String?
  githubRepo        String?
  isArchived        Boolean     @default(false)
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Relations
  tasks             Task[]

  @@index([slug])
  @@index([isArchived])
}

model Task {
  id                String      @id @default(cuid())
  projectId         String
  parentId          String?     // null = top-level (was "Epic")
  title             String
  description       String?     @db.Text
  state             TaskState   @default(PENDING)

  // Linear integration (only for top-level tasks)
  linearIssueId     String?     @unique
  linearIssueUrl    String?

  // Execution tracking (for leaf tasks)
  assignedAgentId   String?
  worktreePath      String?
  branchName        String?
  prUrl             String?
  attempts          Int         @default(0)
  failureReason     String?     @db.Text

  // Timestamps
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  completedAt       DateTime?

  // Relations
  project           Project     @relation(fields: [projectId], references: [id])
  parent            Task?       @relation("TaskHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children          Task[]      @relation("TaskHierarchy")
  assignedAgent     Agent?      @relation("AssignedTasks", fields: [assignedAgentId], references: [id])
  supervisorAgent   Agent?      @relation("SupervisorTask")

  // Dependencies
  dependsOn         TaskDependency[] @relation("DependentTask")
  dependents        TaskDependency[] @relation("DependsOnTask")

  @@index([projectId])
  @@index([parentId])
  @@index([state])
  @@index([linearIssueId])
  @@index([assignedAgentId])
}

model TaskDependency {
  id                String      @id @default(cuid())
  taskId            String      // The task that has the dependency (is blocked)
  dependsOnId       String      // The task it depends on
  createdAt         DateTime    @default(now())

  // Relations
  task              Task        @relation("DependentTask", fields: [taskId], references: [id], onDelete: Cascade)
  dependsOn         Task        @relation("DependsOnTask", fields: [dependsOnId], references: [id], onDelete: Cascade)

  @@unique([taskId, dependsOnId])
  @@index([taskId])
  @@index([dependsOnId])
}

model Agent {
  id                String      @id @default(cuid())
  type              AgentType
  state             AgentState  @default(IDLE)
  currentTaskId     String?     @unique  // For both supervisors (top-level) and workers (leaf)
  tmuxSessionName   String?
  sessionId         String?     // Claude Code CLI session ID for resume
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  lastActiveAt      DateTime    @default(now())

  // Relations
  currentTask       Task?       @relation("SupervisorTask", fields: [currentTaskId], references: [id])
  assignedTasks     Task[]      @relation("AssignedTasks")
  mailReceived      Mail[]      @relation("ReceiverAgent")
  mailSent          Mail[]      @relation("SenderAgent")
  decisionLogs      DecisionLog[]

  @@index([type])
  @@index([state])
  @@index([currentTaskId])
}

model Mail {
  id                String      @id @default(cuid())
  fromAgentId       String?
  toAgentId         String?
  isForHuman        Boolean     @default(false)
  subject           String
  body              String      @db.Text
  isRead            Boolean     @default(false)
  createdAt         DateTime    @default(now())
  readAt            DateTime?

  // Relations
  fromAgent         Agent?      @relation("SenderAgent", fields: [fromAgentId], references: [id])
  toAgent           Agent?      @relation("ReceiverAgent", fields: [toAgentId], references: [id])

  @@index([toAgentId, isRead])
  @@index([isForHuman, isRead])
  @@index([createdAt])
}

model DecisionLog {
  id                String      @id @default(cuid())
  agentId           String
  decision          String      @db.Text
  reasoning         String      @db.Text
  context           String?     @db.Text
  timestamp         DateTime    @default(now())

  // Relations
  agent             Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@index([agentId, timestamp])
  @@index([timestamp])
}

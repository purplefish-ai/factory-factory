// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "./generated"
}

datasource db {
  provider = "postgresql"
}

// Enums

// Task state - about the WORK being done
enum TaskState {
  PENDING        // Not started (subtasks waiting to be picked up)
  PLANNING       // Top-level only: supervisor breaking down work
  IN_PROGRESS    // Being worked on (replaces ASSIGNED, PLANNED)
  REVIEW         // Submitted for review
  COMPLETED      // Work accepted and merged
  FAILED         // Work abandoned
  BLOCKED        // External blocker (dependencies, etc.)
}

enum AgentType {
  SUPERVISOR     // High-level orchestrator
  ORCHESTRATOR   // Epic-level manager
  WORKER         // Task executor
}

// Agent execution state - what the agent IS currently doing (actual state)
enum ExecutionState {
  IDLE           // Agent is idle, not running
  ACTIVE         // Agent is actively running
  PAUSED         // Agent is paused but can be resumed
  CRASHED        // Agent process crashed unexpectedly
}

// Desired execution state - what we WANT the agent to be doing
// (subset of ExecutionState - CRASHED is never desired)
enum DesiredExecutionState {
  IDLE           // We want the agent to be idle/stopped
  ACTIVE         // We want the agent to be running
  PAUSED         // We want the agent to be paused
}

// Models
model Project {
  id                String      @id @default(cuid())
  name              String
  slug              String      @unique
  repoPath          String
  worktreeBasePath  String
  defaultBranch     String      @default("main")
  githubOwner       String?
  githubRepo        String?
  isArchived        Boolean     @default(false)
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Relations
  tasks             Task[]

  @@index([slug])
  @@index([isArchived])
}

model Task {
  id                String      @id @default(cuid())
  projectId         String
  parentId          String?     // null = top-level (was "Epic")
  title             String
  description       String?     @db.Text
  state             TaskState   @default(PENDING)

  // Execution tracking (for leaf tasks)
  assignedAgentId   String?
  worktreePath      String?
  branchName        String?
  prUrl             String?     // Draft PR URL, created after first commit
  attempts          Int         @default(0)
  failureReason     String?     @db.Text

  // Reconciliation tracking
  lastReconcileAt   DateTime?   // Last time this task was reconciled
  reconcileFailures Json?       // Array of {timestamp, error, action} for debugging

  // Timestamps
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  completedAt       DateTime?

  // Relations
  project           Project     @relation(fields: [projectId], references: [id])
  parent            Task?       @relation("TaskHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children          Task[]      @relation("TaskHierarchy")
  assignedAgent     Agent?      @relation("AssignedTasks", fields: [assignedAgentId], references: [id])
  supervisorAgent   Agent?      @relation("SupervisorTask")

  // Dependencies
  dependsOn         TaskDependency[] @relation("DependentTask")
  dependents        TaskDependency[] @relation("DependsOnTask")

  @@index([projectId])
  @@index([parentId])
  @@index([state])
  @@index([assignedAgentId])
  @@index([lastReconcileAt])
}

model TaskDependency {
  id                String      @id @default(cuid())
  taskId            String      // The task that has the dependency (is blocked)
  dependsOnId       String      // The task it depends on
  createdAt         DateTime    @default(now())

  // Relations
  task              Task        @relation("DependentTask", fields: [taskId], references: [id], onDelete: Cascade)
  dependsOn         Task        @relation("DependsOnTask", fields: [dependsOnId], references: [id], onDelete: Cascade)

  @@unique([taskId, dependsOnId])
  @@index([taskId])
  @@index([dependsOnId])
}

model Agent {
  id                      String              @id @default(cuid())
  type                    AgentType
  currentTaskId           String?             @unique  // For both supervisors (top-level) and workers (leaf)

  // Execution state (reconciler-managed)
  executionState          ExecutionState      @default(IDLE)    // ACTUAL: what agent IS doing
  desiredExecutionState   DesiredExecutionState @default(IDLE)  // WANTED: what we want agent to do

  // Session management
  tmuxSessionName         String?
  sessionId               String?             // Claude Code CLI session ID for resume

  // Health tracking
  lastHeartbeat           DateTime?           // Last agent heartbeat (set by agent itself)
  lastReconcileAt         DateTime?           // Last time this agent was reconciled
  reconcileFailures       Json?               // Array of {timestamp, error, action} for debugging

  // Timestamps
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt

  // Relations
  currentTask             Task?               @relation("SupervisorTask", fields: [currentTaskId], references: [id])
  assignedTasks           Task[]              @relation("AssignedTasks")
  mailReceived            Mail[]              @relation("ReceiverAgent")
  mailSent                Mail[]              @relation("SenderAgent")
  decisionLogs            DecisionLog[]

  @@index([type])
  @@index([executionState])
  @@index([desiredExecutionState])
  @@index([currentTaskId])
  @@index([lastHeartbeat])
}

model Mail {
  id                String      @id @default(cuid())
  fromAgentId       String?
  toAgentId         String?
  isForHuman        Boolean     @default(false)
  subject           String
  body              String      @db.Text
  isRead            Boolean     @default(false)
  createdAt         DateTime    @default(now())
  readAt            DateTime?

  // Relations
  fromAgent         Agent?      @relation("SenderAgent", fields: [fromAgentId], references: [id])
  toAgent           Agent?      @relation("ReceiverAgent", fields: [toAgentId], references: [id])

  @@index([toAgentId, isRead])
  @@index([isForHuman, isRead])
  @@index([createdAt])
}

model DecisionLog {
  id                String      @id @default(cuid())
  agentId           String
  decision          String      @db.Text
  reasoning         String      @db.Text
  context           String?     @db.Text
  timestamp         DateTime    @default(now())

  // Relations
  agent             Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@index([agentId, timestamp])
  @@index([timestamp])
}
